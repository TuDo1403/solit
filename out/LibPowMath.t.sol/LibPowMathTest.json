{
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "name": "log",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "log_address",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "val",
          "type": "uint256[]"
        }
      ],
      "name": "log_array",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "int256[]",
          "name": "val",
          "type": "int256[]"
        }
      ],
      "name": "log_array",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "val",
          "type": "address[]"
        }
      ],
      "name": "log_array",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "log_bytes",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "log_bytes32",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "int256",
          "name": "",
          "type": "int256"
        }
      ],
      "name": "log_int",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "key",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "val",
          "type": "address"
        }
      ],
      "name": "log_named_address",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "key",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "val",
          "type": "uint256[]"
        }
      ],
      "name": "log_named_array",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "key",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "int256[]",
          "name": "val",
          "type": "int256[]"
        }
      ],
      "name": "log_named_array",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "key",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "val",
          "type": "address[]"
        }
      ],
      "name": "log_named_array",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "key",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "val",
          "type": "bytes"
        }
      ],
      "name": "log_named_bytes",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "key",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "val",
          "type": "bytes32"
        }
      ],
      "name": "log_named_bytes32",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "key",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "val",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "decimals",
          "type": "uint256"
        }
      ],
      "name": "log_named_decimal_int",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "key",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "val",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "decimals",
          "type": "uint256"
        }
      ],
      "name": "log_named_decimal_uint",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "key",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "val",
          "type": "int256"
        }
      ],
      "name": "log_named_int",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "key",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "val",
          "type": "string"
        }
      ],
      "name": "log_named_string",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "key",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "val",
          "type": "uint256"
        }
      ],
      "name": "log_named_uint",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "name": "log_string",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "log_uint",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "logs",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "IS_TEST",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PRECISION",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "excludeArtifacts",
      "outputs": [
        {
          "internalType": "string[]",
          "name": "excludedArtifacts_",
          "type": "string[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "excludeContracts",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "excludedContracts_",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "excludeSenders",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "excludedSenders_",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "failed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "y",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "d",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "n",
          "type": "uint8"
        }
      ],
      "name": "safeUnutilizedPow",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "res",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "targetArtifactSelectors",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "addr",
              "type": "address"
            },
            {
              "internalType": "bytes4[]",
              "name": "selectors",
              "type": "bytes4[]"
            }
          ],
          "internalType": "struct StdInvariant.FuzzSelector[]",
          "name": "targetedArtifactSelectors_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "targetArtifacts",
      "outputs": [
        {
          "internalType": "string[]",
          "name": "targetedArtifacts_",
          "type": "string[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "targetContracts",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "targetedContracts_",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "targetInterfaces",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "addr",
              "type": "address"
            },
            {
              "internalType": "string[]",
              "name": "artifacts",
              "type": "string[]"
            }
          ],
          "internalType": "struct StdInvariant.FuzzInterface[]",
          "name": "targetedInterfaces_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "targetSelectors",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "addr",
              "type": "address"
            },
            {
              "internalType": "bytes4[]",
              "name": "selectors",
              "type": "bytes4[]"
            }
          ],
          "internalType": "struct StdInvariant.FuzzSelector[]",
          "name": "targetedSelectors_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "targetSenders",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "targetedSenders_",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "n",
          "type": "uint256"
        }
      ],
      "name": "testFail_findMaxExponent_ExponentWhenPlus1",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "res",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "y",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "d",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "n",
          "type": "uint8"
        }
      ],
      "name": "testGas_mulDiv",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "y",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "d",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "n",
          "type": "uint8"
        }
      ],
      "name": "testGas_mulDivLowPrecision",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "y",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "d",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "n",
          "type": "uint8"
        }
      ],
      "name": "testGas_safeUnutilizedPow",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "y",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "d",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "n",
          "type": "uint8"
        }
      ],
      "name": "testGas_unsafePow",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "n",
          "type": "uint256"
        }
      ],
      "name": "test_findMaxExponent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "res",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "y",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "d",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "n",
          "type": "uint8"
        }
      ],
      "name": "test_mulDiv",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "y",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "d",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "n",
          "type": "uint8"
        }
      ],
      "name": "unsafePow",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "r",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "bytecode": {
    "object": "0x608060405260078054600160ff199182168117909255600b8054909116909117905534801561002d57600080fd5b506130bc8061003d6000396000f3fe608060405234801561001057600080fd5b50600436106101775760003560e01c8063916a17c6116100d8578063cc1ebd751161008c578063eaf3dc1e11610066578063eaf3dc1e146102cb578063f76ee3ee146102de578063fa7626d4146102f157600080fd5b8063cc1ebd751461029d578063e20c9f71146102b0578063e47126d0146102b857600080fd5b8063aaf5eb68116100bd578063aaf5eb681461025c578063b5508aa91461027d578063ba414fa61461028557600080fd5b8063916a17c61461024157806393ea09fb1461024957600080fd5b80633e5e3c231161012f5780635a15e501116101145780635a15e5011461020457806366d9a9a01461021757806385226c811461022c57600080fd5b80633e5e3c23146101f45780633f7286f4146101fc57600080fd5b80632ade3880116101605780632ade3880146101b75780632c8bbef9146101cc5780632f410386146101e157600080fd5b80631b7188a71461017c5780631ed7831c146101a2575b600080fd5b61018f61018a36600461274d565b6102fe565b6040519081526020015b60405180910390f35b6101aa610321565b6040516101999190612766565b6101bf610390565b604051610199919061282e565b6101df6101da366004612937565b6104df565b005b61018f6101ef366004612937565b6107cc565b6101aa610803565b6101aa610870565b61018f61021236600461274d565b6108dd565b61021f610990565b604051610199919061297e565b610234610a98565b6040516101999190612a74565b61021f610b68565b6101df610257366004612937565b610c70565b610264601281565b60405167ffffffffffffffff9091168152602001610199565b610234610f66565b61028d611036565b6040519015158152602001610199565b6101df6102ab366004612937565b611198565b6101aa611479565b61018f6102c6366004612937565b6114e6565b6101df6102d9366004612937565b611590565b6101df6102ec366004612937565b611874565b60075461028d9060ff1681565b60008061030a83611e67565b905061031a61ffff821684612c43565b9392505050565b6060601480548060200260200160405190810160405280929190818152602001828054801561038657602002820191906000526020600020905b815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161035b575b5050505050905090565b6060601b805480602002602001604051908101604052809291908181526020016000905b828210156104d6576000848152602080822060408051808201825260028702909201805473ffffffffffffffffffffffffffffffffffffffff168352600181018054835181870281018701909452808452939591948681019491929084015b828210156104bf57838290600052602060002001805461043290612c4f565b80601f016020809104026020016040519081016040528092919081815260200182805461045e90612c4f565b80156104ab5780601f10610480576101008083540402835291602001916104ab565b820191906000526020600020905b81548152906001019060200180831161048e57829003601f168201915b505050505081526020019060010190610413565b5050505081525050815260200190600101906103b4565b50505050905090565b6040517f4c63e56200000000000000000000000000000000000000000000000000000000815282151560048201528490849084908490737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b15801561054c57600080fd5b505afa158015610560573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff831661058d87611e67565b61ffff1611156040518263ffffffff1660e01b81526004016105b3911515815260200190565b60006040518083038186803b1580156105cb57600080fd5b505afa1580156105df573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff831661060c86611e67565b61ffff1611156040518263ffffffff1660e01b8152600401610632911515815260200190565b60006040518083038186803b15801561064a57600080fd5b505afa15801561065e573d6000803e3d6000fd5b50506040805160248101889052604481018790526064810186905260ff85166084808301919091528251808303909101815260a490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f2f410386000000000000000000000000000000000000000000000000000000001790529051600093503092506106f29190612ca2565b600060405180830381855afa9150503d806000811461072d576040519150601f19603f3d011682016040523d82523d6000602084013e610732565b606091505b50506040517f4c63e5620000000000000000000000000000000000000000000000000000000081528115156004820152909150737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b15801561079c57600080fd5b505afa1580156107b0573d6000803e3d6000fd5b505050506107c0898989896114e6565b50505050505050505050565b8360005b8260ff168110156107fa576107e6828686612044565b9150806107f281612cbe565b9150506107d0565b50949350505050565b606060168054806020026020016040519081016040528092919081815260200182805480156103865760200282019190600052602060002090815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161035b575050505050905090565b606060158054806020026020016040519081016040528092919081815260200182805480156103865760200282019190600052602060002090815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161035b575050505050905090565b6000737109709ecfa91a80626ff3989d68f67f5b1dd12d634c63e562611bdc8411801561091a575070010000000000000000000000000000000084105b6040518263ffffffff1660e01b815260040161093a911515815260200190565b60006040518083038186803b15801561095257600080fd5b505afa158015610966573d6000803e3d6000fd5b50505050600061097583611e67565b9050610982816001612cf6565b61031a9061ffff1684612c43565b60606019805480602002602001604051908101604052809291908181526020016000905b828210156104d657600084815260209081902060408051808201825260028602909201805473ffffffffffffffffffffffffffffffffffffffff168352600181018054835181870281018701909452808452939491938583019392830182828015610a8057602002820191906000526020600020906000905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681526020019060040190602082600301049283019260010382029150808411610a2d5790505b505050505081525050815260200190600101906109b4565b60606018805480602002602001604051908101604052809291908181526020016000905b828210156104d6578382906000526020600020018054610adb90612c4f565b80601f0160208091040260200160405190810160405280929190818152602001828054610b0790612c4f565b8015610b545780601f10610b2957610100808354040283529160200191610b54565b820191906000526020600020905b815481529060010190602001808311610b3757829003601f168201915b505050505081526020019060010190610abc565b6060601a805480602002602001604051908101604052809291908181526020016000905b828210156104d657600084815260209081902060408051808201825260028602909201805473ffffffffffffffffffffffffffffffffffffffff168352600181018054835181870281018701909452808452939491938583019392830182828015610c5857602002820191906000526020600020906000905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681526020019060040190602082600301049283019260010382029150808411610c055790505b50505050508152505081526020019060010190610b8c565b6040517f4c63e56200000000000000000000000000000000000000000000000000000000815282151560048201528490849084908490737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b158015610cdd57600080fd5b505afa158015610cf1573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff8316610d1e87611e67565b61ffff1611156040518263ffffffff1660e01b8152600401610d44911515815260200190565b60006040518083038186803b158015610d5c57600080fd5b505afa158015610d70573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff8316610d9d86611e67565b61ffff1611156040518263ffffffff1660e01b8152600401610dc3911515815260200190565b60006040518083038186803b158015610ddb57600080fd5b505afa158015610def573d6000803e3d6000fd5b50506040805160248101889052604481018790526064810186905260ff85166084808301919091528251808303909101815260a490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f2f41038600000000000000000000000000000000000000000000000000000000179052905160009350309250610e839190612ca2565b600060405180830381855afa9150503d8060008114610ebe576040519150601f19603f3d011682016040523d82523d6000602084013e610ec3565b606091505b50506040517f4c63e5620000000000000000000000000000000000000000000000000000000081528115156004820152909150737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b158015610f2d57600080fd5b505afa158015610f41573d6000803e3d6000fd5b5050505061166b985061050d975060f29650601595506107c08989898960ff16612171565b60606017805480602002602001604051908101604052809291908181526020016000905b828210156104d6578382906000526020600020018054610fa990612c4f565b80601f0160208091040260200160405190810160405280929190818152602001828054610fd590612c4f565b80156110225780601f10610ff757610100808354040283529160200191611022565b820191906000526020600020905b81548152906001019060200180831161100557829003601f168201915b505050505081526020019060010190610f8a565b600754600090610100900460ff16156110585750600754610100900460ff1690565b6000737109709ecfa91a80626ff3989d68f67f5b1dd12d3b156111935760408051737109709ecfa91a80626ff3989d68f67f5b1dd12d602082018190527f6661696c65640000000000000000000000000000000000000000000000000000828401528251808303840181526060830190935260009290916110fd917f667f9d70ca411d70ead50d8d5c22070dafc36ad75f3dcf5e7237b22ade9aecc491608001612d18565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529082905261113591612ca2565b6000604051808303816000865af19150503d8060008114611172576040519150601f19603f3d011682016040523d82523d6000602084013e611177565b606091505b509150508080602001905181019061118f9190612d60565b9150505b919050565b6040517f4c63e56200000000000000000000000000000000000000000000000000000000815282151560048201528490849084908490737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b15801561120557600080fd5b505afa158015611219573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff831661124687611e67565b61ffff1611156040518263ffffffff1660e01b815260040161126c911515815260200190565b60006040518083038186803b15801561128457600080fd5b505afa158015611298573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff83166112c586611e67565b61ffff1611156040518263ffffffff1660e01b81526004016112eb911515815260200190565b60006040518083038186803b15801561130357600080fd5b505afa158015611317573d6000803e3d6000fd5b50506040805160248101889052604481018790526064810186905260ff85166084808301919091528251808303909101815260a490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f2f410386000000000000000000000000000000000000000000000000000000001790529051600093503092506113ab9190612ca2565b600060405180830381855afa9150503d80600081146113e6576040519150601f19603f3d011682016040523d82523d6000602084013e6113eb565b606091505b50506040517f4c63e5620000000000000000000000000000000000000000000000000000000081528115156004820152909150737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b15801561145557600080fd5b505afa158015611469573d6000803e3d6000fd5b505050506107c0898989896107cc565b606060138054806020026020016040519081016040528092919081815260200182805480156103865760200282019190600052602060002090815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161035b575050505050905090565b8360005b60ff83161561156957600080611500848861232f565b91509150816115445760ff8316156115325761151c8685612db1565b93508261152881612dec565b93505050506114ea565b61153d848888612044565b9050611552565b8261154e81612e27565b9350505b9250828461155f81612dec565b95505050506114ea565b60ff8116156107fa5761157c8483612db1565b91508061158881612dec565b915050611569565b6040517f4c63e56200000000000000000000000000000000000000000000000000000000815282151560048201528490849084908490737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b1580156115fd57600080fd5b505afa158015611611573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff831661163e87611e67565b61ffff1611156040518263ffffffff1660e01b8152600401611664911515815260200190565b60006040518083038186803b15801561167c57600080fd5b505afa158015611690573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff83166116bd86611e67565b61ffff1611156040518263ffffffff1660e01b81526004016116e3911515815260200190565b60006040518083038186803b1580156116fb57600080fd5b505afa15801561170f573d6000803e3d6000fd5b50506040805160248101889052604481018790526064810186905260ff85166084808301919091528251808303909101815260a490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f2f410386000000000000000000000000000000000000000000000000000000001790529051600093503092506117a39190612ca2565b600060405180830381855afa9150503d80600081146117de576040519150601f19603f3d011682016040523d82523d6000602084013e6117e3565b606091505b50506040517f4c63e5620000000000000000000000000000000000000000000000000000000081528115156004820152909150737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b15801561184d57600080fd5b505afa158015611861573d6000803e3d6000fd5b505050506107c08989898960ff1661237a565b6040517f4c63e56200000000000000000000000000000000000000000000000000000000815282151560048201528490849084908490737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b1580156118e157600080fd5b505afa1580156118f5573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff831661192287611e67565b61ffff1611156040518263ffffffff1660e01b8152600401611948911515815260200190565b60006040518083038186803b15801561196057600080fd5b505afa158015611974573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff83166119a186611e67565b61ffff1611156040518263ffffffff1660e01b81526004016119c7911515815260200190565b60006040518083038186803b1580156119df57600080fd5b505afa1580156119f3573d6000803e3d6000fd5b50506040805160248101889052604481018790526064810186905260ff85166084808301919091528251808303909101815260a490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f2f41038600000000000000000000000000000000000000000000000000000000179052905160009350309250611a879190612ca2565b600060405180830381855afa9150503d8060008114611ac2576040519150601f19603f3d011682016040523d82523d6000602084013e611ac7565b606091505b50506040517f4c63e5620000000000000000000000000000000000000000000000000000000081528115156004820152909150737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b158015611b3157600080fd5b505afa158015611b45573d6000803e3d6000fd5b505050506000611b5a8a8a8a8a60ff16612171565b90506000611b6a8b8b8b8b6114e6565b6040517f6900a3ae000000000000000000000000000000000000000000000000000000008152600481018d9052909150611e5a9083908390737109709ecfa91a80626ff3989d68f67f5b1dd12d90636900a3ae90602401600060405180830381865afa158015611bde573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052611c249190810190612e75565b6040517f6900a3ae000000000000000000000000000000000000000000000000000000008152600481018f9052737109709ecfa91a80626ff3989d68f67f5b1dd12d90636900a3ae90602401600060405180830381865afa158015611c8d573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052611cd39190810190612e75565b6040517f6900a3ae000000000000000000000000000000000000000000000000000000008152600481018f9052737109709ecfa91a80626ff3989d68f67f5b1dd12d90636900a3ae90602401600060405180830381865afa158015611d3c573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052611d829190810190612e75565b6040517f6900a3ae00000000000000000000000000000000000000000000000000000000815260ff8f166004820152737109709ecfa91a80626ff3989d68f67f5b1dd12d90636900a3ae90602401600060405180830381865afa158015611ded573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052611e339190810190612e75565b604051602001611e469493929190612f40565b6040516020818303038152906040526123a3565b5050505050505050505050565b60006003821015611e7a575060ff919050565b6004821015611e8b57506080919050565b6010821015611e9c57506040919050565b610100821015611eae57506020919050565b611bdc821015611ec057506014919050565b612c70821015611ed257506013919050565b614aa9821015611ee457506012919050565b618554821015611ef657506011919050565b62010000821015611f0957506010919050565b62021837821015611f1c5750600f919050565b6204e046821015611f2f5750600e919050565b620ced4c821015611f425750600d919050565b62285146821015611f555750600c919050565b629aa2ad821015611f685750600b919050565b6303080c01821015611f7c5750600a919050565b6315c5cbbd821015611f9057506009919050565b640100000000821015611fa557506008919050565b6417c6a1f29f821015611fba57506007919050565b6506597fa94f5c821015611fd057506006919050565b66093088c35d733b821015611fe757506005919050565b6801000000000000000082101561200057506004919050565b6a285145f31ae515c447bb5782101561201b57506003919050565b70010000000000000000000000000000000082101561203c57506002919050565b506001919050565b600080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8587098587029250828110838203039150508060000361209c5783828161209257612092612d82565b049250505061031a565b808411612109576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4d6174683a206d756c446976206f766572666c6f770000000000000000000000604482015260640160405180910390fd5b600084868809600260036001881981018916988990049182028318808302840302808302840302808302840302808302840302808302840302918202909203026000889003889004909101858311909403939093029303949094049190911702949350505050565b600082841480612183575061ffff8216155b1561218f575083612327565b508360008080806121b061ffff87166121a78a611e67565b61ffff166123f0565b90505b61ffff811615612206576121cd8561ffff83168a0a61232f565b909450925083156121e657829450808603955080820191505b6121ff600261ffff83160461ffff168761ffff166123f0565b90506121b3565b505b61ffff8516156122d35761221c848861232f565b90935091508215612259577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff909401939092508290600101612208565b61ffff81161561229c5785848161227257612272612d82565b0493507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01612208565b6122a7848888612044565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff909501949350612208565b60006122de87611e67565b90505b61ffff8216156123225760006122ff8261ffff168461ffff166123f0565b90508061ffff16880a868161231657612316612d82565b049550909103906122e1565b505050505b949350505050565b600080836000036123465750600190506000612373565b8383028385828161235957612359612d82565b041461236c576000809250925050612373565b6001925090505b9250929050565b600061239a858585856123956123908a8a61240a565b611e67565b612419565b95945050505050565b8183146123eb577f280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583816040516123d9919061303f565b60405180910390a16123eb8383612465565b505050565b60008183106123ff5781612401565b825b90505b92915050565b60008183116123ff5781612401565b8460005b61ffff84161561245b576124398461ffff168461ffff166123f0565b905061244f8261ffff831680890a90880a612044565b9150808403935061241d565b5095945050505050565b8082146125cd577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f506040516124f19060208082526022908201527f4572726f723a2061203d3d2062206e6f7420736174697366696564205b75696e60408201527f745d000000000000000000000000000000000000000000000000000000000000606082015260800190565b60405180910390a160408051818152600a818301527f2020202020204c6566740000000000000000000000000000000000000000000060608201526020810184905290517fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a89181900360800190a160408051818152600a818301527f202020202052696768740000000000000000000000000000000000000000000060608201526020810183905290517fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a89181900360800190a16125cd6125d1565b5050565b737109709ecfa91a80626ff3989d68f67f5b1dd12d3b1561271f5760408051737109709ecfa91a80626ff3989d68f67f5b1dd12d602082018190527f6661696c656400000000000000000000000000000000000000000000000000009282019290925260016060820152600091907f70ca10bbd0dbfd9020a9f4b13402c16cb120705e0d1c0aeab10fa353ae586fc490608001604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290526126a09291602001612d18565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290526126d891612ca2565b6000604051808303816000865af19150503d8060008114612715576040519150601f19603f3d011682016040523d82523d6000602084013e61271a565b606091505b505050505b600780547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff16610100179055565b60006020828403121561275f57600080fd5b5035919050565b6020808252825182820181905260009190848201906040850190845b818110156127b457835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101612782565b50909695505050505050565b60005b838110156127db5781810151838201526020016127c3565b50506000910152565b600081518084526127fc8160208601602086016127c0565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602080825282518282018190526000919060409081850190600581811b8701840188860187805b85811015612927577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08b85030187528251805173ffffffffffffffffffffffffffffffffffffffff1685528901518985018990528051898601819052908a0190606081881b870181019190870190855b81811015612911577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08985030183526128ff8486516127e4565b948e01949350918d01916001016128c5565b505050978a019794505091880191600101612855565b50919a9950505050505050505050565b6000806000806080858703121561294d57600080fd5b843593506020850135925060408501359150606085013560ff8116811461297357600080fd5b939692955090935050565b60006020808301818452808551808352604092508286019150828160051b8701018488016000805b84811015612a65578984037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00186528251805173ffffffffffffffffffffffffffffffffffffffff168552880151888501889052805188860181905290890190839060608701905b80831015612a505783517fffffffff00000000000000000000000000000000000000000000000000000000168252928b019260019290920191908b0190612a0e565b50978a019795505050918701916001016129a6565b50919998505050505050505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b82811015612ae7577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0888603018452612ad58583516127e4565b94509285019290850190600101612a9b565b5092979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600181815b80851115612b7c57817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04821115612b6257612b62612af4565b80851615612b6f57918102915b93841c9390800290612b28565b509250929050565b600082612b9357506001612404565b81612ba057506000612404565b8160018114612bb65760028114612bc057612bdc565b6001915050612404565b60ff841115612bd157612bd1612af4565b50506001821b612404565b5060208310610133831016604e8410600b8410161715612bff575081810a612404565b612c098383612b23565b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04821115612c3b57612c3b612af4565b029392505050565b60006124018383612b84565b600181811c90821680612c6357607f821691505b602082108103612c9c577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b60008251612cb48184602087016127c0565b9190910192915050565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203612cef57612cef612af4565b5060010190565b61ffff818116838216019080821115612d1157612d11612af4565b5092915050565b7fffffffff000000000000000000000000000000000000000000000000000000008316815260008251612d528160048501602087016127c0565b919091016004019392505050565b600060208284031215612d7257600080fd5b8151801515811461031a57600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600082612de7577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b600060ff821680612dff57612dff612af4565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0192915050565b600060ff821660ff8103612e3d57612e3d612af4565b60010192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208284031215612e8757600080fd5b815167ffffffffffffffff80821115612e9f57600080fd5b818401915084601f830112612eb357600080fd5b815181811115612ec557612ec5612e46565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715612f0b57612f0b612e46565b81604052828152876020848701011115612f2457600080fd5b612f358360208301602088016127c0565b979650505050505050565b7f45787072657373696f6e3a200000000000000000000000000000000000000000815260008551612f7881600c850160208a016127c0565b7f2a28000000000000000000000000000000000000000000000000000000000000600c918401918201528551612fb581600e840160208a016127c0565b7f2f00000000000000000000000000000000000000000000000000000000000000600e92909101918201528451612ff381600f8401602089016127c0565b7f292a2a0000000000000000000000000000000000000000000000000000000000600f929091019182015283516130318160128401602088016127c0565b016012019695505050505050565b60408152600560408201527f4572726f72000000000000000000000000000000000000000000000000000000606082015260806020820152600061240160808301846127e456fea2646970667358221220d74336082c7604368ed4d70bab722410a6dc1635cd57fcc0c7648fadd316c11864736f6c63430008150033",
    "sourceMap": "285:4060:52:-:0;;;1572:26:12;;;1594:4;-1:-1:-1;;1572:26:12;;;;;;;;3126:44:15;;;;;;;;;;;285:4060:52;;;;;;;;;;;;;;;;",
    "linkReferences": {}
  },
  "deployedBytecode": {
    "object": "0x608060405234801561001057600080fd5b50600436106101775760003560e01c8063916a17c6116100d8578063cc1ebd751161008c578063eaf3dc1e11610066578063eaf3dc1e146102cb578063f76ee3ee146102de578063fa7626d4146102f157600080fd5b8063cc1ebd751461029d578063e20c9f71146102b0578063e47126d0146102b857600080fd5b8063aaf5eb68116100bd578063aaf5eb681461025c578063b5508aa91461027d578063ba414fa61461028557600080fd5b8063916a17c61461024157806393ea09fb1461024957600080fd5b80633e5e3c231161012f5780635a15e501116101145780635a15e5011461020457806366d9a9a01461021757806385226c811461022c57600080fd5b80633e5e3c23146101f45780633f7286f4146101fc57600080fd5b80632ade3880116101605780632ade3880146101b75780632c8bbef9146101cc5780632f410386146101e157600080fd5b80631b7188a71461017c5780631ed7831c146101a2575b600080fd5b61018f61018a36600461274d565b6102fe565b6040519081526020015b60405180910390f35b6101aa610321565b6040516101999190612766565b6101bf610390565b604051610199919061282e565b6101df6101da366004612937565b6104df565b005b61018f6101ef366004612937565b6107cc565b6101aa610803565b6101aa610870565b61018f61021236600461274d565b6108dd565b61021f610990565b604051610199919061297e565b610234610a98565b6040516101999190612a74565b61021f610b68565b6101df610257366004612937565b610c70565b610264601281565b60405167ffffffffffffffff9091168152602001610199565b610234610f66565b61028d611036565b6040519015158152602001610199565b6101df6102ab366004612937565b611198565b6101aa611479565b61018f6102c6366004612937565b6114e6565b6101df6102d9366004612937565b611590565b6101df6102ec366004612937565b611874565b60075461028d9060ff1681565b60008061030a83611e67565b905061031a61ffff821684612c43565b9392505050565b6060601480548060200260200160405190810160405280929190818152602001828054801561038657602002820191906000526020600020905b815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161035b575b5050505050905090565b6060601b805480602002602001604051908101604052809291908181526020016000905b828210156104d6576000848152602080822060408051808201825260028702909201805473ffffffffffffffffffffffffffffffffffffffff168352600181018054835181870281018701909452808452939591948681019491929084015b828210156104bf57838290600052602060002001805461043290612c4f565b80601f016020809104026020016040519081016040528092919081815260200182805461045e90612c4f565b80156104ab5780601f10610480576101008083540402835291602001916104ab565b820191906000526020600020905b81548152906001019060200180831161048e57829003601f168201915b505050505081526020019060010190610413565b5050505081525050815260200190600101906103b4565b50505050905090565b6040517f4c63e56200000000000000000000000000000000000000000000000000000000815282151560048201528490849084908490737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b15801561054c57600080fd5b505afa158015610560573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff831661058d87611e67565b61ffff1611156040518263ffffffff1660e01b81526004016105b3911515815260200190565b60006040518083038186803b1580156105cb57600080fd5b505afa1580156105df573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff831661060c86611e67565b61ffff1611156040518263ffffffff1660e01b8152600401610632911515815260200190565b60006040518083038186803b15801561064a57600080fd5b505afa15801561065e573d6000803e3d6000fd5b50506040805160248101889052604481018790526064810186905260ff85166084808301919091528251808303909101815260a490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f2f410386000000000000000000000000000000000000000000000000000000001790529051600093503092506106f29190612ca2565b600060405180830381855afa9150503d806000811461072d576040519150601f19603f3d011682016040523d82523d6000602084013e610732565b606091505b50506040517f4c63e5620000000000000000000000000000000000000000000000000000000081528115156004820152909150737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b15801561079c57600080fd5b505afa1580156107b0573d6000803e3d6000fd5b505050506107c0898989896114e6565b50505050505050505050565b8360005b8260ff168110156107fa576107e6828686612044565b9150806107f281612cbe565b9150506107d0565b50949350505050565b606060168054806020026020016040519081016040528092919081815260200182805480156103865760200282019190600052602060002090815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161035b575050505050905090565b606060158054806020026020016040519081016040528092919081815260200182805480156103865760200282019190600052602060002090815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161035b575050505050905090565b6000737109709ecfa91a80626ff3989d68f67f5b1dd12d634c63e562611bdc8411801561091a575070010000000000000000000000000000000084105b6040518263ffffffff1660e01b815260040161093a911515815260200190565b60006040518083038186803b15801561095257600080fd5b505afa158015610966573d6000803e3d6000fd5b50505050600061097583611e67565b9050610982816001612cf6565b61031a9061ffff1684612c43565b60606019805480602002602001604051908101604052809291908181526020016000905b828210156104d657600084815260209081902060408051808201825260028602909201805473ffffffffffffffffffffffffffffffffffffffff168352600181018054835181870281018701909452808452939491938583019392830182828015610a8057602002820191906000526020600020906000905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681526020019060040190602082600301049283019260010382029150808411610a2d5790505b505050505081525050815260200190600101906109b4565b60606018805480602002602001604051908101604052809291908181526020016000905b828210156104d6578382906000526020600020018054610adb90612c4f565b80601f0160208091040260200160405190810160405280929190818152602001828054610b0790612c4f565b8015610b545780601f10610b2957610100808354040283529160200191610b54565b820191906000526020600020905b815481529060010190602001808311610b3757829003601f168201915b505050505081526020019060010190610abc565b6060601a805480602002602001604051908101604052809291908181526020016000905b828210156104d657600084815260209081902060408051808201825260028602909201805473ffffffffffffffffffffffffffffffffffffffff168352600181018054835181870281018701909452808452939491938583019392830182828015610c5857602002820191906000526020600020906000905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681526020019060040190602082600301049283019260010382029150808411610c055790505b50505050508152505081526020019060010190610b8c565b6040517f4c63e56200000000000000000000000000000000000000000000000000000000815282151560048201528490849084908490737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b158015610cdd57600080fd5b505afa158015610cf1573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff8316610d1e87611e67565b61ffff1611156040518263ffffffff1660e01b8152600401610d44911515815260200190565b60006040518083038186803b158015610d5c57600080fd5b505afa158015610d70573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff8316610d9d86611e67565b61ffff1611156040518263ffffffff1660e01b8152600401610dc3911515815260200190565b60006040518083038186803b158015610ddb57600080fd5b505afa158015610def573d6000803e3d6000fd5b50506040805160248101889052604481018790526064810186905260ff85166084808301919091528251808303909101815260a490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f2f41038600000000000000000000000000000000000000000000000000000000179052905160009350309250610e839190612ca2565b600060405180830381855afa9150503d8060008114610ebe576040519150601f19603f3d011682016040523d82523d6000602084013e610ec3565b606091505b50506040517f4c63e5620000000000000000000000000000000000000000000000000000000081528115156004820152909150737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b158015610f2d57600080fd5b505afa158015610f41573d6000803e3d6000fd5b5050505061166b985061050d975060f29650601595506107c08989898960ff16612171565b60606017805480602002602001604051908101604052809291908181526020016000905b828210156104d6578382906000526020600020018054610fa990612c4f565b80601f0160208091040260200160405190810160405280929190818152602001828054610fd590612c4f565b80156110225780601f10610ff757610100808354040283529160200191611022565b820191906000526020600020905b81548152906001019060200180831161100557829003601f168201915b505050505081526020019060010190610f8a565b600754600090610100900460ff16156110585750600754610100900460ff1690565b6000737109709ecfa91a80626ff3989d68f67f5b1dd12d3b156111935760408051737109709ecfa91a80626ff3989d68f67f5b1dd12d602082018190527f6661696c65640000000000000000000000000000000000000000000000000000828401528251808303840181526060830190935260009290916110fd917f667f9d70ca411d70ead50d8d5c22070dafc36ad75f3dcf5e7237b22ade9aecc491608001612d18565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529082905261113591612ca2565b6000604051808303816000865af19150503d8060008114611172576040519150601f19603f3d011682016040523d82523d6000602084013e611177565b606091505b509150508080602001905181019061118f9190612d60565b9150505b919050565b6040517f4c63e56200000000000000000000000000000000000000000000000000000000815282151560048201528490849084908490737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b15801561120557600080fd5b505afa158015611219573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff831661124687611e67565b61ffff1611156040518263ffffffff1660e01b815260040161126c911515815260200190565b60006040518083038186803b15801561128457600080fd5b505afa158015611298573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff83166112c586611e67565b61ffff1611156040518263ffffffff1660e01b81526004016112eb911515815260200190565b60006040518083038186803b15801561130357600080fd5b505afa158015611317573d6000803e3d6000fd5b50506040805160248101889052604481018790526064810186905260ff85166084808301919091528251808303909101815260a490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f2f410386000000000000000000000000000000000000000000000000000000001790529051600093503092506113ab9190612ca2565b600060405180830381855afa9150503d80600081146113e6576040519150601f19603f3d011682016040523d82523d6000602084013e6113eb565b606091505b50506040517f4c63e5620000000000000000000000000000000000000000000000000000000081528115156004820152909150737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b15801561145557600080fd5b505afa158015611469573d6000803e3d6000fd5b505050506107c0898989896107cc565b606060138054806020026020016040519081016040528092919081815260200182805480156103865760200282019190600052602060002090815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161035b575050505050905090565b8360005b60ff83161561156957600080611500848861232f565b91509150816115445760ff8316156115325761151c8685612db1565b93508261152881612dec565b93505050506114ea565b61153d848888612044565b9050611552565b8261154e81612e27565b9350505b9250828461155f81612dec565b95505050506114ea565b60ff8116156107fa5761157c8483612db1565b91508061158881612dec565b915050611569565b6040517f4c63e56200000000000000000000000000000000000000000000000000000000815282151560048201528490849084908490737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b1580156115fd57600080fd5b505afa158015611611573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff831661163e87611e67565b61ffff1611156040518263ffffffff1660e01b8152600401611664911515815260200190565b60006040518083038186803b15801561167c57600080fd5b505afa158015611690573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff83166116bd86611e67565b61ffff1611156040518263ffffffff1660e01b81526004016116e3911515815260200190565b60006040518083038186803b1580156116fb57600080fd5b505afa15801561170f573d6000803e3d6000fd5b50506040805160248101889052604481018790526064810186905260ff85166084808301919091528251808303909101815260a490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f2f410386000000000000000000000000000000000000000000000000000000001790529051600093503092506117a39190612ca2565b600060405180830381855afa9150503d80600081146117de576040519150601f19603f3d011682016040523d82523d6000602084013e6117e3565b606091505b50506040517f4c63e5620000000000000000000000000000000000000000000000000000000081528115156004820152909150737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b15801561184d57600080fd5b505afa158015611861573d6000803e3d6000fd5b505050506107c08989898960ff1661237a565b6040517f4c63e56200000000000000000000000000000000000000000000000000000000815282151560048201528490849084908490737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b1580156118e157600080fd5b505afa1580156118f5573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff831661192287611e67565b61ffff1611156040518263ffffffff1660e01b8152600401611948911515815260200190565b60006040518083038186803b15801561196057600080fd5b505afa158015611974573d6000803e3d6000fd5b50737109709ecfa91a80626ff3989d68f67f5b1dd12d9250634c63e56291505060ff83166119a186611e67565b61ffff1611156040518263ffffffff1660e01b81526004016119c7911515815260200190565b60006040518083038186803b1580156119df57600080fd5b505afa1580156119f3573d6000803e3d6000fd5b50506040805160248101889052604481018790526064810186905260ff85166084808301919091528251808303909101815260a490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f2f41038600000000000000000000000000000000000000000000000000000000179052905160009350309250611a879190612ca2565b600060405180830381855afa9150503d8060008114611ac2576040519150601f19603f3d011682016040523d82523d6000602084013e611ac7565b606091505b50506040517f4c63e5620000000000000000000000000000000000000000000000000000000081528115156004820152909150737109709ecfa91a80626ff3989d68f67f5b1dd12d90634c63e5629060240160006040518083038186803b158015611b3157600080fd5b505afa158015611b45573d6000803e3d6000fd5b505050506000611b5a8a8a8a8a60ff16612171565b90506000611b6a8b8b8b8b6114e6565b6040517f6900a3ae000000000000000000000000000000000000000000000000000000008152600481018d9052909150611e5a9083908390737109709ecfa91a80626ff3989d68f67f5b1dd12d90636900a3ae90602401600060405180830381865afa158015611bde573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052611c249190810190612e75565b6040517f6900a3ae000000000000000000000000000000000000000000000000000000008152600481018f9052737109709ecfa91a80626ff3989d68f67f5b1dd12d90636900a3ae90602401600060405180830381865afa158015611c8d573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052611cd39190810190612e75565b6040517f6900a3ae000000000000000000000000000000000000000000000000000000008152600481018f9052737109709ecfa91a80626ff3989d68f67f5b1dd12d90636900a3ae90602401600060405180830381865afa158015611d3c573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052611d829190810190612e75565b6040517f6900a3ae00000000000000000000000000000000000000000000000000000000815260ff8f166004820152737109709ecfa91a80626ff3989d68f67f5b1dd12d90636900a3ae90602401600060405180830381865afa158015611ded573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052611e339190810190612e75565b604051602001611e469493929190612f40565b6040516020818303038152906040526123a3565b5050505050505050505050565b60006003821015611e7a575060ff919050565b6004821015611e8b57506080919050565b6010821015611e9c57506040919050565b610100821015611eae57506020919050565b611bdc821015611ec057506014919050565b612c70821015611ed257506013919050565b614aa9821015611ee457506012919050565b618554821015611ef657506011919050565b62010000821015611f0957506010919050565b62021837821015611f1c5750600f919050565b6204e046821015611f2f5750600e919050565b620ced4c821015611f425750600d919050565b62285146821015611f555750600c919050565b629aa2ad821015611f685750600b919050565b6303080c01821015611f7c5750600a919050565b6315c5cbbd821015611f9057506009919050565b640100000000821015611fa557506008919050565b6417c6a1f29f821015611fba57506007919050565b6506597fa94f5c821015611fd057506006919050565b66093088c35d733b821015611fe757506005919050565b6801000000000000000082101561200057506004919050565b6a285145f31ae515c447bb5782101561201b57506003919050565b70010000000000000000000000000000000082101561203c57506002919050565b506001919050565b600080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8587098587029250828110838203039150508060000361209c5783828161209257612092612d82565b049250505061031a565b808411612109576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4d6174683a206d756c446976206f766572666c6f770000000000000000000000604482015260640160405180910390fd5b600084868809600260036001881981018916988990049182028318808302840302808302840302808302840302808302840302808302840302918202909203026000889003889004909101858311909403939093029303949094049190911702949350505050565b600082841480612183575061ffff8216155b1561218f575083612327565b508360008080806121b061ffff87166121a78a611e67565b61ffff166123f0565b90505b61ffff811615612206576121cd8561ffff83168a0a61232f565b909450925083156121e657829450808603955080820191505b6121ff600261ffff83160461ffff168761ffff166123f0565b90506121b3565b505b61ffff8516156122d35761221c848861232f565b90935091508215612259577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff909401939092508290600101612208565b61ffff81161561229c5785848161227257612272612d82565b0493507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01612208565b6122a7848888612044565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff909501949350612208565b60006122de87611e67565b90505b61ffff8216156123225760006122ff8261ffff168461ffff166123f0565b90508061ffff16880a868161231657612316612d82565b049550909103906122e1565b505050505b949350505050565b600080836000036123465750600190506000612373565b8383028385828161235957612359612d82565b041461236c576000809250925050612373565b6001925090505b9250929050565b600061239a858585856123956123908a8a61240a565b611e67565b612419565b95945050505050565b8183146123eb577f280f4446b28a1372417dda658d30b95b2992b12ac9c7f378535f29a97acf3583816040516123d9919061303f565b60405180910390a16123eb8383612465565b505050565b60008183106123ff5781612401565b825b90505b92915050565b60008183116123ff5781612401565b8460005b61ffff84161561245b576124398461ffff168461ffff166123f0565b905061244f8261ffff831680890a90880a612044565b9150808403935061241d565b5095945050505050565b8082146125cd577f41304facd9323d75b11bcdd609cb38effffdb05710f7caf0e9b16c6d9d709f506040516124f19060208082526022908201527f4572726f723a2061203d3d2062206e6f7420736174697366696564205b75696e60408201527f745d000000000000000000000000000000000000000000000000000000000000606082015260800190565b60405180910390a160408051818152600a818301527f2020202020204c6566740000000000000000000000000000000000000000000060608201526020810184905290517fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a89181900360800190a160408051818152600a818301527f202020202052696768740000000000000000000000000000000000000000000060608201526020810183905290517fb2de2fbe801a0df6c0cbddfd448ba3c41d48a040ca35c56c8196ef0fcae721a89181900360800190a16125cd6125d1565b5050565b737109709ecfa91a80626ff3989d68f67f5b1dd12d3b1561271f5760408051737109709ecfa91a80626ff3989d68f67f5b1dd12d602082018190527f6661696c656400000000000000000000000000000000000000000000000000009282019290925260016060820152600091907f70ca10bbd0dbfd9020a9f4b13402c16cb120705e0d1c0aeab10fa353ae586fc490608001604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290526126a09291602001612d18565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290526126d891612ca2565b6000604051808303816000865af19150503d8060008114612715576040519150601f19603f3d011682016040523d82523d6000602084013e61271a565b606091505b505050505b600780547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff16610100179055565b60006020828403121561275f57600080fd5b5035919050565b6020808252825182820181905260009190848201906040850190845b818110156127b457835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101612782565b50909695505050505050565b60005b838110156127db5781810151838201526020016127c3565b50506000910152565b600081518084526127fc8160208601602086016127c0565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602080825282518282018190526000919060409081850190600581811b8701840188860187805b85811015612927577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08b85030187528251805173ffffffffffffffffffffffffffffffffffffffff1685528901518985018990528051898601819052908a0190606081881b870181019190870190855b81811015612911577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08985030183526128ff8486516127e4565b948e01949350918d01916001016128c5565b505050978a019794505091880191600101612855565b50919a9950505050505050505050565b6000806000806080858703121561294d57600080fd5b843593506020850135925060408501359150606085013560ff8116811461297357600080fd5b939692955090935050565b60006020808301818452808551808352604092508286019150828160051b8701018488016000805b84811015612a65578984037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00186528251805173ffffffffffffffffffffffffffffffffffffffff168552880151888501889052805188860181905290890190839060608701905b80831015612a505783517fffffffff00000000000000000000000000000000000000000000000000000000168252928b019260019290920191908b0190612a0e565b50978a019795505050918701916001016129a6565b50919998505050505050505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b82811015612ae7577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0888603018452612ad58583516127e4565b94509285019290850190600101612a9b565b5092979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600181815b80851115612b7c57817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04821115612b6257612b62612af4565b80851615612b6f57918102915b93841c9390800290612b28565b509250929050565b600082612b9357506001612404565b81612ba057506000612404565b8160018114612bb65760028114612bc057612bdc565b6001915050612404565b60ff841115612bd157612bd1612af4565b50506001821b612404565b5060208310610133831016604e8410600b8410161715612bff575081810a612404565b612c098383612b23565b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04821115612c3b57612c3b612af4565b029392505050565b60006124018383612b84565b600181811c90821680612c6357607f821691505b602082108103612c9c577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b60008251612cb48184602087016127c0565b9190910192915050565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203612cef57612cef612af4565b5060010190565b61ffff818116838216019080821115612d1157612d11612af4565b5092915050565b7fffffffff000000000000000000000000000000000000000000000000000000008316815260008251612d528160048501602087016127c0565b919091016004019392505050565b600060208284031215612d7257600080fd5b8151801515811461031a57600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600082612de7577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b600060ff821680612dff57612dff612af4565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0192915050565b600060ff821660ff8103612e3d57612e3d612af4565b60010192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208284031215612e8757600080fd5b815167ffffffffffffffff80821115612e9f57600080fd5b818401915084601f830112612eb357600080fd5b815181811115612ec557612ec5612e46565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715612f0b57612f0b612e46565b81604052828152876020848701011115612f2457600080fd5b612f358360208301602088016127c0565b979650505050505050565b7f45787072657373696f6e3a200000000000000000000000000000000000000000815260008551612f7881600c850160208a016127c0565b7f2a28000000000000000000000000000000000000000000000000000000000000600c918401918201528551612fb581600e840160208a016127c0565b7f2f00000000000000000000000000000000000000000000000000000000000000600e92909101918201528451612ff381600f8401602089016127c0565b7f292a2a0000000000000000000000000000000000000000000000000000000000600f929091019182015283516130318160128401602088016127c0565b016012019695505050505050565b60408152600560408201527f4572726f72000000000000000000000000000000000000000000000000000000606082015260806020820152600061240160808301846127e456fea2646970667358221220d74336082c7604368ed4d70bab722410a6dc1635cd57fcc0c7648fadd316c11864736f6c63430008150033",
    "sourceMap": "285:4060:52:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;873:163;;;;;;:::i;:::-;;:::i;:::-;;;345:25:54;;;333:2;318:18;873:163:52;;;;;;;;2452:134:18;;;:::i;:::-;;;;;;;:::i;3360:151::-;;;:::i;:::-;;;;;;;:::i;1460:198:52:-;;;;;;:::i;:::-;;:::i;:::-;;3307:243;;;;;;:::i;:::-;;:::i;3221:133:18:-;;;:::i;2922:141::-;;;:::i;1108:279:52:-;;;;;;:::i;:::-;;:::i;2738:178:18:-;;;:::i;:::-;;;;;;;:::i;2592:140::-;;;:::i;:::-;;;;;;;:::i;3069:146::-;;;:::i;1731:256:52:-;;;;;;:::i;:::-;;:::i;323:37::-;;358:2;323:37;;;;;6769:18:54;6757:31;;;6739:50;;6727:2;6712:18;323:37:52;6595:200:54;2157:141:18;;;:::i;1819:584:12:-;;;:::i;:::-;;;6965:14:54;;6958:22;6940:41;;6928:2;6913:18;1819:584:12;6800:187:54;2359:182:52;;;;;;:::i;:::-;;:::i;2304:142:18:-;;;:::i;3636:707:52:-;;;;;;:::i;:::-;;:::i;2072:211::-;;;;;;:::i;:::-;;:::i;2642:579::-;;;;;;:::i;:::-;;:::i;1572:26:12:-;;;;;;;;;873:163:52;935:11;958:8;969:29;996:1;969:26;:29::i;:::-;958:40;-1:-1:-1;1014:15:52;1019:10;;;1014:1;:15;:::i;:::-;1008:21;873:163;-1:-1:-1;;;873:163:52:o;2452:134:18:-;2499:33;2563:16;2544:35;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2452:134;:::o;3360:151::-;3409:42;3485:19;3463:41;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3360:151;:::o;1460:198:52:-;479:17;;;;;489:6;;;479:17;;;6940:41:54;1600:1:52;;1603;;1606;;1609;;479:9;;;;6913:18:54;;479:17:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;506:9:52;;-1:-1:-1;506:9:52;;-1:-1:-1;;516:34:52;;;:29;543:1;516:26;:29::i;:::-;:34;;;;506:45;;;;;;;;;;;;;6965:14:54;6958:22;6940:41;;6928:2;6913:18;;6800:187;506:45:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;561:9:52;;-1:-1:-1;561:9:52;;-1:-1:-1;;571:34:52;;;:29;598:1;571:26;:29::i;:::-;:34;;;;561:45;;;;;;;;;;;;;6965:14:54;6958:22;6940:41;;6928:2;6913:18;;6800:187;561:45:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;668:44:52;;;;;;9344:25:54;;;9385:18;;;9378:34;;;9428:18;;;9421:34;;;9503:4;9491:17;;9471:18;;;;9464:45;;;;668:44:52;;;;;;;;;;9316:19:54;;;;668:44:52;;;;;;;;;;;;;630:92;;-1:-1:-1;;;638:4:52;;-1:-1:-1;630:92:52;;668:44;630:92;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;732:13:52;;;;;6965:14:54;;6958:22;732:13:52;;;6940:41:54;616:106:52;;-1:-1:-1;732:9:52;;;;6913:18:54;;732:13:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1622:29:::1;1640:1;1643;1646;1649;1622:17;:29::i;:::-;;469:294:::0;1460:198;;;;;;;;:::o;3307:243::-;3452:1;3427:9;3463:81;3487:1;3483:5;;:1;:5;3463:81;;;3513:20;3525:1;3528;3531;3513:11;:20::i;:::-;3509:24;-1:-1:-1;3490:3:52;;;;:::i;:::-;;;;3463:81;;;;3307:243;;;;;;:::o;3221:133:18:-;3267:33;3331:16;3312:35;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3221:133;:::o;2922:141::-;2970:35;3038:18;3017:39;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2922:141;:::o;1108:279:52:-;1206:11;1229:9;;1239:4;:8;-1:-1:-1;1239:55:52;;;;;1255:39;1251:1;:43;1239:55;1229:66;;;;;;;;;;;;;6965:14:54;6958:22;6940:41;;6928:2;6913:18;;6800:187;1229:66:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1305:8;1316:29;1343:1;1316:26;:29::i;:::-;1305:40;-1:-1:-1;1374:5:52;1305:40;1378:1;1374:5;:::i;:::-;1361:19;;1366:14;;1361:1;:19;:::i;2738:178:18:-;2794:48;2883:26;2854:55;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2592:140;2640:34;2707:18;2686:39;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3069:146;3117:40;3190:18;3169:39;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1731:256:52;479:17;;;;;489:6;;;479:17;;;6940:41:54;1860:1:52;;1863;;1866;;1869;;479:9;;;;6913:18:54;;479:17:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;506:9:52;;-1:-1:-1;506:9:52;;-1:-1:-1;;516:34:52;;;:29;543:1;516:26;:29::i;:::-;:34;;;;506:45;;;;;;;;;;;;;6965:14:54;6958:22;6940:41;;6928:2;6913:18;;6800:187;506:45:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;561:9:52;;-1:-1:-1;561:9:52;;-1:-1:-1;;571:34:52;;;:29;598:1;571:26;:29::i;:::-;:34;;;;561:45;;;;;;;;;;;;;6965:14:54;6958:22;6940:41;;6928:2;6913:18;;6800:187;561:45:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;668:44:52;;;;;;9344:25:54;;;9385:18;;;9378:34;;;9428:18;;;9421:34;;;9503:4;9491:17;;9471:18;;;;9464:45;;;;668:44:52;;;;;;;;;;9316:19:54;;;;668:44:52;;;;;;;;;;;;;630:92;;-1:-1:-1;;;638:4:52;;-1:-1:-1;630:92:52;;668:44;630:92;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;732:13:52;;;;;6965:14:54;;6958:22;732:13:52;;;6940:41:54;616:106:52;;-1:-1:-1;732:9:52;;;;6913:18:54;;732:13:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1886:4:::1;1882:8;;1904:4;1900:8;;1922:3;1918:7;;1939:2;1935:6;;1951:29;1969:1;1972;1975;1978;1951:29;;:17;:29::i;2157:141:18:-:0;2206:34;2273:18;2252:39;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1819:584:12;1873:7;;1853:4;;1873:7;;;;;1869:528;;;-1:-1:-1;1903:7:12;;;;;;;;1819:584::o;1869:528::-;1941:17;2997:42;2985:55;3066:16;1980:374;;2196:43;;;1671:64;2196:43;;;10359:74:54;;;2221:17:12;10449:18:54;;;10442:34;2196:43:12;;;;;;;;;10332:18:54;;;2196:43:12;;;-1:-1:-1;;1671:64:12;;2086:175;;2135:34;;2086:175;;;:::i;:::-;;;;;;;;;;;;;;;2047:232;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2020:259;;;2323:7;2312:27;;;;;;;;;;;;:::i;:::-;2297:42;;2002:352;1980:374;2374:12;1819:584;-1:-1:-1;1819:584:12:o;2359:182:52:-;479:17;;;;;489:6;;;479:17;;;6940:41:54;2491:1:52;;2494;;2497;;2500;;479:9;;;;6913:18:54;;479:17:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;506:9:52;;-1:-1:-1;506:9:52;;-1:-1:-1;;516:34:52;;;:29;543:1;516:26;:29::i;:::-;:34;;;;506:45;;;;;;;;;;;;;6965:14:54;6958:22;6940:41;;6928:2;6913:18;;6800:187;506:45:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;561:9:52;;-1:-1:-1;561:9:52;;-1:-1:-1;;571:34:52;;;:29;598:1;571:26;:29::i;:::-;:34;;;;561:45;;;;;;;;;;;;;6965:14:54;6958:22;6940:41;;6928:2;6913:18;;6800:187;561:45:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;668:44:52;;;;;;9344:25:54;;;9385:18;;;9378:34;;;9428:18;;;9421:34;;;9503:4;9491:17;;9471:18;;;;9464:45;;;;668:44:52;;;;;;;;;;9316:19:54;;;;668:44:52;;;;;;;;;;;;;630:92;;-1:-1:-1;;;638:4:52;;-1:-1:-1;630:92:52;;668:44;630:92;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;732:13:52;;;;;6965:14:54;;6958:22;732:13:52;;;6940:41:54;616:106:52;;-1:-1:-1;732:9:52;;;;6913:18:54;;732:13:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2513:21:::1;2523:1;2526;2529;2532;2513:9;:21::i;2304:142:18:-:0;2353:35;2421:18;2400:39;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2304:142;:::o;3636:707:52:-;3793:1;3764:11;3829:413;3836:5;;;;3829:413;;3858:7;3867:12;3883:23;3899:3;3904:1;3883:15;:23::i;:::-;3857:49;;;;3925:2;3920:270;;3951:13;;;;3947:131;;3988:8;3995:1;3988:8;;:::i;:::-;;-1:-1:-1;4018:11:52;;;;:::i;:::-;;;;4051:8;;;;3947:131;4103:22;4115:3;4120:1;4123;4103:11;:22::i;:::-;4096:29;;3920:270;;;4164:11;;;;:::i;:::-;;;;3920:270;4210:4;-1:-1:-1;4210:4:52;4228:3;;;;:::i;:::-;;;;3843:399;;3829:413;;;4259:13;;;;4252:85;;4294:7;4300:1;4294:3;:7;:::i;:::-;4288:13;-1:-1:-1;4315:11:52;;;;:::i;:::-;;;;4252:85;;2072:211;479:17;;;;;489:6;;;479:17;;;6940:41:54;2213:1:52;;2216;;2219;;2222;;479:9;;;;6913:18:54;;479:17:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;506:9:52;;-1:-1:-1;506:9:52;;-1:-1:-1;;516:34:52;;;:29;543:1;516:26;:29::i;:::-;:34;;;;506:45;;;;;;;;;;;;;6965:14:54;6958:22;6940:41;;6928:2;6913:18;;6800:187;506:45:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;561:9:52;;-1:-1:-1;561:9:52;;-1:-1:-1;;571:34:52;;;:29;598:1;571:26;:29::i;:::-;:34;;;;561:45;;;;;;;;;;;;;6965:14:54;6958:22;6940:41;;6928:2;6913:18;;6800:187;561:45:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;668:44:52;;;;;;9344:25:54;;;9385:18;;;9378:34;;;9428:18;;;9421:34;;;9503:4;9491:17;;9471:18;;;;9464:45;;;;668:44:52;;;;;;;;;;9316:19:54;;;;668:44:52;;;;;;;;;;;;;630:92;;-1:-1:-1;;;638:4:52;;-1:-1:-1;630:92:52;;668:44;630:92;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;732:13:52;;;;;6965:14:54;;6958:22;732:13:52;;;6940:41:54;616:106:52;;-1:-1:-1;732:9:52;;;;6913:18:54;;732:13:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2235:41:::1;2265:1;2268;2271;2274;2235:41;;:29;:41::i;2642:579::-:0;479:17;;;;;489:6;;;479:17;;;6940:41:54;2763:1:52;;2766;;2769;;2772;;479:9;;;;6913:18:54;;479:17:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;506:9:52;;-1:-1:-1;506:9:52;;-1:-1:-1;;516:34:52;;;:29;543:1;516:26;:29::i;:::-;:34;;;;506:45;;;;;;;;;;;;;6965:14:54;6958:22;6940:41;;6928:2;6913:18;;6800:187;506:45:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;561:9:52;;-1:-1:-1;561:9:52;;-1:-1:-1;;571:34:52;;;:29;598:1;571:26;:29::i;:::-;:34;;;;561:45;;;;;;;;;;;;;6965:14:54;6958:22;6940:41;;6928:2;6913:18;;6800:187;561:45:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;668:44:52;;;;;;9344:25:54;;;9385:18;;;9378:34;;;9428:18;;;9421:34;;;9503:4;9491:17;;9471:18;;;;9464:45;;;;668:44:52;;;;;;;;;;9316:19:54;;;;668:44:52;;;;;;;;;;;;;630:92;;-1:-1:-1;;;638:4:52;;-1:-1:-1;630:92:52;;668:44;630:92;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;732:13:52;;;;;6965:14:54;;6958:22;732:13:52;;;6940:41:54;616:106:52;;-1:-1:-1;732:9:52;;;;6913:18:54;;732:13:52;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2785:12:::1;2800:29;2818:1;2821;2824;2827;2800:29;;:17;:29::i;:::-;2785:44;;2839:12;2854:29;2872:1;2875;2878;2881;2854:17;:29::i;:::-;3014:14;::::0;;;;::::1;::::0;::::1;345:25:54::0;;;2839:44:52;;-1:-1:-1;2893:321:52::1;::::0;2915:4;;2839:44;;3014:11;;::::1;::::0;318:18:54;;3014:14:52::1;;;;;;;;;;;;;;;;;::::0;::::1;;;;;;;;;;;;;;;;;::::0;;::::1;::::0;::::1;::::0;::::1;;::::0;::::1;::::0;;;::::1;::::0;::::1;:::i;:::-;3068;::::0;;;;::::1;::::0;::::1;345:25:54::0;;;3068:11:52;;::::1;::::0;318:18:54;;3068:14:52::1;;;;;;;;;;;;;;;;;::::0;::::1;;;;;;;;;;;;;;;;;::::0;;::::1;::::0;::::1;::::0;::::1;;::::0;::::1;::::0;;;::::1;::::0;::::1;:::i;:::-;3121;::::0;;;;::::1;::::0;::::1;345:25:54::0;;;3121:11:52;;::::1;::::0;318:18:54;;3121:14:52::1;;;;;;;;;;;;;;;;;::::0;::::1;;;;;;;;;;;;;;;;;::::0;;::::1;::::0;::::1;::::0;::::1;;::::0;::::1;::::0;;;::::1;::::0;::::1;:::i;:::-;3176;::::0;;;;13419:4:54;13407:17;;3176:14:52::1;::::0;::::1;13389:36:54::0;3176:11:52;;::::1;::::0;13362:18:54;;3176:14:52::1;;;;;;;;;;;;;;;;;::::0;::::1;;;;;;;;;;;;;;;;;::::0;;::::1;::::0;::::1;::::0;::::1;;::::0;::::1;::::0;;;::::1;::::0;::::1;:::i;:::-;2951:253;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;2893:8;:321::i;:::-;2775:446;;469:294:::0;2642:579;;;;;;;;:::o;2714:1015:8:-;2773:8;2801:1;2797;:5;2793:929;;;-1:-1:-1;2808:3:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;2793:929:8:-;2834:1;2830;:5;2826:896;;;-1:-1:-1;2841:3:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;2826:896:8:-;2867:2;2863:1;:6;2859:863;;;-1:-1:-1;2875:2:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;2859:863:8:-;2900:3;2896:1;:7;2892:830;;;-1:-1:-1;2909:2:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;2892:830:8:-;2934:4;2930:1;:8;2926:796;;;-1:-1:-1;2944:2:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;2926:796:8:-;2969:5;2965:1;:9;2961:761;;;-1:-1:-1;2980:2:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;2961:761:8:-;3005:5;3001:1;:9;2997:725;;;-1:-1:-1;3016:2:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;2997:725:8:-;3041:5;3037:1;:9;3033:689;;;-1:-1:-1;3052:2:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3033:689:8:-;3077:5;3073:1;:9;3069:653;;;-1:-1:-1;3088:2:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3069:653:8:-;3113:6;3109:1;:10;3105:617;;;-1:-1:-1;3125:2:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3105:617:8:-;3150:6;3146:1;:10;3142:580;;;-1:-1:-1;3162:2:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3142:580:8:-;3187:6;3183:1;:10;3179:543;;;-1:-1:-1;3199:2:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3179:543:8:-;3224:7;3220:1;:11;3216:506;;;-1:-1:-1;3237:2:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3216:506:8:-;3262:8;3258:1;:12;3254:468;;;-1:-1:-1;3276:2:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3254:468:8:-;3301:8;3297:1;:12;3293:429;;;-1:-1:-1;3315:2:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3293:429:8:-;3340:9;3336:1;:13;3332:390;;;-1:-1:-1;3355:1:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3332:390:8:-;3379:10;3375:1;:14;3371:351;;;-1:-1:-1;3395:1:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3371:351:8:-;3419:12;3415:1;:16;3411:311;;;-1:-1:-1;3437:1:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3411:311:8:-;3461:13;3457:1;:17;3453:269;;;-1:-1:-1;3480:1:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3453:269:8:-;3504:16;3500:1;:20;3496:226;;;-1:-1:-1;3526:1:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3496:226:8:-;3550:20;3546:1;:24;3542:180;;;-1:-1:-1;3576:1:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3542:180:8:-;3600:26;3596:1;:30;3592:130;;;-1:-1:-1;3632:1:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3592:130:8:-;3656:39;3652:1;:43;3648:74;;;-1:-1:-1;3701:1:8;2374:12:12;1819:584;-1:-1:-1;1819:584:12:o;3648:74:8:-;-1:-1:-1;3721:1:8;2714:1015;;;:::o;1667:4213:50:-;1749:14;;;2289:6;2286:1;2283;2276:20;2329:1;2326;2322:9;2313:18;;2384:5;2380:2;2377:13;2369:5;2365:2;2361:14;2357:34;2348:43;;;2486:5;2495:1;2486:10;2482:368;;2824:11;2816:5;:19;;;;;:::i;:::-;;2809:26;;;;;;2482:368;2974:5;2960:11;:19;2952:53;;;;;;;15070:2:54;2952:53:50;;;15052:21:54;15109:2;15089:18;;;15082:30;15148:23;15128:18;;;15121:51;15189:18;;2952:53:50;;;;;;;;3261:17;3396:11;3393:1;3390;3383:25;4774:1;4755;3944;3929:12;;:16;;3914:32;;4049:22;;;;4755:15;;;4754:21;;5007;;;5003:25;;4992:36;5076:21;;;5072:25;;5061:36;5146:21;;;5142:25;;5131:36;5216:21;;;5212:25;;5201:36;5286:21;;;5282:25;;5271:36;5357:21;;;5353:25;;;5342:36;3899:12;4294;;;4290:23;;;4286:31;;;3510:20;;;3499:32;;;4406:12;;;;3557:21;;4147:16;;;;4397:21;;;;5821:15;;1667:4213;-1:-1:-1;;;;1667:4213:50:o;365:1294:8:-;485:9;539:1;534;:6;:16;;;-1:-1:-1;544:6:8;;;;534:16;530:30;;;-1:-1:-1;559:1:8;552:8;;530:30;-1:-1:-1;578:1:8;594:7;;;;701:31;;;;713:18;729:1;713:15;:18::i;:::-;701:31;;:8;:31::i;:::-;682:51;;751:290;758:6;;;;751:290;;799:17;:1;808:7;;;;;799:8;:17::i;:::-;788:28;;-1:-1:-1;788:28:8;-1:-1:-1;838:131:8;;;;876:2;872:6;;909:2;904:7;;;;944:2;937:9;;;;838:131;1002:19;1016:1;1011:6;;;;1002:19;;1019:1;1002:19;;:8;:19::i;:::-;990:32;;751:290;;;664:391;1069:376;1076:5;;;;1069:376;;1112:11;:1;1121;1112:8;:11::i;:::-;1101:22;;-1:-1:-1;1101:22:8;-1:-1:-1;1141:290:8;;;;1199:3;;;;;1175:2;;-1:-1:-1;1175:2:8;;1199:3;1224:5;1069:376;;1141:290;1258:7;;;;1254:177;;1294:1;1289:6;;;;;;:::i;:::-;;;-1:-1:-1;1317:5:8;;1069:376;;1254:177;1373:14;:1;1382;1385;1373:8;:14::i;:::-;1409:3;;;;;1369:18;-1:-1:-1;1069:376:8;;;1459:9;1471:18;1487:1;1471:15;:18::i;:::-;1459:30;;1503:140;1510:7;;;;1503:140;;1537:8;1555:17;1564:2;1555:17;;1568:3;1555:17;;:8;:17::i;:::-;1537:36;;1601:1;1596:6;;:1;:6;1591:11;;;;;;:::i;:::-;;;-1:-1:-1;1620:8:8;;;;1503:140;;;506:1147;;;;365:1294;;;;;;;:::o;1339:493:51:-;1400:4;1406:7;1683:1;1688;1683:6;1679:28;;-1:-1:-1;1699:4:51;;-1:-1:-1;1705:1:51;1691:16;;1679:28;1733:5;;;1737:1;1733;:5;:1;1756:5;;;;:::i;:::-;;:10;1752:33;;1776:5;1783:1;1768:17;;;;;;;1752:33;1807:4;;-1:-1:-1;1813:1:51;-1:-1:-1;1339:493:51;;;;;;:::o;1746:225:8:-;1878:7;1904:60;1920:1;1923;1926;1929;1932:31;1948:14;1957:1;1960;1948:8;:14::i;:::-;1932:15;:31::i;:::-;1904:15;:60::i;:::-;1897:67;1746:225;-1:-1:-1;;;;;1746:225:8:o;5476:178:12:-;5557:1;5552;:6;5548:100;;5579:30;5605:3;5579:30;;;;;;:::i;:::-;;;;;;;;5623:14;5632:1;5635;5623:8;:14::i;:::-;5476:178;;;:::o;588:104:50:-;646:7;676:1;672;:5;:13;;684:1;672:13;;;680:1;672:13;665:20;;588:104;;;;;:::o;413:::-;471:7;501:1;497;:5;:13;;509:1;497:13;;2141:398:8;2340:1;2291:9;2377:146;2384:5;;;;2377:146;;2420:17;2429:1;2420:17;;2432:4;2420:17;;:8;:17::i;:::-;2409:29;-1:-1:-1;2460:24:8;:1;2469:6;;;;;;;2477;;2460:8;:24::i;:::-;2456:28;;2507:1;2502:6;;;;2377:146;;;2312:221;2141:398;;;;;;;:::o;5209:262:12:-;5271:1;5266;:6;5262:203;;5293:41;;;;;15871:2:54;15853:21;;;15910:2;15890:18;;;15883:30;15949:34;15944:2;15929:18;;15922:62;16020:4;16015:2;16000:18;;15993:32;16057:3;16042:19;;15669:398;5293:41:12;;;;;;;;5353:31;;;16284:21:54;;;16341:2;16321:18;;;16314:30;16380:12;16375:2;16360:18;;16353:40;16460:4;16445:20;;16438:36;;;5353:31:12;;;;;;;16425:3:54;5353:31:12;;;5403;;;16697:21:54;;;16754:2;16734:18;;;16727:30;16793:12;16788:2;16773:18;;16766:40;16873:4;16858:20;;16851:36;;;5403:31:12;;;;;;;16838:3:54;5403:31:12;;;5448:6;:4;:6::i;:::-;5209:262;;:::o;2409:432::-;2997:42;2985:55;3066:16;2452:359;;2652:67;;;1671:64;2652:67;;;17100:74:54;;;2677:17:12;17190:18:54;;;17183:34;;;;2712:4:12;17233:18:54;;;17226:34;2489:11:12;;1671:64;2586:43;;17073:18:54;;2652:67:12;;;;;;;;;;;;;;2541:196;;;2652:67;2541:196;;:::i;:::-;;;;;;;;;;;;;;;2506:245;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;2452:359:12;2820:7;:14;;;;;;;;2409:432::o;14:180:54:-;73:6;126:2;114:9;105:7;101:23;97:32;94:52;;;142:1;139;132:12;94:52;-1:-1:-1;165:23:54;;14:180;-1:-1:-1;14:180:54:o;381:681::-;552:2;604:21;;;674:13;;577:18;;;696:22;;;523:4;;552:2;775:15;;;;749:2;734:18;;;523:4;818:218;832:6;829:1;826:13;818:218;;;897:13;;912:42;893:62;881:75;;1011:15;;;;976:12;;;;854:1;847:9;818:218;;;-1:-1:-1;1053:3:54;;381:681;-1:-1:-1;;;;;;381:681:54:o;1067:250::-;1152:1;1162:113;1176:6;1173:1;1170:13;1162:113;;;1252:11;;;1246:18;1233:11;;;1226:39;1198:2;1191:10;1162:113;;;-1:-1:-1;;1309:1:54;1291:16;;1284:27;1067:250::o;1322:330::-;1364:3;1402:5;1396:12;1429:6;1424:3;1417:19;1445:76;1514:6;1507:4;1502:3;1498:14;1491:4;1484:5;1480:16;1445:76;:::i;:::-;1566:2;1554:15;1571:66;1550:88;1541:98;;;;1641:4;1537:109;;1322:330;-1:-1:-1;;1322:330:54:o;1657:1885::-;1892:2;1944:21;;;2014:13;;1917:18;;;2036:22;;;1863:4;;1892:2;2077;;2095:18;;;;2132:1;2175:15;;;2160:31;;2156:40;;2219:15;;;1863:4;;2283:1230;2299:6;2294:3;2291:15;2283:1230;;;2392:66;2368:22;;;2364:95;2352:108;;2483:13;;2570:9;;2581:42;2566:58;2551:74;;2664:11;;2658:18;2696:15;;;2689:27;;;2777:19;;2523:15;;;2809:24;;;2990:21;;;;2856:2;2938:17;;;2926:30;;2922:39;;;2880:15;;;;3035:1;3049:355;3065:8;3060:3;3057:17;3049:355;;;3167:66;3158:6;3150;3146:19;3142:92;3135:5;3128:107;3262:42;3297:6;3286:8;3280:15;3262:42;:::i;:::-;3333:17;;;;3252:52;-1:-1:-1;3376:14:54;;;;3093:1;3084:11;3049:355;;;-1:-1:-1;;;3491:12:54;;;;3427:6;-1:-1:-1;;3456:15:54;;;;2325:1;2316:11;2283:1230;;;-1:-1:-1;3530:6:54;;1657:1885;-1:-1:-1;;;;;;;;;;1657:1885:54:o;3547:474::-;3631:6;3639;3647;3655;3708:3;3696:9;3687:7;3683:23;3679:33;3676:53;;;3725:1;3722;3715:12;3676:53;3761:9;3748:23;3738:33;;3818:2;3807:9;3803:18;3790:32;3780:42;;3869:2;3858:9;3854:18;3841:32;3831:42;;3923:2;3912:9;3908:18;3895:32;3967:4;3960:5;3956:16;3949:5;3946:27;3936:55;;3987:1;3984;3977:12;3936:55;3547:474;;;;-1:-1:-1;3547:474:54;;-1:-1:-1;;3547:474:54:o;4026:1697::-;4230:4;4259:2;4299;4288:9;4284:18;4329:2;4318:9;4311:21;4352:6;4387;4381:13;4418:6;4410;4403:22;4444:2;4434:12;;4477:2;4466:9;4462:18;4455:25;;4539:2;4529:6;4526:1;4522:14;4511:9;4507:30;4503:39;4577:2;4569:6;4565:15;4598:1;4619;4629:1065;4645:6;4640:3;4637:15;4629:1065;;;4714:22;;;4738:66;4710:95;4698:108;;4829:13;;4916:9;;4927:42;4912:58;4897:74;;5010:11;;5004:18;5042:15;;;5035:27;;;5123:19;;4869:15;;;5155:24;;;5245:21;;;;5290:1;;5213:2;5201:15;;;5304:282;5320:8;5315:3;5312:17;5304:282;;;5401:15;;5418:66;5397:88;5383:103;;5555:17;;;;5348:1;5339:11;;;;;5512:14;;;;5304:282;;;-1:-1:-1;5672:12:54;;;;5609:5;-1:-1:-1;;;5637:15:54;;;;4671:1;4662:11;4629:1065;;;-1:-1:-1;5711:6:54;;4026:1697;-1:-1:-1;;;;;;;;;4026:1697:54:o;5728:862::-;5890:4;5919:2;5959;5948:9;5944:18;5989:2;5978:9;5971:21;6012:6;6047;6041:13;6078:6;6070;6063:22;6116:2;6105:9;6101:18;6094:25;;6178:2;6168:6;6165:1;6161:14;6150:9;6146:30;6142:39;6128:53;;6216:2;6208:6;6204:15;6237:1;6247:314;6261:6;6258:1;6255:13;6247:314;;;6350:66;6338:9;6330:6;6326:22;6322:95;6317:3;6310:108;6441:40;6474:6;6465;6459:13;6441:40;:::i;:::-;6431:50;-1:-1:-1;6539:12:54;;;;6504:15;;;;6283:1;6276:9;6247:314;;;-1:-1:-1;6578:6:54;;5728:862;-1:-1:-1;;;;;;;5728:862:54:o;6992:184::-;7044:77;7041:1;7034:88;7141:4;7138:1;7131:15;7165:4;7162:1;7155:15;7181:482;7270:1;7313:5;7270:1;7327:330;7348:7;7338:8;7335:21;7327:330;;;7467:4;7399:66;7395:77;7389:4;7386:87;7383:113;;;7476:18;;:::i;:::-;7526:7;7516:8;7512:22;7509:55;;;7546:16;;;;7509:55;7625:22;;;;7585:15;;;;7327:330;;;7331:3;7181:482;;;;;:::o;7668:866::-;7717:5;7747:8;7737:80;;-1:-1:-1;7788:1:54;7802:5;;7737:80;7836:4;7826:76;;-1:-1:-1;7873:1:54;7887:5;;7826:76;7918:4;7936:1;7931:59;;;;8004:1;7999:130;;;;7911:218;;7931:59;7961:1;7952:10;;7975:5;;;7999:130;8036:3;8026:8;8023:17;8020:43;;;8043:18;;:::i;:::-;-1:-1:-1;;8099:1:54;8085:16;;8114:5;;7911:218;;8213:2;8203:8;8200:16;8194:3;8188:4;8185:13;8181:36;8175:2;8165:8;8162:16;8157:2;8151:4;8148:12;8144:35;8141:77;8138:159;;;-1:-1:-1;8250:19:54;;;8282:5;;8138:159;8329:34;8354:8;8348:4;8329:34;:::i;:::-;8459:6;8391:66;8387:79;8378:7;8375:92;8372:118;;;8470:18;;:::i;:::-;8508:20;;7668:866;-1:-1:-1;;;7668:866:54:o;8539:131::-;8599:5;8628:36;8655:8;8649:4;8628:36;:::i;8675:437::-;8754:1;8750:12;;;;8797;;;8818:61;;8872:4;8864:6;8860:17;8850:27;;8818:61;8925:2;8917:6;8914:14;8894:18;8891:38;8888:218;;8962:77;8959:1;8952:88;9063:4;9060:1;9053:15;9091:4;9088:1;9081:15;8888:218;;8675:437;;;:::o;9520:287::-;9649:3;9687:6;9681:13;9703:66;9762:6;9757:3;9750:4;9742:6;9738:17;9703:66;:::i;:::-;9785:16;;;;;9520:287;-1:-1:-1;;9520:287:54:o;9812:195::-;9851:3;9882:66;9875:5;9872:77;9869:103;;9952:18;;:::i;:::-;-1:-1:-1;9999:1:54;9988:13;;9812:195::o;10012:168::-;10079:6;10105:10;;;10117;;;10101:27;;10140:11;;;10137:37;;;10154:18;;:::i;:::-;10137:37;10012:168;;;;:::o;10487:430::-;10684:66;10676:6;10672:79;10667:3;10660:92;10642:3;10781:6;10775:13;10797:74;10864:6;10860:1;10855:3;10851:11;10844:4;10836:6;10832:17;10797:74;:::i;:::-;10891:16;;;;10909:1;10887:24;;10487:430;-1:-1:-1;;;10487:430:54:o;10922:277::-;10989:6;11042:2;11030:9;11021:7;11017:23;11013:32;11010:52;;;11058:1;11055;11048:12;11010:52;11090:9;11084:16;11143:5;11136:13;11129:21;11122:5;11119:32;11109:60;;11165:1;11162;11155:12;11204:184;11256:77;11253:1;11246:88;11353:4;11350:1;11343:15;11377:4;11374:1;11367:15;11393:274;11433:1;11459;11449:189;;11494:77;11491:1;11484:88;11595:4;11592:1;11585:15;11623:4;11620:1;11613:15;11449:189;-1:-1:-1;11652:9:54;;11393:274::o;11672:238::-;11709:3;11753:4;11746:5;11742:16;11777:7;11767:41;;11788:18;;:::i;:::-;11837:66;11824:80;;11672:238;-1:-1:-1;;11672:238:54:o;11915:175::-;11952:3;11996:4;11989:5;11985:16;12025:4;12016:7;12013:17;12010:43;;12033:18;;:::i;:::-;12082:1;12069:15;;11915:175;-1:-1:-1;;11915:175:54:o;12095:184::-;12147:77;12144:1;12137:88;12244:4;12241:1;12234:15;12268:4;12265:1;12258:15;12284:956;12364:6;12417:2;12405:9;12396:7;12392:23;12388:32;12385:52;;;12433:1;12430;12423:12;12385:52;12466:9;12460:16;12495:18;12536:2;12528:6;12525:14;12522:34;;;12552:1;12549;12542:12;12522:34;12590:6;12579:9;12575:22;12565:32;;12635:7;12628:4;12624:2;12620:13;12616:27;12606:55;;12657:1;12654;12647:12;12606:55;12686:2;12680:9;12708:2;12704;12701:10;12698:36;;;12714:18;;:::i;:::-;12848:2;12842:9;12910:4;12902:13;;12753:66;12898:22;;;12922:2;12894:31;12890:40;12878:53;;;12946:18;;;12966:22;;;12943:46;12940:72;;;12992:18;;:::i;:::-;13032:10;13028:2;13021:22;13067:2;13059:6;13052:18;13107:7;13102:2;13097;13093;13089:11;13085:20;13082:33;13079:53;;;13128:1;13125;13118:12;13079:53;13141:68;13206:2;13201;13193:6;13189:15;13184:2;13180;13176:11;13141:68;:::i;:::-;13228:6;12284:956;-1:-1:-1;;;;;;;12284:956:54:o;13436:1427::-;14102:14;14097:3;14090:27;14072:3;14146:6;14140:13;14162:75;14230:6;14225:2;14220:3;14216:12;14209:4;14201:6;14197:17;14162:75;:::i;:::-;14301:4;14296:2;14256:16;;;14288:11;;;14281:25;14331:13;;14353:76;14331:13;14415:2;14407:11;;14400:4;14388:17;;14353:76;:::i;:::-;14494:3;14489:2;14448:17;;;;14481:11;;;14474:24;14523:13;;14545:76;14523:13;14607:2;14599:11;;14592:4;14580:17;;14545:76;:::i;:::-;14686:5;14681:2;14640:17;;;;14673:11;;;14666:26;14717:13;;14739:76;14717:13;14801:2;14793:11;;14786:4;14774:17;;14739:76;:::i;:::-;14835:17;14854:2;14831:26;;13436:1427;-1:-1:-1;;;;;;13436:1427:54:o;15218:446::-;15468:2;15457:9;15450:21;15507:1;15502:2;15491:9;15487:18;15480:29;15545:7;15540:2;15529:9;15525:18;15518:35;15591:3;15584:4;15573:9;15569:20;15562:33;15431:4;15612:46;15653:3;15642:9;15638:19;15630:6;15612:46;:::i",
    "linkReferences": {}
  },
  "methodIdentifiers": {
    "IS_TEST()": "fa7626d4",
    "PRECISION()": "aaf5eb68",
    "excludeArtifacts()": "b5508aa9",
    "excludeContracts()": "e20c9f71",
    "excludeSenders()": "1ed7831c",
    "failed()": "ba414fa6",
    "safeUnutilizedPow(uint256,uint256,uint256,uint8)": "e47126d0",
    "targetArtifactSelectors()": "66d9a9a0",
    "targetArtifacts()": "85226c81",
    "targetContracts()": "3f7286f4",
    "targetInterfaces()": "2ade3880",
    "targetSelectors()": "916a17c6",
    "targetSenders()": "3e5e3c23",
    "testFail_findMaxExponent_ExponentWhenPlus1(uint256)": "5a15e501",
    "testGas_mulDiv(uint256,uint256,uint256,uint8)": "93ea09fb",
    "testGas_mulDivLowPrecision(uint256,uint256,uint256,uint8)": "eaf3dc1e",
    "testGas_safeUnutilizedPow(uint256,uint256,uint256,uint8)": "2c8bbef9",
    "testGas_unsafePow(uint256,uint256,uint256,uint8)": "cc1ebd75",
    "test_findMaxExponent(uint256)": "1b7188a7",
    "test_mulDiv(uint256,uint256,uint256,uint8)": "f76ee3ee",
    "unsafePow(uint256,uint256,uint256,uint8)": "2f410386"
  },
  "rawMetadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"log_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"val\",\"type\":\"uint256[]\"}],\"name\":\"log_array\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256[]\",\"name\":\"val\",\"type\":\"int256[]\"}],\"name\":\"log_array\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"val\",\"type\":\"address[]\"}],\"name\":\"log_array\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"log_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"log_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"name\":\"log_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"log_named_address\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"val\",\"type\":\"uint256[]\"}],\"name\":\"log_named_array\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256[]\",\"name\":\"val\",\"type\":\"int256[]\"}],\"name\":\"log_named_array\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"val\",\"type\":\"address[]\"}],\"name\":\"log_named_array\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"}],\"name\":\"log_named_bytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"val\",\"type\":\"bytes32\"}],\"name\":\"log_named_bytes32\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"log_named_decimal_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"val\",\"type\":\"int256\"}],\"name\":\"log_named_int\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"val\",\"type\":\"string\"}],\"name\":\"log_named_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"log_named_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"log_string\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"log_uint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"logs\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_TEST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"excludeArtifacts\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"excludedArtifacts_\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"excludeContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"excludedContracts_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"excludeSenders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"excludedSenders_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"n\",\"type\":\"uint8\"}],\"name\":\"safeUnutilizedPow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetArtifactSelectors\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct StdInvariant.FuzzSelector[]\",\"name\":\"targetedArtifactSelectors_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetArtifacts\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"targetedArtifacts_\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"targetedContracts_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetInterfaces\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"artifacts\",\"type\":\"string[]\"}],\"internalType\":\"struct StdInvariant.FuzzInterface[]\",\"name\":\"targetedInterfaces_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetSelectors\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct StdInvariant.FuzzSelector[]\",\"name\":\"targetedSelectors_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetSenders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"targetedSenders_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"testFail_findMaxExponent_ExponentWhenPlus1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"n\",\"type\":\"uint8\"}],\"name\":\"testGas_mulDiv\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"n\",\"type\":\"uint8\"}],\"name\":\"testGas_mulDivLowPrecision\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"n\",\"type\":\"uint8\"}],\"name\":\"testGas_safeUnutilizedPow\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"n\",\"type\":\"uint8\"}],\"name\":\"testGas_unsafePow\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"test_findMaxExponent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"n\",\"type\":\"uint8\"}],\"name\":\"test_mulDiv\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"n\",\"type\":\"uint8\"}],\"name\":\"unsafePow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"safeUnutilizedPow(uint256,uint256,uint256,uint8)\":{\"notice\":\"Helper method to compute scale: x * (y / d) ^ n.\"},\"testFail_findMaxExponent_ExponentWhenPlus1(uint256)\":{\"notice\":\"Should fail when the exponent k+1.\"},\"testGas_mulDiv(uint256,uint256,uint256,uint8)\":{\"notice\":\"Gas report for {LibPowMath.mulDiv}.\"},\"testGas_mulDivLowPrecision(uint256,uint256,uint256,uint8)\":{\"notice\":\"Gas report for {LibPowMath.mulDivLowPrecision}.\"},\"testGas_safeUnutilizedPow(uint256,uint256,uint256,uint8)\":{\"notice\":\"Gas report for {safeUnutilizedPow}.\"},\"testGas_unsafePow(uint256,uint256,uint256,uint8)\":{\"notice\":\"Gas report for {LibPowMath.unsafePow}.\"},\"test_findMaxExponent(uint256)\":{\"notice\":\"Ensures the method {LibPowMath.findMaxExponent} works without reverting.\"},\"test_mulDiv(uint256,uint256,uint256,uint8)\":{\"notice\":\"Test the correctness of the mul div method {LibPowMath.mulDiv}.\"},\"unsafePow(uint256,uint256,uint256,uint8)\":{\"notice\":\"Helper method to compute scale: x * (y / d) ^ n.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"tests/libraries/math/LibPowMath.t.sol\":\"LibPowMathTest\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[\":@openzeppelin/=node_modules/@openzeppelin/\",\":@solit/contracts/=contracts/\",\":contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":eth-gas-reporter/=node_modules/eth-gas-reporter/\",\":forge-std/=lib/forge-std/src/\",\":hardhat/=node_modules/hardhat/\",\":sample-projects/=node_modules/hardhat/sample-projects/\",\":solady/=node_modules/solady/\",\":solmate/=node_modules/solmate/\"]},\"sources\":{\"contracts/libraries/math/LibPowMath.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\nlibrary LibPowMath {\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Calculates floor(x * (y / d)**n) with full precision.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d,\\n        uint16 n\\n    ) internal pure returns (uint256 r) {\\n        unchecked {\\n            if (y == d || n == 0) return x;\\n            r = x;\\n\\n            bool ok;\\n            uint256 r_;\\n            uint16 nd_;\\n\\n            {\\n                uint16 ye = uint16(Math.min(n, findMaxExponent(y)));\\n                while (ye > 0) {\\n                    (ok, r_) = r.tryMul(y ** ye);\\n                    if (ok) {\\n                        r = r_;\\n                        n -= ye;\\n                        nd_ += ye;\\n                    }\\n                    ye = uint16(Math.min(ye / 2, n));\\n                }\\n            }\\n\\n            while (n > 0) {\\n                (ok, r_) = r.tryMul(y);\\n                if (ok) {\\n                    r = r_;\\n                    n--;\\n                    nd_++;\\n                } else if (nd_ > 0) {\\n                    r /= d;\\n                    nd_--;\\n                } else {\\n                    r = r.mulDiv(y, d);\\n                    n--;\\n                }\\n            }\\n\\n            uint16 de = findMaxExponent(d);\\n            while (nd_ > 0) {\\n                uint16 e = uint16(Math.min(de, nd_));\\n                r /= d ** e;\\n                nd_ -= e;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates floor(x * (y / d)**n) with low precision.\\n     */\\n    function mulDivLowPrecision(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d,\\n        uint16 n\\n    ) internal pure returns (uint256) {\\n        return uncheckedMulDiv(x, y, d, n, findMaxExponent(Math.max(y, d)));\\n    }\\n\\n    /**\\n     * @dev Aggregated calculate multiplications.\\n     * ```\\n     * r = x*(y/d)^k\\n     *   = \\\\prod(x*(y/d)^{k_i}) \\\\ where \\\\ sum(k_i) = k\\n     * ```\\n     */\\n    function uncheckedMulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d,\\n        uint16 n,\\n        uint16 maxE\\n    ) internal pure returns (uint256 r) {\\n        unchecked {\\n            r = x;\\n            uint16 e;\\n            while (n > 0) {\\n                e = uint16(Math.min(n, maxE));\\n                r = r.mulDiv(y ** e, d ** e);\\n                n -= e;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest exponent `k` where, x^k <= 2^256-1\\n     * Note: n = Surd[2^256-1,k]\\n     *         = 10^( log2(2^256-1) / k * log10(2) )\\n     */\\n    function findMaxExponent(uint256 x) internal pure returns (uint16 k) {\\n        if (x < 3) k = 255;\\n        else if (x < 4) k = 128;\\n        else if (x < 16) k = 64;\\n        else if (x < 256) k = 32;\\n        else if (x < 7132) k = 20;\\n        else if (x < 11376) k = 19;\\n        else if (x < 19113) k = 18;\\n        else if (x < 34132) k = 17;\\n        else if (x < 65536) k = 16;\\n        else if (x < 137271) k = 15;\\n        else if (x < 319558) k = 14;\\n        else if (x < 847180) k = 13;\\n        else if (x < 2642246) k = 12;\\n        else if (x < 10134189) k = 11;\\n        else if (x < 50859009) k = 10;\\n        else if (x < 365284285) k = 9;\\n        else if (x < 4294967296) k = 8;\\n        else if (x < 102116749983) k = 7;\\n        else if (x < 6981463658332) k = 6;\\n        else if (x < 2586638741762875) k = 5;\\n        else if (x < 18446744073709551616) k = 4;\\n        else if (x < 48740834812604276470692695) k = 3;\\n        else if (x < 340282366920938463463374607431768211456) k = 2;\\n        else k = 1;\\n    }\\n}\\n\",\"keccak256\":\"0xb33ae0dd981e4854e8742b36c417b077f7b2cd1ce1371d0cabf08edbe43a6f51\",\"license\":\"MIT\"},\"lib/forge-std/lib/ds-test/src/test.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.5.0;\\n\\ncontract DSTest {\\n    event log                    (string);\\n    event logs                   (bytes);\\n\\n    event log_address            (address);\\n    event log_bytes32            (bytes32);\\n    event log_int                (int);\\n    event log_uint               (uint);\\n    event log_bytes              (bytes);\\n    event log_string             (string);\\n\\n    event log_named_address      (string key, address val);\\n    event log_named_bytes32      (string key, bytes32 val);\\n    event log_named_decimal_int  (string key, int val, uint decimals);\\n    event log_named_decimal_uint (string key, uint val, uint decimals);\\n    event log_named_int          (string key, int val);\\n    event log_named_uint         (string key, uint val);\\n    event log_named_bytes        (string key, bytes val);\\n    event log_named_string       (string key, string val);\\n\\n    bool public IS_TEST = true;\\n    bool private _failed;\\n\\n    address constant HEVM_ADDRESS =\\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\\n\\n    modifier mayRevert() { _; }\\n    modifier testopts(string memory) { _; }\\n\\n    function failed() public returns (bool) {\\n        if (_failed) {\\n            return _failed;\\n        } else {\\n            bool globalFailed = false;\\n            if (hasHEVMContext()) {\\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\\n                    abi.encodePacked(\\n                        bytes4(keccak256(\\\"load(address,bytes32)\\\")),\\n                        abi.encode(HEVM_ADDRESS, bytes32(\\\"failed\\\"))\\n                    )\\n                );\\n                globalFailed = abi.decode(retdata, (bool));\\n            }\\n            return globalFailed;\\n        }\\n    }\\n\\n    function fail() internal virtual {\\n        if (hasHEVMContext()) {\\n            (bool status, ) = HEVM_ADDRESS.call(\\n                abi.encodePacked(\\n                    bytes4(keccak256(\\\"store(address,bytes32,bytes32)\\\")),\\n                    abi.encode(HEVM_ADDRESS, bytes32(\\\"failed\\\"), bytes32(uint256(0x01)))\\n                )\\n            );\\n            status; // Silence compiler warnings\\n        }\\n        _failed = true;\\n    }\\n\\n    function hasHEVMContext() internal view returns (bool) {\\n        uint256 hevmCodeSize = 0;\\n        assembly {\\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\\n        }\\n        return hevmCodeSize > 0;\\n    }\\n\\n    modifier logs_gas() {\\n        uint startGas = gasleft();\\n        _;\\n        uint endGas = gasleft();\\n        emit log_named_uint(\\\"gas\\\", startGas - endGas);\\n    }\\n\\n    function assertTrue(bool condition) internal {\\n        if (!condition) {\\n            emit log(\\\"Error: Assertion Failed\\\");\\n            fail();\\n        }\\n    }\\n\\n    function assertTrue(bool condition, string memory err) internal {\\n        if (!condition) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertTrue(condition);\\n        }\\n    }\\n\\n    function assertEq(address a, address b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [address]\\\");\\n            emit log_named_address(\\\"      Left\\\", a);\\n            emit log_named_address(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq(address a, address b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string (\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertEq(bytes32 a, bytes32 b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [bytes32]\\\");\\n            emit log_named_bytes32(\\\"      Left\\\", a);\\n            emit log_named_bytes32(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string (\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n    function assertEq32(bytes32 a, bytes32 b) internal {\\n        assertEq(a, b);\\n    }\\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\\n        assertEq(a, b, err);\\n    }\\n\\n    function assertEq(int a, int b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [int]\\\");\\n            emit log_named_int(\\\"      Left\\\", a);\\n            emit log_named_int(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq(int a, int b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n    function assertEq(uint a, uint b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"      Left\\\", a);\\n            emit log_named_uint(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq(uint a, uint b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n    function assertEqDecimal(int a, int b, uint decimals) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"     Right\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEqDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"     Right\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEqDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertNotEq(address a, address b) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [address]\\\");\\n            emit log_named_address(\\\"      Left\\\", a);\\n            emit log_named_address(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq(address a, address b, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string (\\\"Error\\\", err);\\n            assertNotEq(a, b);\\n        }\\n    }\\n\\n    function assertNotEq(bytes32 a, bytes32 b) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [bytes32]\\\");\\n            emit log_named_bytes32(\\\"      Left\\\", a);\\n            emit log_named_bytes32(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq(bytes32 a, bytes32 b, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string (\\\"Error\\\", err);\\n            assertNotEq(a, b);\\n        }\\n    }\\n    function assertNotEq32(bytes32 a, bytes32 b) internal {\\n        assertNotEq(a, b);\\n    }\\n    function assertNotEq32(bytes32 a, bytes32 b, string memory err) internal {\\n        assertNotEq(a, b, err);\\n    }\\n\\n    function assertNotEq(int a, int b) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [int]\\\");\\n            emit log_named_int(\\\"      Left\\\", a);\\n            emit log_named_int(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq(int a, int b, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEq(a, b);\\n        }\\n    }\\n    function assertNotEq(uint a, uint b) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"      Left\\\", a);\\n            emit log_named_uint(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq(uint a, uint b, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEq(a, b);\\n        }\\n    }\\n    function assertNotEqDecimal(int a, int b, uint decimals) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"     Right\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertNotEqDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEqDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertNotEqDecimal(uint a, uint b, uint decimals) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"     Right\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertNotEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEqDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertGt(uint a, uint b) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGt(uint a, uint b, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGt(a, b);\\n        }\\n    }\\n    function assertGt(int a, int b) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGt(int a, int b, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGt(a, b);\\n        }\\n    }\\n    function assertGtDecimal(int a, int b, uint decimals) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGtDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGtDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertGe(uint a, uint b) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGe(uint a, uint b, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGe(a, b);\\n        }\\n    }\\n    function assertGe(int a, int b) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGe(int a, int b, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGe(a, b);\\n        }\\n    }\\n    function assertGeDecimal(int a, int b, uint decimals) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGeDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGeDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertLt(uint a, uint b) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLt(uint a, uint b, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLt(a, b);\\n        }\\n    }\\n    function assertLt(int a, int b) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLt(int a, int b, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLt(a, b);\\n        }\\n    }\\n    function assertLtDecimal(int a, int b, uint decimals) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLtDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLtDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertLe(uint a, uint b) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLe(uint a, uint b, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLe(a, b);\\n        }\\n    }\\n    function assertLe(int a, int b) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLe(int a, int b, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLe(a, b);\\n        }\\n    }\\n    function assertLeDecimal(int a, int b, uint decimals) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLeDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLeDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertEq(string memory a, string memory b) internal {\\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\\n            emit log(\\\"Error: a == b not satisfied [string]\\\");\\n            emit log_named_string(\\\"      Left\\\", a);\\n            emit log_named_string(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq(string memory a, string memory b, string memory err) internal {\\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertNotEq(string memory a, string memory b) internal {\\n        if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {\\n            emit log(\\\"Error: a != b not satisfied [string]\\\");\\n            emit log_named_string(\\\"      Left\\\", a);\\n            emit log_named_string(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq(string memory a, string memory b, string memory err) internal {\\n        if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEq(a, b);\\n        }\\n    }\\n\\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\\n        ok = true;\\n        if (a.length == b.length) {\\n            for (uint i = 0; i < a.length; i++) {\\n                if (a[i] != b[i]) {\\n                    ok = false;\\n                }\\n            }\\n        } else {\\n            ok = false;\\n        }\\n    }\\n    function assertEq0(bytes memory a, bytes memory b) internal {\\n        if (!checkEq0(a, b)) {\\n            emit log(\\\"Error: a == b not satisfied [bytes]\\\");\\n            emit log_named_bytes(\\\"      Left\\\", a);\\n            emit log_named_bytes(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\\n        if (!checkEq0(a, b)) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq0(a, b);\\n        }\\n    }\\n\\n    function assertNotEq0(bytes memory a, bytes memory b) internal {\\n        if (checkEq0(a, b)) {\\n            emit log(\\\"Error: a != b not satisfied [bytes]\\\");\\n            emit log_named_bytes(\\\"      Left\\\", a);\\n            emit log_named_bytes(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq0(bytes memory a, bytes memory b, string memory err) internal {\\n        if (checkEq0(a, b)) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEq0(a, b);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8758531bbac3972efcf1fa46383dbe1d276406fe527bc7abb2f236486278e83b\",\"license\":\"GPL-3.0-or-later\"},\"lib/forge-std/src/Base.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nimport {StdStorage} from \\\"./StdStorage.sol\\\";\\nimport {Vm, VmSafe} from \\\"./Vm.sol\\\";\\n\\nabstract contract CommonBase {\\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\\\"hevm cheat code\\\"))));\\n    // console.sol and console2.sol work by executing a staticcall to this address.\\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\\\"foundry default caller\\\"))));\\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\\n    // Deterministic deployment address of the Multicall3 contract.\\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\\n    // The order of the secp256k1 curve.\\n    uint256 internal constant SECP256K1_ORDER =\\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\\n\\n    uint256 internal constant UINT256_MAX =\\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    Vm internal constant vm = Vm(VM_ADDRESS);\\n    StdStorage internal stdstore;\\n}\\n\\nabstract contract TestBase is CommonBase {}\\n\\nabstract contract ScriptBase is CommonBase {\\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\\n}\\n\",\"keccak256\":\"0x4ff1a785311017d1eedb1b4737956fa383067ad34eb439abfec1d989754dde1c\",\"license\":\"MIT\"},\"lib/forge-std/src/StdAssertions.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nimport {DSTest} from \\\"ds-test/test.sol\\\";\\nimport {stdMath} from \\\"./StdMath.sol\\\";\\n\\nabstract contract StdAssertions is DSTest {\\n    event log_array(uint256[] val);\\n    event log_array(int256[] val);\\n    event log_array(address[] val);\\n    event log_named_array(string key, uint256[] val);\\n    event log_named_array(string key, int256[] val);\\n    event log_named_array(string key, address[] val);\\n\\n    function fail(string memory err) internal virtual {\\n        emit log_named_string(\\\"Error\\\", err);\\n        fail();\\n    }\\n\\n    function assertFalse(bool data) internal virtual {\\n        assertTrue(!data);\\n    }\\n\\n    function assertFalse(bool data, string memory err) internal virtual {\\n        assertTrue(!data, err);\\n    }\\n\\n    function assertEq(bool a, bool b) internal virtual {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [bool]\\\");\\n            emit log_named_string(\\\"      Left\\\", a ? \\\"true\\\" : \\\"false\\\");\\n            emit log_named_string(\\\"     Right\\\", b ? \\\"true\\\" : \\\"false\\\");\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(bool a, bool b, string memory err) internal virtual {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertEq(bytes memory a, bytes memory b) internal virtual {\\n        assertEq0(a, b);\\n    }\\n\\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {\\n        assertEq0(a, b, err);\\n    }\\n\\n    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log(\\\"Error: a == b not satisfied [uint[]]\\\");\\n            emit log_named_array(\\\"      Left\\\", a);\\n            emit log_named_array(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(int256[] memory a, int256[] memory b) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log(\\\"Error: a == b not satisfied [int[]]\\\");\\n            emit log_named_array(\\\"      Left\\\", a);\\n            emit log_named_array(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(address[] memory a, address[] memory b) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log(\\\"Error: a == b not satisfied [address[]]\\\");\\n            emit log_named_array(\\\"      Left\\\", a);\\n            emit log_named_array(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    // Legacy helper\\n    function assertEqUint(uint256 a, uint256 b) internal virtual {\\n        assertEq(uint256(a), uint256(b));\\n    }\\n\\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"      Left\\\", a);\\n            emit log_named_uint(\\\"     Right\\\", b);\\n            emit log_named_uint(\\\" Max Delta\\\", maxDelta);\\n            emit log_named_uint(\\\"     Delta\\\", delta);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqAbs(a, b, maxDelta);\\n        }\\n    }\\n\\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [uint]\\\");\\n            emit log_named_decimal_uint(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"     Right\\\", b, decimals);\\n            emit log_named_decimal_uint(\\\" Max Delta\\\", maxDelta, decimals);\\n            emit log_named_decimal_uint(\\\"     Delta\\\", delta, decimals);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)\\n        internal\\n        virtual\\n    {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\\n        }\\n    }\\n\\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [int]\\\");\\n            emit log_named_int(\\\"       Left\\\", a);\\n            emit log_named_int(\\\"      Right\\\", b);\\n            emit log_named_uint(\\\" Max Delta\\\", maxDelta);\\n            emit log_named_uint(\\\"     Delta\\\", delta);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqAbs(a, b, maxDelta);\\n        }\\n    }\\n\\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [int]\\\");\\n            emit log_named_decimal_int(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"     Right\\\", b, decimals);\\n            emit log_named_decimal_uint(\\\" Max Delta\\\", maxDelta, decimals);\\n            emit log_named_decimal_uint(\\\"     Delta\\\", delta, decimals);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)\\n        internal\\n        virtual\\n    {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\\n        }\\n    }\\n\\n    function assertApproxEqRel(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"        Left\\\", a);\\n            emit log_named_uint(\\\"       Right\\\", b);\\n            emit log_named_decimal_uint(\\\" Max % Delta\\\", maxPercentDelta * 100, 18);\\n            emit log_named_decimal_uint(\\\"     % Delta\\\", percentDelta * 100, 18);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqRel(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\\n        string memory err\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqRel(a, b, maxPercentDelta);\\n        }\\n    }\\n\\n    function assertApproxEqRelDecimal(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\\n        uint256 decimals\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [uint]\\\");\\n            emit log_named_decimal_uint(\\\"        Left\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"       Right\\\", b, decimals);\\n            emit log_named_decimal_uint(\\\" Max % Delta\\\", maxPercentDelta * 100, 18);\\n            emit log_named_decimal_uint(\\\"     % Delta\\\", percentDelta * 100, 18);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqRelDecimal(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\\n        uint256 decimals,\\n        string memory err\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\\n        }\\n    }\\n\\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [int]\\\");\\n            emit log_named_int(\\\"        Left\\\", a);\\n            emit log_named_int(\\\"       Right\\\", b);\\n            emit log_named_decimal_uint(\\\" Max % Delta\\\", maxPercentDelta * 100, 18);\\n            emit log_named_decimal_uint(\\\"     % Delta\\\", percentDelta * 100, 18);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {\\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqRel(a, b, maxPercentDelta);\\n        }\\n    }\\n\\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [int]\\\");\\n            emit log_named_decimal_int(\\\"        Left\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"       Right\\\", b, decimals);\\n            emit log_named_decimal_uint(\\\" Max % Delta\\\", maxPercentDelta * 100, 18);\\n            emit log_named_decimal_uint(\\\"     % Delta\\\", percentDelta * 100, 18);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)\\n        internal\\n        virtual\\n    {\\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\\n        }\\n    }\\n\\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\\n        assertEqCall(target, callDataA, target, callDataB, true);\\n    }\\n\\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\\n        internal\\n        virtual\\n    {\\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\\n    }\\n\\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\\n        internal\\n        virtual\\n    {\\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\\n    }\\n\\n    function assertEqCall(\\n        address targetA,\\n        bytes memory callDataA,\\n        address targetB,\\n        bytes memory callDataB,\\n        bool strictRevertData\\n    ) internal virtual {\\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\\n\\n        if (successA && successB) {\\n            assertEq(returnDataA, returnDataB, \\\"Call return data does not match\\\");\\n        }\\n\\n        if (!successA && !successB && strictRevertData) {\\n            assertEq(returnDataA, returnDataB, \\\"Call revert data does not match\\\");\\n        }\\n\\n        if (!successA && successB) {\\n            emit log(\\\"Error: Calls were not equal\\\");\\n            emit log_named_bytes(\\\"  Left call revert data\\\", returnDataA);\\n            emit log_named_bytes(\\\" Right call return data\\\", returnDataB);\\n            fail();\\n        }\\n\\n        if (successA && !successB) {\\n            emit log(\\\"Error: Calls were not equal\\\");\\n            emit log_named_bytes(\\\"  Left call return data\\\", returnDataA);\\n            emit log_named_bytes(\\\" Right call revert data\\\", returnDataB);\\n            fail();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1a0dee4d8b2c81e9318e87dd85ef009467ebf7dba6575530d1fce94d34dbae60\",\"license\":\"MIT\"},\"lib/forge-std/src/StdChains.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\n/**\\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\\n * alias used in this contract, which can be found as the first argument to the\\n * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.\\n *\\n * There are two main ways to use this contract:\\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\\n *      `setChain(string memory chainAlias, Chain memory chain)`\\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\\n *\\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\\n * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\\n * `defaultRpcUrls`.\\n *\\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\\n *\\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\\n * we want to retrieve the RPC URL for `mainnet`:\\n *   - If you have specified data with `setChain`, it will return that.\\n *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it\\n *     is valid (e.g. a URL is specified, or an environment variable is given and exists).\\n *   - If neither of the above conditions is met, the default data is returned.\\n *\\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\\n */\\nabstract contract StdChains {\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    bool private stdChainsInitialized;\\n\\n    struct ChainData {\\n        string name;\\n        uint256 chainId;\\n        string rpcUrl;\\n    }\\n\\n    struct Chain {\\n        // The chain name.\\n        string name;\\n        // The chain's Chain ID.\\n        uint256 chainId;\\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\\n        string chainAlias;\\n        // A default RPC endpoint for this chain.\\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\\n        string rpcUrl;\\n    }\\n\\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\\n    mapping(string => Chain) private chains;\\n    // Maps from the chain's alias to it's default RPC URL.\\n    mapping(string => string) private defaultRpcUrls;\\n    // Maps from a chain ID to it's alias.\\n    mapping(uint256 => string) private idToAlias;\\n\\n    bool private fallbackToDefaultRpcUrls = true;\\n\\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\\n        require(bytes(chainAlias).length != 0, \\\"StdChains getChain(string): Chain alias cannot be the empty string.\\\");\\n\\n        initializeStdChains();\\n        chain = chains[chainAlias];\\n        require(\\n            chain.chainId != 0,\\n            string(abi.encodePacked(\\\"StdChains getChain(string): Chain with alias \\\\\\\"\\\", chainAlias, \\\"\\\\\\\" not found.\\\"))\\n        );\\n\\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\\n    }\\n\\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\\n        require(chainId != 0, \\\"StdChains getChain(uint256): Chain ID cannot be 0.\\\");\\n        initializeStdChains();\\n        string memory chainAlias = idToAlias[chainId];\\n\\n        chain = chains[chainAlias];\\n\\n        require(\\n            chain.chainId != 0,\\n            string(abi.encodePacked(\\\"StdChains getChain(uint256): Chain with ID \\\", vm.toString(chainId), \\\" not found.\\\"))\\n        );\\n\\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\\n    }\\n\\n    // set chain info, with priority to argument's rpcUrl field.\\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\\n        require(\\n            bytes(chainAlias).length != 0,\\n            \\\"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\\\"\\n        );\\n\\n        require(chain.chainId != 0, \\\"StdChains setChain(string,ChainData): Chain ID cannot be 0.\\\");\\n\\n        initializeStdChains();\\n        string memory foundAlias = idToAlias[chain.chainId];\\n\\n        require(\\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\\n            string(\\n                abi.encodePacked(\\n                    \\\"StdChains setChain(string,ChainData): Chain ID \\\",\\n                    vm.toString(chain.chainId),\\n                    \\\" already used by \\\\\\\"\\\",\\n                    foundAlias,\\n                    \\\"\\\\\\\".\\\"\\n                )\\n            )\\n        );\\n\\n        uint256 oldChainId = chains[chainAlias].chainId;\\n        delete idToAlias[oldChainId];\\n\\n        chains[chainAlias] =\\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\\n        idToAlias[chain.chainId] = chainAlias;\\n    }\\n\\n    // set chain info, with priority to argument's rpcUrl field.\\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\\n    }\\n\\n    function _toUpper(string memory str) private pure returns (string memory) {\\n        bytes memory strb = bytes(str);\\n        bytes memory copy = new bytes(strb.length);\\n        for (uint256 i = 0; i < strb.length; i++) {\\n            bytes1 b = strb[i];\\n            if (b >= 0x61 && b <= 0x7A) {\\n                copy[i] = bytes1(uint8(b) - 32);\\n            } else {\\n                copy[i] = b;\\n            }\\n        }\\n        return string(copy);\\n    }\\n\\n    // lookup rpcUrl, in descending order of priority:\\n    // current -> config (foundry.toml) -> environment variable -> default\\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain) private returns (Chain memory) {\\n        if (bytes(chain.rpcUrl).length == 0) {\\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\\n                chain.rpcUrl = configRpcUrl;\\n            } catch (bytes memory err) {\\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \\\"_RPC_URL\\\"));\\n                if (fallbackToDefaultRpcUrls) {\\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\\n                } else {\\n                    chain.rpcUrl = vm.envString(envName);\\n                }\\n                // distinguish 'not found' from 'cannot read'\\n                bytes memory notFoundError =\\n                    abi.encodeWithSignature(\\\"CheatCodeError\\\", string(abi.encodePacked(\\\"invalid rpc url \\\", chainAlias)));\\n                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, err), mload(err))\\n                    }\\n                }\\n            }\\n        }\\n        return chain;\\n    }\\n\\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\\n        fallbackToDefaultRpcUrls = useDefault;\\n    }\\n\\n    function initializeStdChains() private {\\n        if (stdChainsInitialized) return;\\n\\n        stdChainsInitialized = true;\\n\\n        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`\\n        setChainWithDefaultRpcUrl(\\\"anvil\\\", ChainData(\\\"Anvil\\\", 31337, \\\"http://127.0.0.1:8545\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"mainnet\\\", ChainData(\\\"Mainnet\\\", 1, \\\"https://mainnet.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"goerli\\\", ChainData(\\\"Goerli\\\", 5, \\\"https://goerli.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"sepolia\\\", ChainData(\\\"Sepolia\\\", 11155111, \\\"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"optimism\\\", ChainData(\\\"Optimism\\\", 10, \\\"https://mainnet.optimism.io\\\"));\\n        setChainWithDefaultRpcUrl(\\\"optimism_goerli\\\", ChainData(\\\"Optimism Goerli\\\", 420, \\\"https://goerli.optimism.io\\\"));\\n        setChainWithDefaultRpcUrl(\\\"arbitrum_one\\\", ChainData(\\\"Arbitrum One\\\", 42161, \\\"https://arb1.arbitrum.io/rpc\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"arbitrum_one_goerli\\\", ChainData(\\\"Arbitrum One Goerli\\\", 421613, \\\"https://goerli-rollup.arbitrum.io/rpc\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"arbitrum_nova\\\", ChainData(\\\"Arbitrum Nova\\\", 42170, \\\"https://nova.arbitrum.io/rpc\\\"));\\n        setChainWithDefaultRpcUrl(\\\"polygon\\\", ChainData(\\\"Polygon\\\", 137, \\\"https://polygon-rpc.com\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"polygon_mumbai\\\", ChainData(\\\"Polygon Mumbai\\\", 80001, \\\"https://rpc-mumbai.maticvigil.com\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"avalanche\\\", ChainData(\\\"Avalanche\\\", 43114, \\\"https://api.avax.network/ext/bc/C/rpc\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"avalanche_fuji\\\", ChainData(\\\"Avalanche Fuji\\\", 43113, \\\"https://api.avax-test.network/ext/bc/C/rpc\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"bnb_smart_chain\\\", ChainData(\\\"BNB Smart Chain\\\", 56, \\\"https://bsc-dataseed1.binance.org\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"bnb_smart_chain_testnet\\\",\\n            ChainData(\\\"BNB Smart Chain Testnet\\\", 97, \\\"https://rpc.ankr.com/bsc_testnet_chapel\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"gnosis_chain\\\", ChainData(\\\"Gnosis Chain\\\", 100, \\\"https://rpc.gnosischain.com\\\"));\\n        setChainWithDefaultRpcUrl(\\\"moonbeam\\\", ChainData(\\\"Moonbeam\\\", 1284, \\\"https://rpc.api.moonbeam.network\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"moonriver\\\", ChainData(\\\"Moonriver\\\", 1285, \\\"https://rpc.api.moonriver.moonbeam.network\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"moonbase\\\", ChainData(\\\"Moonbase\\\", 1287, \\\"https://rpc.testnet.moonbeam.network\\\"));\\n        setChainWithDefaultRpcUrl(\\\"base_goerli\\\", ChainData(\\\"Base Goerli\\\", 84531, \\\"https://goerli.base.org\\\"));\\n        setChainWithDefaultRpcUrl(\\\"base\\\", ChainData(\\\"Base\\\", 8453, \\\"https://mainnet.base.org\\\"));\\n    }\\n\\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\\n        string memory rpcUrl = chain.rpcUrl;\\n        defaultRpcUrls[chainAlias] = rpcUrl;\\n        chain.rpcUrl = \\\"\\\";\\n        setChain(chainAlias, chain);\\n        chain.rpcUrl = rpcUrl; // restore argument\\n    }\\n}\\n\",\"keccak256\":\"0xdbb593a36db1fde25c398f38312cfedc5b39c4bad1c65c2f58b7515c4dd76be8\",\"license\":\"MIT\"},\"lib/forge-std/src/StdCheats.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {StdStorage, stdStorage} from \\\"./StdStorage.sol\\\";\\nimport {console2} from \\\"./console2.sol\\\";\\nimport {Vm} from \\\"./Vm.sol\\\";\\n\\nabstract contract StdCheatsSafe {\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    uint256 private constant UINT256_MAX =\\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    bool private gasMeteringOff;\\n\\n    // Data structures to parse Transaction objects from the broadcast artifact\\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\\n    // and then converted to the one that is used by the user for better UX.\\n\\n    struct RawTx1559 {\\n        string[] arguments;\\n        address contractAddress;\\n        string contractName;\\n        // json value name = function\\n        string functionSig;\\n        bytes32 hash;\\n        // json value name = tx\\n        RawTx1559Detail txDetail;\\n        // json value name = type\\n        string opcode;\\n    }\\n\\n    struct RawTx1559Detail {\\n        AccessList[] accessList;\\n        bytes data;\\n        address from;\\n        bytes gas;\\n        bytes nonce;\\n        address to;\\n        bytes txType;\\n        bytes value;\\n    }\\n\\n    struct Tx1559 {\\n        string[] arguments;\\n        address contractAddress;\\n        string contractName;\\n        string functionSig;\\n        bytes32 hash;\\n        Tx1559Detail txDetail;\\n        string opcode;\\n    }\\n\\n    struct Tx1559Detail {\\n        AccessList[] accessList;\\n        bytes data;\\n        address from;\\n        uint256 gas;\\n        uint256 nonce;\\n        address to;\\n        uint256 txType;\\n        uint256 value;\\n    }\\n\\n    // Data structures to parse Transaction objects from the broadcast artifact\\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\\n    // and then converted to the one that is used by the user for better UX.\\n\\n    struct TxLegacy {\\n        string[] arguments;\\n        address contractAddress;\\n        string contractName;\\n        string functionSig;\\n        string hash;\\n        string opcode;\\n        TxDetailLegacy transaction;\\n    }\\n\\n    struct TxDetailLegacy {\\n        AccessList[] accessList;\\n        uint256 chainId;\\n        bytes data;\\n        address from;\\n        uint256 gas;\\n        uint256 gasPrice;\\n        bytes32 hash;\\n        uint256 nonce;\\n        bytes1 opcode;\\n        bytes32 r;\\n        bytes32 s;\\n        uint256 txType;\\n        address to;\\n        uint8 v;\\n        uint256 value;\\n    }\\n\\n    struct AccessList {\\n        address accessAddress;\\n        bytes32[] storageKeys;\\n    }\\n\\n    // Data structures to parse Receipt objects from the broadcast artifact.\\n    // The Raw structs is what is parsed from the JSON\\n    // and then converted to the one that is used by the user for better UX.\\n\\n    struct RawReceipt {\\n        bytes32 blockHash;\\n        bytes blockNumber;\\n        address contractAddress;\\n        bytes cumulativeGasUsed;\\n        bytes effectiveGasPrice;\\n        address from;\\n        bytes gasUsed;\\n        RawReceiptLog[] logs;\\n        bytes logsBloom;\\n        bytes status;\\n        address to;\\n        bytes32 transactionHash;\\n        bytes transactionIndex;\\n    }\\n\\n    struct Receipt {\\n        bytes32 blockHash;\\n        uint256 blockNumber;\\n        address contractAddress;\\n        uint256 cumulativeGasUsed;\\n        uint256 effectiveGasPrice;\\n        address from;\\n        uint256 gasUsed;\\n        ReceiptLog[] logs;\\n        bytes logsBloom;\\n        uint256 status;\\n        address to;\\n        bytes32 transactionHash;\\n        uint256 transactionIndex;\\n    }\\n\\n    // Data structures to parse the entire broadcast artifact, assuming the\\n    // transactions conform to EIP1559.\\n\\n    struct EIP1559ScriptArtifact {\\n        string[] libraries;\\n        string path;\\n        string[] pending;\\n        Receipt[] receipts;\\n        uint256 timestamp;\\n        Tx1559[] transactions;\\n        TxReturn[] txReturns;\\n    }\\n\\n    struct RawEIP1559ScriptArtifact {\\n        string[] libraries;\\n        string path;\\n        string[] pending;\\n        RawReceipt[] receipts;\\n        TxReturn[] txReturns;\\n        uint256 timestamp;\\n        RawTx1559[] transactions;\\n    }\\n\\n    struct RawReceiptLog {\\n        // json value = address\\n        address logAddress;\\n        bytes32 blockHash;\\n        bytes blockNumber;\\n        bytes data;\\n        bytes logIndex;\\n        bool removed;\\n        bytes32[] topics;\\n        bytes32 transactionHash;\\n        bytes transactionIndex;\\n        bytes transactionLogIndex;\\n    }\\n\\n    struct ReceiptLog {\\n        // json value = address\\n        address logAddress;\\n        bytes32 blockHash;\\n        uint256 blockNumber;\\n        bytes data;\\n        uint256 logIndex;\\n        bytes32[] topics;\\n        uint256 transactionIndex;\\n        uint256 transactionLogIndex;\\n        bool removed;\\n    }\\n\\n    struct TxReturn {\\n        string internalType;\\n        string value;\\n    }\\n\\n    struct Account {\\n        address addr;\\n        uint256 key;\\n    }\\n\\n    enum AddressType {\\n        Payable,\\n        NonPayable,\\n        ZeroAddress,\\n        Precompile,\\n        ForgeAddress\\n    }\\n\\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\\n    function assumeNotBlacklisted(address token, address addr) internal view virtual {\\n        // Nothing to check if `token` is not a contract.\\n        uint256 tokenCodeSize;\\n        assembly {\\n            tokenCodeSize := extcodesize(token)\\n        }\\n        require(tokenCodeSize > 0, \\\"StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.\\\");\\n\\n        bool success;\\n        bytes memory returnData;\\n\\n        // 4-byte selector for `isBlacklisted(address)`, used by USDC.\\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));\\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\\n\\n        // 4-byte selector for `isBlackListed(address)`, used by USDT.\\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));\\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\\n    }\\n\\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\\n    // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for\\n    // backwards compatibility, since this name was used in the original PR which has already has\\n    // a release. This function can be removed in a future release once we want a breaking change.\\n    function assumeNoBlacklisted(address token, address addr) internal view virtual {\\n        assumeNotBlacklisted(token, addr);\\n    }\\n\\n    function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {\\n        if (addressType == AddressType.Payable) {\\n            assumeNotPayable(addr);\\n        } else if (addressType == AddressType.NonPayable) {\\n            assumePayable(addr);\\n        } else if (addressType == AddressType.ZeroAddress) {\\n            assumeNotZeroAddress(addr);\\n        } else if (addressType == AddressType.Precompile) {\\n            assumeNotPrecompile(addr);\\n        } else if (addressType == AddressType.ForgeAddress) {\\n            assumeNotForgeAddress(addr);\\n        }\\n    }\\n\\n    function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {\\n        assumeAddressIsNot(addr, addressType1);\\n        assumeAddressIsNot(addr, addressType2);\\n    }\\n\\n    function assumeAddressIsNot(\\n        address addr,\\n        AddressType addressType1,\\n        AddressType addressType2,\\n        AddressType addressType3\\n    ) internal virtual {\\n        assumeAddressIsNot(addr, addressType1);\\n        assumeAddressIsNot(addr, addressType2);\\n        assumeAddressIsNot(addr, addressType3);\\n    }\\n\\n    function assumeAddressIsNot(\\n        address addr,\\n        AddressType addressType1,\\n        AddressType addressType2,\\n        AddressType addressType3,\\n        AddressType addressType4\\n    ) internal virtual {\\n        assumeAddressIsNot(addr, addressType1);\\n        assumeAddressIsNot(addr, addressType2);\\n        assumeAddressIsNot(addr, addressType3);\\n        assumeAddressIsNot(addr, addressType4);\\n    }\\n\\n    // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to\\n    // `addr` and checking the `success` return value.\\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\\n    // implemented by `addr`, which should be taken into account when this function is used.\\n    function _isPayable(address addr) private returns (bool) {\\n        require(\\n            addr.balance < UINT256_MAX,\\n            \\\"StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds\\\"\\n        );\\n        uint256 origBalanceTest = address(this).balance;\\n        uint256 origBalanceAddr = address(addr).balance;\\n\\n        vm.deal(address(this), 1);\\n        (bool success,) = payable(addr).call{value: 1}(\\\"\\\");\\n\\n        // reset balances\\n        vm.deal(address(this), origBalanceTest);\\n        vm.deal(addr, origBalanceAddr);\\n\\n        return success;\\n    }\\n\\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\\n    // implemented by `addr`, which should be taken into account when this function is used. See the\\n    // `_isPayable` method for more information.\\n    function assumePayable(address addr) internal virtual {\\n        vm.assume(_isPayable(addr));\\n    }\\n\\n    function assumeNotPayable(address addr) internal virtual {\\n        vm.assume(!_isPayable(addr));\\n    }\\n\\n    function assumeNotZeroAddress(address addr) internal pure virtual {\\n        vm.assume(addr != address(0));\\n    }\\n\\n    function assumeNotPrecompile(address addr) internal pure virtual {\\n        assumeNotPrecompile(addr, _pureChainId());\\n    }\\n\\n    function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {\\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\\n        // address), but the same rationale for excluding them applies so we include those too.\\n\\n        // These should be present on all EVM-compatible chains.\\n        vm.assume(addr < address(0x1) || addr > address(0x9));\\n\\n        // forgefmt: disable-start\\n        if (chainId == 10 || chainId == 420) {\\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\\n        } else if (chainId == 42161 || chainId == 421613) {\\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\\n        } else if (chainId == 43114 || chainId == 43113) {\\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\\n        }\\n        // forgefmt: disable-end\\n    }\\n\\n    function assumeNotForgeAddress(address addr) internal pure virtual {\\n        // vm, console, and Create2Deployer addresses\\n        vm.assume(\\n            addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67\\n                && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C\\n        );\\n    }\\n\\n    function readEIP1559ScriptArtifact(string memory path)\\n        internal\\n        view\\n        virtual\\n        returns (EIP1559ScriptArtifact memory)\\n    {\\n        string memory data = vm.readFile(path);\\n        bytes memory parsedData = vm.parseJson(data);\\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\\n        EIP1559ScriptArtifact memory artifact;\\n        artifact.libraries = rawArtifact.libraries;\\n        artifact.path = rawArtifact.path;\\n        artifact.timestamp = rawArtifact.timestamp;\\n        artifact.pending = rawArtifact.pending;\\n        artifact.txReturns = rawArtifact.txReturns;\\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\\n        return artifact;\\n    }\\n\\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\\n        for (uint256 i; i < rawTxs.length; i++) {\\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\\n        }\\n        return txs;\\n    }\\n\\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\\n        Tx1559 memory transaction;\\n        transaction.arguments = rawTx.arguments;\\n        transaction.contractName = rawTx.contractName;\\n        transaction.functionSig = rawTx.functionSig;\\n        transaction.hash = rawTx.hash;\\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\\n        transaction.opcode = rawTx.opcode;\\n        return transaction;\\n    }\\n\\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\\n        internal\\n        pure\\n        virtual\\n        returns (Tx1559Detail memory)\\n    {\\n        Tx1559Detail memory txDetail;\\n        txDetail.data = rawDetail.data;\\n        txDetail.from = rawDetail.from;\\n        txDetail.to = rawDetail.to;\\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\\n        txDetail.txType = _bytesToUint(rawDetail.txType);\\n        txDetail.value = _bytesToUint(rawDetail.value);\\n        txDetail.gas = _bytesToUint(rawDetail.gas);\\n        txDetail.accessList = rawDetail.accessList;\\n        return txDetail;\\n    }\\n\\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\\n        string memory deployData = vm.readFile(path);\\n        bytes memory parsedDeployData = vm.parseJson(deployData, \\\".transactions\\\");\\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\\n        return rawToConvertedEIPTx1559s(rawTxs);\\n    }\\n\\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\\n        string memory deployData = vm.readFile(path);\\n        string memory key = string(abi.encodePacked(\\\".transactions[\\\", vm.toString(index), \\\"]\\\"));\\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\\n        return rawToConvertedEIPTx1559(rawTx);\\n    }\\n\\n    // Analogous to readTransactions, but for receipts.\\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\\n        string memory deployData = vm.readFile(path);\\n        bytes memory parsedDeployData = vm.parseJson(deployData, \\\".receipts\\\");\\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\\n        return rawToConvertedReceipts(rawReceipts);\\n    }\\n\\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\\n        string memory deployData = vm.readFile(path);\\n        string memory key = string(abi.encodePacked(\\\".receipts[\\\", vm.toString(index), \\\"]\\\"));\\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\\n        return rawToConvertedReceipt(rawReceipt);\\n    }\\n\\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\\n        for (uint256 i; i < rawReceipts.length; i++) {\\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\\n        }\\n        return receipts;\\n    }\\n\\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\\n        Receipt memory receipt;\\n        receipt.blockHash = rawReceipt.blockHash;\\n        receipt.to = rawReceipt.to;\\n        receipt.from = rawReceipt.from;\\n        receipt.contractAddress = rawReceipt.contractAddress;\\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\\n        receipt.status = _bytesToUint(rawReceipt.status);\\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\\n        receipt.logsBloom = rawReceipt.logsBloom;\\n        receipt.transactionHash = rawReceipt.transactionHash;\\n        return receipt;\\n    }\\n\\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\\n        internal\\n        pure\\n        virtual\\n        returns (ReceiptLog[] memory)\\n    {\\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\\n        for (uint256 i; i < rawLogs.length; i++) {\\n            logs[i].logAddress = rawLogs[i].logAddress;\\n            logs[i].blockHash = rawLogs[i].blockHash;\\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\\n            logs[i].data = rawLogs[i].data;\\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\\n            logs[i].topics = rawLogs[i].topics;\\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\\n            logs[i].removed = rawLogs[i].removed;\\n        }\\n        return logs;\\n    }\\n\\n    // Deploy a contract by fetching the contract bytecode from\\n    // the artifacts directory\\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string,bytes): Deployment failed.\\\");\\n    }\\n\\n    function deployCode(string memory what) internal virtual returns (address addr) {\\n        bytes memory bytecode = vm.getCode(what);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string): Deployment failed.\\\");\\n    }\\n\\n    /// @dev deploy contract with value on construction\\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string,bytes,uint256): Deployment failed.\\\");\\n    }\\n\\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\\n        bytes memory bytecode = vm.getCode(what);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string,uint256): Deployment failed.\\\");\\n    }\\n\\n    // creates a labeled address and the corresponding private key\\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\\n        addr = vm.addr(privateKey);\\n        vm.label(addr, name);\\n    }\\n\\n    // creates a labeled address\\n    function makeAddr(string memory name) internal virtual returns (address addr) {\\n        (addr,) = makeAddrAndKey(name);\\n    }\\n\\n    // Destroys an account immediately, sending the balance to beneficiary.\\n    // Destroying means: balance will be zero, code will be empty, and nonce will be 0\\n    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce\\n    // only after tx ends, this will run immediately.\\n    function destroyAccount(address who, address beneficiary) internal virtual {\\n        uint256 currBalance = who.balance;\\n        vm.etch(who, abi.encode());\\n        vm.deal(who, 0);\\n        vm.resetNonce(who);\\n\\n        uint256 beneficiaryBalance = beneficiary.balance;\\n        vm.deal(beneficiary, currBalance + beneficiaryBalance);\\n    }\\n\\n    // creates a struct containing both a labeled address and the corresponding private key\\n    function makeAccount(string memory name) internal virtual returns (Account memory account) {\\n        (account.addr, account.key) = makeAddrAndKey(name);\\n    }\\n\\n    function deriveRememberKey(string memory mnemonic, uint32 index)\\n        internal\\n        virtual\\n        returns (address who, uint256 privateKey)\\n    {\\n        privateKey = vm.deriveKey(mnemonic, index);\\n        who = vm.rememberKey(privateKey);\\n    }\\n\\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\\n        require(b.length <= 32, \\\"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\\\");\\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\\n    }\\n\\n    function isFork() internal view virtual returns (bool status) {\\n        try vm.activeFork() {\\n            status = true;\\n        } catch (bytes memory) {}\\n    }\\n\\n    modifier skipWhenForking() {\\n        if (!isFork()) {\\n            _;\\n        }\\n    }\\n\\n    modifier skipWhenNotForking() {\\n        if (isFork()) {\\n            _;\\n        }\\n    }\\n\\n    modifier noGasMetering() {\\n        vm.pauseGasMetering();\\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\\n        // it back on until we exit the top level function that used the modifier\\n        //\\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\\n        // so we only turn metering back on at the end of the funcA\\n        bool gasStartedOff = gasMeteringOff;\\n        gasMeteringOff = true;\\n\\n        _;\\n\\n        // if gas metering was on when this modifier was called, turn it back on at the end\\n        if (!gasStartedOff) {\\n            gasMeteringOff = false;\\n            vm.resumeGasMetering();\\n        }\\n    }\\n\\n    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no\\n    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We\\n    // can't simply access the chain ID in a normal view or pure function because the solc View Pure\\n    // Checker changed `chainid` from pure to view in 0.8.0.\\n    function _viewChainId() private view returns (uint256 chainId) {\\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        address(this); // Silence warnings in older Solc versions.\\n    }\\n\\n    function _pureChainId() private pure returns (uint256 chainId) {\\n        function() internal view returns (uint256) fnIn = _viewChainId;\\n        function() internal pure returns (uint256) pureChainId;\\n        assembly {\\n            pureChainId := fnIn\\n        }\\n        chainId = pureChainId();\\n    }\\n}\\n\\n// Wrappers around cheatcodes to avoid footguns\\nabstract contract StdCheats is StdCheatsSafe {\\n    using stdStorage for StdStorage;\\n\\n    StdStorage private stdstore;\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    // Skip forward or rewind time by the specified number of seconds\\n    function skip(uint256 time) internal virtual {\\n        vm.warp(block.timestamp + time);\\n    }\\n\\n    function rewind(uint256 time) internal virtual {\\n        vm.warp(block.timestamp - time);\\n    }\\n\\n    // Setup a prank from an address that has some ether\\n    function hoax(address msgSender) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.prank(msgSender);\\n    }\\n\\n    function hoax(address msgSender, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.prank(msgSender);\\n    }\\n\\n    function hoax(address msgSender, address origin) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.prank(msgSender, origin);\\n    }\\n\\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.prank(msgSender, origin);\\n    }\\n\\n    // Start perpetual prank from an address that has some ether\\n    function startHoax(address msgSender) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.startPrank(msgSender);\\n    }\\n\\n    function startHoax(address msgSender, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.startPrank(msgSender);\\n    }\\n\\n    // Start perpetual prank from an address that has some ether\\n    // tx.origin is set to the origin parameter\\n    function startHoax(address msgSender, address origin) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.startPrank(msgSender, origin);\\n    }\\n\\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.startPrank(msgSender, origin);\\n    }\\n\\n    function changePrank(address msgSender) internal virtual {\\n        console2_log(\\\"changePrank is deprecated. Please use vm.startPrank instead.\\\");\\n        vm.stopPrank();\\n        vm.startPrank(msgSender);\\n    }\\n\\n    function changePrank(address msgSender, address txOrigin) internal virtual {\\n        vm.stopPrank();\\n        vm.startPrank(msgSender, txOrigin);\\n    }\\n\\n    // The same as Vm's `deal`\\n    // Use the alternative signature for ERC20 tokens\\n    function deal(address to, uint256 give) internal virtual {\\n        vm.deal(to, give);\\n    }\\n\\n    // Set the balance of an account for any ERC20 token\\n    // Use the alternative signature to update `totalSupply`\\n    function deal(address token, address to, uint256 give) internal virtual {\\n        deal(token, to, give, false);\\n    }\\n\\n    // Set the balance of an account for any ERC1155 token\\n    // Use the alternative signature to update `totalSupply`\\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\\n        dealERC1155(token, to, id, give, false);\\n    }\\n\\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\\n        // get current balance\\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\\n        uint256 prevBal = abi.decode(balData, (uint256));\\n\\n        // update balance\\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\\n\\n        // update total supply\\n        if (adjust) {\\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\\n            uint256 totSup = abi.decode(totSupData, (uint256));\\n            if (give < prevBal) {\\n                totSup -= (prevBal - give);\\n            } else {\\n                totSup += (give - prevBal);\\n            }\\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\\n        }\\n    }\\n\\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\\n        // get current balance\\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));\\n        uint256 prevBal = abi.decode(balData, (uint256));\\n\\n        // update balance\\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\\n\\n        // update total supply\\n        if (adjust) {\\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));\\n            require(\\n                totSupData.length != 0,\\n                \\\"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\\\"\\n            );\\n            uint256 totSup = abi.decode(totSupData, (uint256));\\n            if (give < prevBal) {\\n                totSup -= (prevBal - give);\\n            } else {\\n                totSup += (give - prevBal);\\n            }\\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\\n        }\\n    }\\n\\n    function dealERC721(address token, address to, uint256 id) internal virtual {\\n        // check if token id is already minted and the actual owner.\\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\\n        require(successMinted, \\\"StdCheats deal(address,address,uint,bool): id not minted.\\\");\\n\\n        // get owner current balance\\n        (, bytes memory fromBalData) =\\n            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\\n\\n        // get new user current balance\\n        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\\n\\n        // update balances\\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\\n\\n        // update owner\\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\\n    }\\n\\n    function deployCodeTo(string memory what, address where) internal virtual {\\n        deployCodeTo(what, \\\"\\\", 0, where);\\n    }\\n\\n    function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {\\n        deployCodeTo(what, args, 0, where);\\n    }\\n\\n    function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {\\n        bytes memory creationCode = vm.getCode(what);\\n        vm.etch(where, abi.encodePacked(creationCode, args));\\n        (bool success, bytes memory runtimeBytecode) = where.call{value: value}(\\\"\\\");\\n        require(success, \\\"StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.\\\");\\n        vm.etch(where, runtimeBytecode);\\n    }\\n\\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\\n    function console2_log(string memory p0) private view {\\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n        status;\\n    }\\n}\\n\",\"keccak256\":\"0xa0bac08b3d12d561fadf74c83c69f3ee54fe40e0c7766611766f6db70c202373\",\"license\":\"MIT\"},\"lib/forge-std/src/StdError.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\\npragma solidity >=0.6.2 <0.9.0;\\n\\nlibrary stdError {\\n    bytes public constant assertionError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x01);\\n    bytes public constant arithmeticError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x11);\\n    bytes public constant divisionError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x12);\\n    bytes public constant enumConversionError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x21);\\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x22);\\n    bytes public constant popError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x31);\\n    bytes public constant indexOOBError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x32);\\n    bytes public constant memOverflowError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x41);\\n    bytes public constant zeroVarError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x51);\\n}\\n\",\"keccak256\":\"0xbf477b11a42d7611696956546bcfaa29317d1166bf65e402344599c05943fc77\",\"license\":\"MIT\"},\"lib/forge-std/src/StdInvariant.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nabstract contract StdInvariant {\\n    struct FuzzSelector {\\n        address addr;\\n        bytes4[] selectors;\\n    }\\n\\n    struct FuzzInterface {\\n        address addr;\\n        string[] artifacts;\\n    }\\n\\n    address[] private _excludedContracts;\\n    address[] private _excludedSenders;\\n    address[] private _targetedContracts;\\n    address[] private _targetedSenders;\\n\\n    string[] private _excludedArtifacts;\\n    string[] private _targetedArtifacts;\\n\\n    FuzzSelector[] private _targetedArtifactSelectors;\\n    FuzzSelector[] private _targetedSelectors;\\n\\n    FuzzInterface[] private _targetedInterfaces;\\n\\n    // Functions for users:\\n    // These are intended to be called in tests.\\n\\n    function excludeContract(address newExcludedContract_) internal {\\n        _excludedContracts.push(newExcludedContract_);\\n    }\\n\\n    function excludeSender(address newExcludedSender_) internal {\\n        _excludedSenders.push(newExcludedSender_);\\n    }\\n\\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\\n        _excludedArtifacts.push(newExcludedArtifact_);\\n    }\\n\\n    function targetArtifact(string memory newTargetedArtifact_) internal {\\n        _targetedArtifacts.push(newTargetedArtifact_);\\n    }\\n\\n    function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {\\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\\n    }\\n\\n    function targetContract(address newTargetedContract_) internal {\\n        _targetedContracts.push(newTargetedContract_);\\n    }\\n\\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\\n        _targetedSelectors.push(newTargetedSelector_);\\n    }\\n\\n    function targetSender(address newTargetedSender_) internal {\\n        _targetedSenders.push(newTargetedSender_);\\n    }\\n\\n    function targetInterface(FuzzInterface memory newTargetedInterface_) internal {\\n        _targetedInterfaces.push(newTargetedInterface_);\\n    }\\n\\n    // Functions for forge:\\n    // These are called by forge to run invariant tests and don't need to be called in tests.\\n\\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\\n        excludedArtifacts_ = _excludedArtifacts;\\n    }\\n\\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\\n        excludedContracts_ = _excludedContracts;\\n    }\\n\\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\\n        excludedSenders_ = _excludedSenders;\\n    }\\n\\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\\n        targetedArtifacts_ = _targetedArtifacts;\\n    }\\n\\n    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\\n    }\\n\\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\\n        targetedContracts_ = _targetedContracts;\\n    }\\n\\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\\n        targetedSelectors_ = _targetedSelectors;\\n    }\\n\\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\\n        targetedSenders_ = _targetedSenders;\\n    }\\n\\n    function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {\\n        targetedInterfaces_ = _targetedInterfaces;\\n    }\\n}\\n\",\"keccak256\":\"0x67299bfacd77fddfa2a67b8e2b901e0e333618a4975fb94850b07475e51f6de6\",\"license\":\"MIT\"},\"lib/forge-std/src/StdJson.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\n// Helpers for parsing and writing JSON files\\n// To parse:\\n// ```\\n// using stdJson for string;\\n// string memory json = vm.readFile(\\\"some_peth\\\");\\n// json.parseUint(\\\"<json_path>\\\");\\n// ```\\n// To write:\\n// ```\\n// using stdJson for string;\\n// string memory json = \\\"deploymentArtifact\\\";\\n// Contract contract = new Contract();\\n// json.serialize(\\\"contractAddress\\\", address(contract));\\n// json = json.serialize(\\\"deploymentTimes\\\", uint(1));\\n// // store the stringified JSON to the 'json' variable we have been using as a key\\n// // as we won't need it any longer\\n// string memory json2 = \\\"finalArtifact\\\";\\n// string memory final = json2.serialize(\\\"depArtifact\\\", json);\\n// final.write(\\\"<some_path>\\\");\\n// ```\\n\\nlibrary stdJson {\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\\n        return vm.parseJson(json, key);\\n    }\\n\\n    function readUint(string memory json, string memory key) internal pure returns (uint256) {\\n        return vm.parseJsonUint(json, key);\\n    }\\n\\n    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {\\n        return vm.parseJsonUintArray(json, key);\\n    }\\n\\n    function readInt(string memory json, string memory key) internal pure returns (int256) {\\n        return vm.parseJsonInt(json, key);\\n    }\\n\\n    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {\\n        return vm.parseJsonIntArray(json, key);\\n    }\\n\\n    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {\\n        return vm.parseJsonBytes32(json, key);\\n    }\\n\\n    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {\\n        return vm.parseJsonBytes32Array(json, key);\\n    }\\n\\n    function readString(string memory json, string memory key) internal pure returns (string memory) {\\n        return vm.parseJsonString(json, key);\\n    }\\n\\n    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {\\n        return vm.parseJsonStringArray(json, key);\\n    }\\n\\n    function readAddress(string memory json, string memory key) internal pure returns (address) {\\n        return vm.parseJsonAddress(json, key);\\n    }\\n\\n    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {\\n        return vm.parseJsonAddressArray(json, key);\\n    }\\n\\n    function readBool(string memory json, string memory key) internal pure returns (bool) {\\n        return vm.parseJsonBool(json, key);\\n    }\\n\\n    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {\\n        return vm.parseJsonBoolArray(json, key);\\n    }\\n\\n    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {\\n        return vm.parseJsonBytes(json, key);\\n    }\\n\\n    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {\\n        return vm.parseJsonBytesArray(json, key);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {\\n        return vm.serializeJson(jsonKey, rootObject);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\\n        return vm.serializeBool(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeBool(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\\n        return vm.serializeUint(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeUint(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\\n        return vm.serializeInt(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeInt(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\\n        return vm.serializeAddress(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeAddress(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\\n        return vm.serializeBytes32(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeBytes32(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\\n        return vm.serializeBytes(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeBytes(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, string memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeString(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeString(jsonKey, key, value);\\n    }\\n\\n    function write(string memory jsonKey, string memory path) internal {\\n        vm.writeJson(jsonKey, path);\\n    }\\n\\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\\n        vm.writeJson(jsonKey, path, valueKey);\\n    }\\n}\\n\",\"keccak256\":\"0x8f914dbd016bd0e318fe2b8bd556fbc8256c7cddc24e3e4fcb9f3c1c1935592d\",\"license\":\"MIT\"},\"lib/forge-std/src/StdMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nlibrary stdMath {\\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n\\n    function abs(int256 a) internal pure returns (uint256) {\\n        // Required or it will fail when `a = type(int256).min`\\n        if (a == INT256_MIN) {\\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n        }\\n\\n        return uint256(a > 0 ? a : -a);\\n    }\\n\\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a - b : b - a;\\n    }\\n\\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\\n        // a and b are of the same sign\\n        // this works thanks to two's complement, the left-most bit is the sign bit\\n        if ((a ^ b) > -1) {\\n            return delta(abs(a), abs(b));\\n        }\\n\\n        // a and b are of opposite signs\\n        return abs(a) + abs(b);\\n    }\\n\\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 absDelta = delta(a, b);\\n\\n        return absDelta * 1e18 / b;\\n    }\\n\\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\\n        uint256 absDelta = delta(a, b);\\n        uint256 absB = abs(b);\\n\\n        return absDelta * 1e18 / absB;\\n    }\\n}\\n\",\"keccak256\":\"0xd90ad4fd8aeaeb8929964e686e769fdedd5eded3fc3815df194a0ab9f91a3fb2\",\"license\":\"MIT\"},\"lib/forge-std/src/StdStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nimport {Vm} from \\\"./Vm.sol\\\";\\n\\nstruct StdStorage {\\n    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\\n    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;\\n    bytes32[] _keys;\\n    bytes4 _sig;\\n    uint256 _depth;\\n    address _target;\\n    bytes32 _set;\\n}\\n\\nlibrary stdStorageSafe {\\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\\n    event WARNING_UninitedSlot(address who, uint256 slot);\\n\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\\n        return bytes4(keccak256(bytes(sigStr)));\\n    }\\n\\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\\n    // slot complexity:\\n    //  if flat, will be bytes32(uint256(uint));\\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\\n    function find(StdStorage storage self) internal returns (uint256) {\\n        address who = self._target;\\n        bytes4 fsig = self._sig;\\n        uint256 field_depth = self._depth;\\n        bytes32[] memory ins = self._keys;\\n\\n        // calldata to test against\\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\\n        }\\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\\n        vm.record();\\n        bytes32 fdat;\\n        {\\n            (, bytes memory rdat) = who.staticcall(cald);\\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\\n        }\\n\\n        (bytes32[] memory reads,) = vm.accesses(address(who));\\n        if (reads.length == 1) {\\n            bytes32 curr = vm.load(who, reads[0]);\\n            if (curr == bytes32(0)) {\\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\\n            }\\n            if (fdat != curr) {\\n                require(\\n                    false,\\n                    \\\"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\\\"\\n                );\\n            }\\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\\n        } else if (reads.length > 1) {\\n            for (uint256 i = 0; i < reads.length; i++) {\\n                bytes32 prev = vm.load(who, reads[i]);\\n                if (prev == bytes32(0)) {\\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\\n                }\\n                if (prev != fdat) {\\n                    continue;\\n                }\\n                bytes32 new_val = ~prev;\\n                // store\\n                vm.store(who, reads[i], new_val);\\n                bool success;\\n                {\\n                    bytes memory rdat;\\n                    (success, rdat) = who.staticcall(cald);\\n                    fdat = bytesToBytes32(rdat, 32 * field_depth);\\n                }\\n\\n                if (success && fdat == new_val) {\\n                    // we found which of the slots is the actual one\\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\\n                    vm.store(who, reads[i], prev);\\n                    break;\\n                }\\n                vm.store(who, reads[i], prev);\\n            }\\n        } else {\\n            revert(\\\"stdStorage find(StdStorage): No storage use detected for target.\\\");\\n        }\\n\\n        require(\\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],\\n            \\\"stdStorage find(StdStorage): Slot(s) not found.\\\"\\n        );\\n\\n        delete self._target;\\n        delete self._sig;\\n        delete self._keys;\\n        delete self._depth;\\n\\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\\n    }\\n\\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\\n        self._target = _target;\\n        return self;\\n    }\\n\\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\\n        self._sig = _sig;\\n        return self;\\n    }\\n\\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\\n        self._sig = sigs(_sig);\\n        return self;\\n    }\\n\\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\\n        self._keys.push(bytes32(uint256(uint160(who))));\\n        return self;\\n    }\\n\\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\\n        self._keys.push(bytes32(amt));\\n        return self;\\n    }\\n\\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\\n        self._keys.push(key);\\n        return self;\\n    }\\n\\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\\n        self._depth = _depth;\\n        return self;\\n    }\\n\\n    function read(StdStorage storage self) private returns (bytes memory) {\\n        address t = self._target;\\n        uint256 s = find(self);\\n        return abi.encode(vm.load(t, bytes32(s)));\\n    }\\n\\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\\n        return abi.decode(read(self), (bytes32));\\n    }\\n\\n    function read_bool(StdStorage storage self) internal returns (bool) {\\n        int256 v = read_int(self);\\n        if (v == 0) return false;\\n        if (v == 1) return true;\\n        revert(\\\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\\\");\\n    }\\n\\n    function read_address(StdStorage storage self) internal returns (address) {\\n        return abi.decode(read(self), (address));\\n    }\\n\\n    function read_uint(StdStorage storage self) internal returns (uint256) {\\n        return abi.decode(read(self), (uint256));\\n    }\\n\\n    function read_int(StdStorage storage self) internal returns (int256) {\\n        return abi.decode(read(self), (int256));\\n    }\\n\\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\\n        address who = self._target;\\n        uint256 field_depth = self._depth;\\n        vm.startMappingRecording();\\n        uint256 child = find(self) - field_depth;\\n        (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\\n        if (!found) {\\n            revert(\\n                \\\"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\\\"\\n            );\\n        }\\n        return (uint256(parent_slot), key);\\n    }\\n\\n    function root(StdStorage storage self) internal returns (uint256) {\\n        address who = self._target;\\n        uint256 field_depth = self._depth;\\n        vm.startMappingRecording();\\n        uint256 child = find(self) - field_depth;\\n        bool found;\\n        bytes32 root_slot;\\n        bytes32 parent_slot;\\n        (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\\n        if (!found) {\\n            revert(\\n                \\\"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\\\"\\n            );\\n        }\\n        while (found) {\\n            root_slot = parent_slot;\\n            (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));\\n        }\\n        return uint256(root_slot);\\n    }\\n\\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\\n        bytes32 out;\\n\\n        uint256 max = b.length > 32 ? 32 : b.length;\\n        for (uint256 i = 0; i < max; i++) {\\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\\n        }\\n        return out;\\n    }\\n\\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\\n        bytes memory result = new bytes(b.length * 32);\\n        for (uint256 i = 0; i < b.length; i++) {\\n            bytes32 k = b[i];\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(add(result, add(32, mul(32, i))), k)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\nlibrary stdStorage {\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\\n        return stdStorageSafe.sigs(sigStr);\\n    }\\n\\n    function find(StdStorage storage self) internal returns (uint256) {\\n        return stdStorageSafe.find(self);\\n    }\\n\\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\\n        return stdStorageSafe.target(self, _target);\\n    }\\n\\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\\n        return stdStorageSafe.sig(self, _sig);\\n    }\\n\\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\\n        return stdStorageSafe.sig(self, _sig);\\n    }\\n\\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\\n        return stdStorageSafe.with_key(self, who);\\n    }\\n\\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\\n        return stdStorageSafe.with_key(self, amt);\\n    }\\n\\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\\n        return stdStorageSafe.with_key(self, key);\\n    }\\n\\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\\n        return stdStorageSafe.depth(self, _depth);\\n    }\\n\\n    function checked_write(StdStorage storage self, address who) internal {\\n        checked_write(self, bytes32(uint256(uint160(who))));\\n    }\\n\\n    function checked_write(StdStorage storage self, uint256 amt) internal {\\n        checked_write(self, bytes32(amt));\\n    }\\n\\n    function checked_write_int(StdStorage storage self, int256 val) internal {\\n        checked_write(self, bytes32(uint256(val)));\\n    }\\n\\n    function checked_write(StdStorage storage self, bool write) internal {\\n        bytes32 t;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            t := write\\n        }\\n        checked_write(self, t);\\n    }\\n\\n    function checked_write(StdStorage storage self, bytes32 set) internal {\\n        address who = self._target;\\n        bytes4 fsig = self._sig;\\n        uint256 field_depth = self._depth;\\n        bytes32[] memory ins = self._keys;\\n\\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\\n            find(self);\\n        }\\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\\n\\n        bytes32 fdat;\\n        {\\n            (, bytes memory rdat) = who.staticcall(cald);\\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\\n        }\\n        bytes32 curr = vm.load(who, slot);\\n\\n        if (fdat != curr) {\\n            require(\\n                false,\\n                \\\"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\\\"\\n            );\\n        }\\n        vm.store(who, slot, set);\\n        delete self._target;\\n        delete self._sig;\\n        delete self._keys;\\n        delete self._depth;\\n    }\\n\\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\\n        return stdStorageSafe.read_bytes32(self);\\n    }\\n\\n    function read_bool(StdStorage storage self) internal returns (bool) {\\n        return stdStorageSafe.read_bool(self);\\n    }\\n\\n    function read_address(StdStorage storage self) internal returns (address) {\\n        return stdStorageSafe.read_address(self);\\n    }\\n\\n    function read_uint(StdStorage storage self) internal returns (uint256) {\\n        return stdStorageSafe.read_uint(self);\\n    }\\n\\n    function read_int(StdStorage storage self) internal returns (int256) {\\n        return stdStorageSafe.read_int(self);\\n    }\\n\\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\\n        return stdStorageSafe.parent(self);\\n    }\\n\\n    function root(StdStorage storage self) internal returns (uint256) {\\n        return stdStorageSafe.root(self);\\n    }\\n\\n    // Private function so needs to be copied over\\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\\n        bytes32 out;\\n\\n        uint256 max = b.length > 32 ? 32 : b.length;\\n        for (uint256 i = 0; i < max; i++) {\\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\\n        }\\n        return out;\\n    }\\n\\n    // Private function so needs to be copied over\\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\\n        bytes memory result = new bytes(b.length * 32);\\n        for (uint256 i = 0; i < b.length; i++) {\\n            bytes32 k = b[i];\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(add(result, add(32, mul(32, i))), k)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x4298f3f4cedaedb07029820b1daad2c03af45379559392201f7bf3ec71105811\",\"license\":\"MIT\"},\"lib/forge-std/src/StdStyle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\nlibrary StdStyle {\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    string constant RED = \\\"\\\\u001b[91m\\\";\\n    string constant GREEN = \\\"\\\\u001b[92m\\\";\\n    string constant YELLOW = \\\"\\\\u001b[93m\\\";\\n    string constant BLUE = \\\"\\\\u001b[94m\\\";\\n    string constant MAGENTA = \\\"\\\\u001b[95m\\\";\\n    string constant CYAN = \\\"\\\\u001b[96m\\\";\\n    string constant BOLD = \\\"\\\\u001b[1m\\\";\\n    string constant DIM = \\\"\\\\u001b[2m\\\";\\n    string constant ITALIC = \\\"\\\\u001b[3m\\\";\\n    string constant UNDERLINE = \\\"\\\\u001b[4m\\\";\\n    string constant INVERSE = \\\"\\\\u001b[7m\\\";\\n    string constant RESET = \\\"\\\\u001b[0m\\\";\\n\\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\\n        return string(abi.encodePacked(style, self, RESET));\\n    }\\n\\n    function red(string memory self) internal pure returns (string memory) {\\n        return styleConcat(RED, self);\\n    }\\n\\n    function red(uint256 self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function red(int256 self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function red(address self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function red(bool self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function redBytes(bytes memory self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function green(string memory self) internal pure returns (string memory) {\\n        return styleConcat(GREEN, self);\\n    }\\n\\n    function green(uint256 self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function green(int256 self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function green(address self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function green(bool self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function yellow(string memory self) internal pure returns (string memory) {\\n        return styleConcat(YELLOW, self);\\n    }\\n\\n    function yellow(uint256 self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellow(int256 self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellow(address self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellow(bool self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function blue(string memory self) internal pure returns (string memory) {\\n        return styleConcat(BLUE, self);\\n    }\\n\\n    function blue(uint256 self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blue(int256 self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blue(address self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blue(bool self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function magenta(string memory self) internal pure returns (string memory) {\\n        return styleConcat(MAGENTA, self);\\n    }\\n\\n    function magenta(uint256 self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magenta(int256 self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magenta(address self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magenta(bool self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function cyan(string memory self) internal pure returns (string memory) {\\n        return styleConcat(CYAN, self);\\n    }\\n\\n    function cyan(uint256 self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyan(int256 self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyan(address self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyan(bool self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function bold(string memory self) internal pure returns (string memory) {\\n        return styleConcat(BOLD, self);\\n    }\\n\\n    function bold(uint256 self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function bold(int256 self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function bold(address self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function bold(bool self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function dim(string memory self) internal pure returns (string memory) {\\n        return styleConcat(DIM, self);\\n    }\\n\\n    function dim(uint256 self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dim(int256 self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dim(address self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dim(bool self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function italic(string memory self) internal pure returns (string memory) {\\n        return styleConcat(ITALIC, self);\\n    }\\n\\n    function italic(uint256 self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italic(int256 self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italic(address self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italic(bool self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function underline(string memory self) internal pure returns (string memory) {\\n        return styleConcat(UNDERLINE, self);\\n    }\\n\\n    function underline(uint256 self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underline(int256 self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underline(address self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underline(bool self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function inverse(string memory self) internal pure returns (string memory) {\\n        return styleConcat(INVERSE, self);\\n    }\\n\\n    function inverse(uint256 self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverse(int256 self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverse(address self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverse(bool self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n}\\n\",\"keccak256\":\"0x43e2a8a9b9c2574dabe74f11adf6f782df218f463540e3b5b563609fe108597d\",\"license\":\"MIT\"},\"lib/forge-std/src/StdUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {IMulticall3} from \\\"./interfaces/IMulticall3.sol\\\";\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\nabstract contract StdUtils {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                     CONSTANTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\\n    uint256 private constant INT256_MIN_ABS =\\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n    uint256 private constant SECP256K1_ORDER =\\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\\n    uint256 private constant UINT256_MAX =\\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                 INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\\n        require(min <= max, \\\"StdUtils bound(uint256,uint256,uint256): Max is less than min.\\\");\\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\\n        if (x >= min && x <= max) return x;\\n\\n        uint256 size = max - min + 1;\\n\\n        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\\n        // This helps ensure coverage of the min/max values.\\n        if (x <= 3 && size > x) return min + x;\\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\\n\\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\\n        if (x > max) {\\n            uint256 diff = x - max;\\n            uint256 rem = diff % size;\\n            if (rem == 0) return max;\\n            result = min + rem - 1;\\n        } else if (x < min) {\\n            uint256 diff = min - x;\\n            uint256 rem = diff % size;\\n            if (rem == 0) return min;\\n            result = max - rem + 1;\\n        }\\n    }\\n\\n    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {\\n        result = _bound(x, min, max);\\n        console2_log(\\\"Bound Result\\\", result);\\n    }\\n\\n    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\\n        require(min <= max, \\\"StdUtils bound(int256,int256,int256): Max is less than min.\\\");\\n\\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\\n        // int256 : -(2**255) ~ (2**255 - 1)\\n        // uint256:     0     ~ (2**256 - 1)\\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\\n        //\\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\\n        // So, use `~uint256(x) + 1` instead.\\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\\n\\n        uint256 y = _bound(_x, _min, _max);\\n\\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\\n    }\\n\\n    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {\\n        result = _bound(x, min, max);\\n        console2_log(\\\"Bound result\\\", vm.toString(result));\\n    }\\n\\n    function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {\\n        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);\\n    }\\n\\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\\n        require(b.length <= 32, \\\"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\\\");\\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\\n    }\\n\\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\\n        // forgefmt: disable-start\\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\\n        // A one byte integer uses its own value as its length prefix, there is no additional \\\"0x80 + length\\\" prefix that comes before it.\\n        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\\n        if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\\n\\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\\n        // forgefmt: disable-end\\n\\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\\n        return addressFromLast20Bytes(\\n            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))\\n        );\\n    }\\n\\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\\n        internal\\n        pure\\n        virtual\\n        returns (address)\\n    {\\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));\\n    }\\n\\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\\n        return computeCreate2Address(salt, initCodeHash, CREATE2_FACTORY);\\n    }\\n\\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\\n        return hashInitCode(creationCode, \\\"\\\");\\n    }\\n\\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\\n    /// @param args the ABI-encoded arguments to the constructor of C\\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(creationCode, args));\\n    }\\n\\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\\n    function getTokenBalances(address token, address[] memory addresses)\\n        internal\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        uint256 tokenCodeSize;\\n        assembly {\\n            tokenCodeSize := extcodesize(token)\\n        }\\n        require(tokenCodeSize > 0, \\\"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\\\");\\n\\n        // ABI encode the aggregate call to Multicall3.\\n        uint256 length = addresses.length;\\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\\n        for (uint256 i = 0; i < length; ++i) {\\n            // 0x70a08231 = bytes4(\\\"balanceOf(address)\\\"))\\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\\n        }\\n\\n        // Make the aggregate call.\\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\\n\\n        // ABI decode the return data and return the balances.\\n        balances = new uint256[](length);\\n        for (uint256 i = 0; i < length; ++i) {\\n            balances[i] = abi.decode(returnData[i], (uint256));\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                 PRIVATE FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\\n        return address(uint160(uint256(bytesValue)));\\n    }\\n\\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\\n\\n    function console2_log(string memory p0, uint256 p1) private view {\\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n        status;\\n    }\\n\\n    function console2_log(string memory p0, string memory p1) private view {\\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n        status;\\n    }\\n}\\n\",\"keccak256\":\"0x8758c42ba9d9e46868b796e2330ac239006ede07bd438a4b36dd6f2c47d27dc1\",\"license\":\"MIT\"},\"lib/forge-std/src/Test.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\n// \\ud83d\\udcac ABOUT\\n// Forge Std's default Test.\\n\\n// \\ud83e\\udde9 MODULES\\nimport {console} from \\\"./console.sol\\\";\\nimport {console2} from \\\"./console2.sol\\\";\\nimport {safeconsole} from \\\"./safeconsole.sol\\\";\\nimport {StdAssertions} from \\\"./StdAssertions.sol\\\";\\nimport {StdChains} from \\\"./StdChains.sol\\\";\\nimport {StdCheats} from \\\"./StdCheats.sol\\\";\\nimport {stdError} from \\\"./StdError.sol\\\";\\nimport {StdInvariant} from \\\"./StdInvariant.sol\\\";\\nimport {stdJson} from \\\"./StdJson.sol\\\";\\nimport {stdMath} from \\\"./StdMath.sol\\\";\\nimport {StdStorage, stdStorage} from \\\"./StdStorage.sol\\\";\\nimport {StdStyle} from \\\"./StdStyle.sol\\\";\\nimport {StdUtils} from \\\"./StdUtils.sol\\\";\\nimport {Vm} from \\\"./Vm.sol\\\";\\n\\n// \\ud83d\\udce6 BOILERPLATE\\nimport {TestBase} from \\\"./Base.sol\\\";\\nimport {DSTest} from \\\"ds-test/test.sol\\\";\\n\\n// \\u2b50\\ufe0f TEST\\nabstract contract Test is TestBase, DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {\\n// Note: IS_TEST() must return true.\\n// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.\\n}\\n\",\"keccak256\":\"0x39b1729d5868c8e94ab8af16751eb500a17fe3870dc627d2b7ddcd5df18d7ad0\",\"license\":\"MIT\"},\"lib/forge-std/src/Vm.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\n// Cheatcodes are marked as view/pure/none using the following rules:\\n// 0. A call's observable behaviour includes its return value, logs, reverts and state writes,\\n// 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),\\n// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,\\n// 3. Otherwise you're `pure`.\\n\\ninterface VmSafe {\\n    enum CallerMode {\\n        None,\\n        Broadcast,\\n        RecurrentBroadcast,\\n        Prank,\\n        RecurrentPrank\\n    }\\n\\n    struct Log {\\n        bytes32[] topics;\\n        bytes data;\\n        address emitter;\\n    }\\n\\n    struct Rpc {\\n        string key;\\n        string url;\\n    }\\n\\n    struct DirEntry {\\n        string errorMessage;\\n        string path;\\n        uint64 depth;\\n        bool isDir;\\n        bool isSymlink;\\n    }\\n\\n    struct FsMetadata {\\n        bool isDir;\\n        bool isSymlink;\\n        uint256 length;\\n        bool readOnly;\\n        uint256 modified;\\n        uint256 accessed;\\n        uint256 created;\\n    }\\n\\n    struct Wallet {\\n        address addr;\\n        uint256 publicKeyX;\\n        uint256 publicKeyY;\\n        uint256 privateKey;\\n    }\\n\\n    struct FfiResult {\\n        int32 exit_code;\\n        bytes stdout;\\n        bytes stderr;\\n    }\\n\\n    // Derives a private key from the name, labels the account with that name, and returns the wallet\\n    function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);\\n    // Generates a wallet from the private key and returns the wallet\\n    function createWallet(uint256 privateKey) external returns (Wallet memory wallet);\\n    // Generates a wallet from the private key, labels the account with that name, and returns the wallet\\n    function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);\\n    // Signs data, (Wallet, digest) => (v, r, s)\\n    function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);\\n    // Get nonce for a Wallet\\n    function getNonce(Wallet calldata wallet) external returns (uint64 nonce);\\n\\n    // Loads a storage slot from an address\\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\\n    // Signs data\\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\\n    // Gets the address for a given private key\\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\\n    // Gets the nonce of an account\\n    function getNonce(address account) external view returns (uint64 nonce);\\n    // Performs a foreign function call via the terminal\\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\\n    // Performs a foreign function call via terminal and returns the exit code, stdout, and stderr\\n    function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);\\n    // Sets environment variables\\n    function setEnv(string calldata name, string calldata value) external;\\n    // Reads environment variables, (name) => (value)\\n    function envBool(string calldata name) external view returns (bool value);\\n    function envUint(string calldata name) external view returns (uint256 value);\\n    function envInt(string calldata name) external view returns (int256 value);\\n    function envAddress(string calldata name) external view returns (address value);\\n    function envBytes32(string calldata name) external view returns (bytes32 value);\\n    function envString(string calldata name) external view returns (string memory value);\\n    function envBytes(string calldata name) external view returns (bytes memory value);\\n    // Reads environment variables as arrays\\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\\n    // Read environment variables with default value\\n    function envOr(string calldata name, bool defaultValue) external returns (bool value);\\n    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);\\n    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);\\n    function envOr(string calldata name, address defaultValue) external returns (address value);\\n    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);\\n    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);\\n    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);\\n    // Read environment variables as arrays with default value\\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\\n        external\\n        returns (bool[] memory value);\\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\\n        external\\n        returns (uint256[] memory value);\\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\\n        external\\n        returns (int256[] memory value);\\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\\n        external\\n        returns (address[] memory value);\\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\\n        external\\n        returns (bytes32[] memory value);\\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\\n        external\\n        returns (string[] memory value);\\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\\n        external\\n        returns (bytes[] memory value);\\n    // Records all storage reads and writes\\n    function record() external;\\n    // Gets all accessed reads and write slot from a recording session, for a given address\\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\\n    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file\\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\\n    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file\\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\\n    // Labels an address in call traces\\n    function label(address account, string calldata newLabel) external;\\n    // Gets the label for the specified address\\n    function getLabel(address account) external returns (string memory currentLabel);\\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\\n    function broadcast() external;\\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\\n    function broadcast(address signer) external;\\n    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain\\n    function broadcast(uint256 privateKey) external;\\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\\n    function startBroadcast() external;\\n    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain\\n    function startBroadcast(address signer) external;\\n    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain\\n    function startBroadcast(uint256 privateKey) external;\\n    // Stops collecting onchain transactions\\n    function stopBroadcast() external;\\n\\n    // Get the path of the current project root.\\n    function projectRoot() external view returns (string memory path);\\n    // Reads the entire content of file to string. `path` is relative to the project root.\\n    function readFile(string calldata path) external view returns (string memory data);\\n    // Reads the entire content of file as binary. `path` is relative to the project root.\\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\\n    // Reads next line of file to string.\\n    function readLine(string calldata path) external view returns (string memory line);\\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\\n    // `path` is relative to the project root.\\n    function writeFile(string calldata path, string calldata data) external;\\n    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\\n    // `path` is relative to the project root.\\n    function writeFileBinary(string calldata path, bytes calldata data) external;\\n    // Writes line to file, creating a file if it does not exist.\\n    // `path` is relative to the project root.\\n    function writeLine(string calldata path, string calldata data) external;\\n    // Copies the contents of one file to another. This function will **overwrite** the contents of `to`.\\n    // On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.\\n    // Both `from` and `to` are relative to the project root.\\n    function copyFile(string calldata from, string calldata to) external returns (uint64 copied);\\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\\n    // `path` is relative to the project root.\\n    function closeFile(string calldata path) external;\\n    // Removes a file from the filesystem.\\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    // - `path` points to a directory.\\n    // - The file doesn't exist.\\n    // - The user lacks permissions to remove the file.\\n    // `path` is relative to the project root.\\n    function removeFile(string calldata path) external;\\n    // Creates a new, empty directory at the provided path.\\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    // - User lacks permissions to modify `path`.\\n    // - A parent of the given path doesn't exist and `recursive` is false.\\n    // - `path` already exists and `recursive` is false.\\n    // `path` is relative to the project root.\\n    function createDir(string calldata path, bool recursive) external;\\n    // Removes a directory at the provided path.\\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    // - `path` doesn't exist.\\n    // - `path` isn't a directory.\\n    // - User lacks permissions to modify `path`.\\n    // - The directory is not empty and `recursive` is false.\\n    // `path` is relative to the project root.\\n    function removeDir(string calldata path, bool recursive) external;\\n    // Reads the directory at the given path recursively, up to `max_depth`.\\n    // `max_depth` defaults to 1, meaning only the direct children of the given directory will be returned.\\n    // Follows symbolic links if `follow_links` is true.\\n    function readDir(string calldata path) external view returns (DirEntry[] memory entries);\\n    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);\\n    function readDir(string calldata path, uint64 maxDepth, bool followLinks)\\n        external\\n        view\\n        returns (DirEntry[] memory entries);\\n    // Reads a symbolic link, returning the path that the link points to.\\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    // - `path` is not a symbolic link.\\n    // - `path` does not exist.\\n    function readLink(string calldata linkPath) external view returns (string memory targetPath);\\n    // Given a path, query the file system to get information about a file, directory, etc.\\n    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);\\n    // Returns true if the given path points to an existing entity, else returns false\\n    function exists(string calldata path) external returns (bool result);\\n    // Returns true if the path exists on disk and is pointing at a regular file, else returns false\\n    function isFile(string calldata path) external returns (bool result);\\n    // Returns true if the path exists on disk and is pointing at a directory, else returns false\\n    function isDir(string calldata path) external returns (bool result);\\n\\n    // Convert values to a string\\n    function toString(address value) external pure returns (string memory stringifiedValue);\\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\\n    function toString(bool value) external pure returns (string memory stringifiedValue);\\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\\n    // Convert values from a string\\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\\n    // Record all the transaction logs\\n    function recordLogs() external;\\n    // Gets all the recorded logs\\n    function getRecordedLogs() external returns (Log[] memory logs);\\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}\\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\\n        external\\n        pure\\n        returns (uint256 privateKey);\\n    // Adds a private key to the local forge wallet and returns the address\\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\\n    //\\n    // parseJson\\n    //\\n    // ----\\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\\n    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that\\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\\n    // as tuples, with the attributes in the order in which they are defined.\\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\\n    // a: uint256\\n    // b: address\\n    // To decode that json, we need to define a struct or a tuple as follows:\\n    // struct json = { uint256 a; address b; }\\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\\n    // decode the tuple in that order, and thus fail.\\n    // ----\\n    // Given a string of JSON, return it as ABI-encoded\\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\\n\\n    // The following parseJson cheatcodes will do type coercion, for the type that they indicate.\\n    // For example, parseJsonUint will coerce all values to a uint256. That includes stringified numbers '12'\\n    // and hex numbers '0xEF'.\\n    // Type coercion works ONLY for discrete values or arrays. That means that the key must return a value or array, not\\n    // a JSON object.\\n    function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);\\n    function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);\\n    function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);\\n    function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);\\n    function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);\\n    function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);\\n    function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);\\n    function parseJsonAddressArray(string calldata json, string calldata key)\\n        external\\n        pure\\n        returns (address[] memory);\\n    function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);\\n    function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);\\n    function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);\\n    function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);\\n    function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);\\n    function parseJsonBytes32Array(string calldata json, string calldata key)\\n        external\\n        pure\\n        returns (bytes32[] memory);\\n\\n    // Checks if a key exists in a JSON or TOML object.\\n    function keyExists(string calldata json, string calldata key) external view returns (bool);\\n\\n    // Returns array of keys for a JSON object\\n    function parseJsonKeys(string calldata json, string calldata key) external returns (string[] memory keys);\\n\\n    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file\\n    // It returns the stringified version of the specific JSON file up to that moment.\\n    function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);\\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\\n        external\\n        returns (string memory json);\\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\\n        external\\n        returns (string memory json);\\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\\n        external\\n        returns (string memory json);\\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\\n        external\\n        returns (string memory json);\\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\\n        external\\n        returns (string memory json);\\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\\n        external\\n        returns (string memory json);\\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\\n        external\\n        returns (string memory json);\\n\\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\\n        external\\n        returns (string memory json);\\n\\n    //\\n    // writeJson\\n    //\\n    // ----\\n    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.\\n    // Let's assume we want to write the following JSON to a file:\\n    //\\n    // { \\\"boolean\\\": true, \\\"number\\\": 342, \\\"object\\\": { \\\"title\\\": \\\"finally json serialization\\\" } }\\n    //\\n    // ```\\n    //  string memory json1 = \\\"some key\\\";\\n    //  vm.serializeBool(json1, \\\"boolean\\\", true);\\n    //  vm.serializeBool(json1, \\\"number\\\", uint256(342));\\n    //  json2 = \\\"some other key\\\";\\n    //  string memory output = vm.serializeString(json2, \\\"title\\\", \\\"finally json serialization\\\");\\n    //  string memory finalJson = vm.serialize(json1, \\\"object\\\", output);\\n    //  vm.writeJson(finalJson, \\\"./output/example.json\\\");\\n    // ```\\n    // The critical insight is that every invocation of serialization will return the stringified version of the JSON\\n    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version\\n    // to serialize them as values to another JSON object.\\n    //\\n    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)\\n    // will find the object in-memory that is keyed by \\\"some key\\\".\\n    function writeJson(string calldata json, string calldata path) external;\\n    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>\\n    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing\\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\\n    // Returns the RPC url for the given alias\\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\\n    // Returns all rpc urls and their aliases `[alias, url][]`\\n    function rpcUrls() external view returns (string[2][] memory urls);\\n    // Returns all rpc urls and their aliases as structs.\\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\\n    // If the condition is false, discard this run's fuzz inputs and generate new ones.\\n    function assume(bool condition) external pure;\\n    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\\n    function pauseGasMetering() external;\\n    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\\n    function resumeGasMetering() external;\\n    // Starts recording all map SSTOREs for later retrieval.\\n    function startMappingRecording() external;\\n    // Stops recording all map SSTOREs for later retrieval and clears the recorded data.\\n    function stopMappingRecording() external;\\n    // Gets the number of elements in the mapping at the given slot, for a given address.\\n    function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);\\n    // Gets the elements at index idx of the mapping at the given slot, for a given address. The\\n    // index must be less than the length of the mapping (i.e. the number of keys in the mapping).\\n    function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);\\n    // Gets the map key and parent of a mapping at a given slot, for a given address.\\n    function getMappingKeyAndParentOf(address target, bytes32 elementSlot)\\n        external\\n        returns (bool found, bytes32 key, bytes32 parent);\\n    // Writes a breakpoint to jump to in the debugger\\n    function breakpoint(string calldata char) external;\\n    // Writes a conditional breakpoint to jump to in the debugger\\n    function breakpoint(string calldata char, bool value) external;\\n    // Suspends execution of the main thread for `duration` milliseconds\\n    function sleep(uint256 duration) external;\\n}\\n\\ninterface Vm is VmSafe {\\n    // Sets block.timestamp\\n    function warp(uint256 newTimestamp) external;\\n    // Sets block.height\\n    function roll(uint256 newHeight) external;\\n    // Sets block.basefee\\n    function fee(uint256 newBasefee) external;\\n    // Sets block.difficulty\\n    // Not available on EVM versions from Paris onwards. Use `prevrandao` instead.\\n    // If used on unsupported EVM versions it will revert.\\n    function difficulty(uint256 newDifficulty) external;\\n    // Sets block.prevrandao\\n    // Not available on EVM versions before Paris. Use `difficulty` instead.\\n    // If used on unsupported EVM versions it will revert.\\n    function prevrandao(bytes32 newPrevrandao) external;\\n    // Sets block.chainid\\n    function chainId(uint256 newChainId) external;\\n    // Sets tx.gasprice\\n    function txGasPrice(uint256 newGasPrice) external;\\n    // Stores a value to an address' storage slot.\\n    function store(address target, bytes32 slot, bytes32 value) external;\\n    // Sets the nonce of an account; must be higher than the current nonce of the account\\n    function setNonce(address account, uint64 newNonce) external;\\n    // Sets the nonce of an account to an arbitrary value\\n    function setNonceUnsafe(address account, uint64 newNonce) external;\\n    // Resets the nonce of an account to 0 for EOAs and 1 for contract accounts\\n    function resetNonce(address account) external;\\n    // Sets the *next* call's msg.sender to be the input address\\n    function prank(address msgSender) external;\\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\\n    function startPrank(address msgSender) external;\\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\\n    function prank(address msgSender, address txOrigin) external;\\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\\n    function startPrank(address msgSender, address txOrigin) external;\\n    // Resets subsequent calls' msg.sender to be `address(this)`\\n    function stopPrank() external;\\n    // Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification\\n    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);\\n    // Sets an address' balance\\n    function deal(address account, uint256 newBalance) external;\\n    // Sets an address' code\\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\\n    // Marks a test as skipped. Must be called at the top of the test.\\n    function skip(bool skipTest) external;\\n    // Expects an error on next call\\n    function expectRevert(bytes calldata revertData) external;\\n    function expectRevert(bytes4 revertData) external;\\n    function expectRevert() external;\\n\\n    // Prepare an expected log with all four checks enabled.\\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\\n    // logs were emitted in the expected order with the expected topics and data.\\n    // Second form also checks supplied address against emitting contract.\\n    function expectEmit() external;\\n    function expectEmit(address emitter) external;\\n\\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\\n    // Second form also checks supplied address against emitting contract.\\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\\n        external;\\n\\n    // Mocks a call to an address, returning specified data.\\n    // Calldata can either be strict or a partial match, e.g. if you only\\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\\n    // function will be mocked.\\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\\n    // Mocks a call to an address with a specific msg.value, returning specified data.\\n    // Calldata match takes precedence over msg.value in case of ambiguity.\\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\\n    // Reverts a call to an address with specified revert data.\\n    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;\\n    // Reverts a call to an address with a specific msg.value, with specified revert data.\\n    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)\\n        external;\\n    // Clears all mocked calls\\n    function clearMockedCalls() external;\\n    // Expects a call to an address with the specified calldata.\\n    // Calldata can either be a strict or a partial match\\n    function expectCall(address callee, bytes calldata data) external;\\n    // Expects given number of calls to an address with the specified calldata.\\n    function expectCall(address callee, bytes calldata data, uint64 count) external;\\n    // Expects a call to an address with the specified msg.value and calldata\\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\\n    // Expects given number of calls to an address with the specified msg.value and calldata\\n    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;\\n    // Expect a call to an address with the specified msg.value, gas, and calldata.\\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\\n    // Expects given number of calls to an address with the specified msg.value, gas, and calldata.\\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;\\n    // Expect a call to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\\n    // Expect given number of calls to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)\\n        external;\\n    // Only allows memory writes to offsets [0x00, 0x60) \\u222a [min, max) in the current subcontext. If any other\\n    // memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\\n    function expectSafeMemory(uint64 min, uint64 max) external;\\n    // Only allows memory writes to offsets [0x00, 0x60) \\u222a [min, max) in the next created subcontext.\\n    // If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\\n    // to the set.\\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\\n    // Sets block.coinbase\\n    function coinbase(address newCoinbase) external;\\n    // Snapshot the current state of the evm.\\n    // Returns the id of the snapshot that was created.\\n    // To revert a snapshot use `revertTo`\\n    function snapshot() external returns (uint256 snapshotId);\\n    // Revert the state of the EVM to a previous snapshot\\n    // Takes the snapshot id to revert to.\\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\\n    function revertTo(uint256 snapshotId) external returns (bool success);\\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\\n    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,\\n    // and returns the identifier of the fork\\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\\n    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before\\n    // the transaction, returns the identifier of the fork\\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\\n    function selectFork(uint256 forkId) external;\\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\\n    function activeFork() external view returns (uint256 forkId);\\n    // Updates the currently active fork to given block number\\n    // This is similar to `roll` but for the currently active fork\\n    function rollFork(uint256 blockNumber) external;\\n    // Updates the currently active fork to given transaction\\n    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block\\n    function rollFork(bytes32 txHash) external;\\n    // Updates the given fork to given block number\\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\\n    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block\\n    function rollFork(uint256 forkId, bytes32 txHash) external;\\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\\n    // Meaning, changes made to the state of this account will be kept when switching forks\\n    function makePersistent(address account) external;\\n    function makePersistent(address account0, address account1) external;\\n    function makePersistent(address account0, address account1, address account2) external;\\n    function makePersistent(address[] calldata accounts) external;\\n    // Revokes persistent status from the address, previously added via `makePersistent`\\n    function revokePersistent(address account) external;\\n    function revokePersistent(address[] calldata accounts) external;\\n    // Returns true if the account is marked as persistent\\n    function isPersistent(address account) external view returns (bool persistent);\\n    // In forking mode, explicitly grant the given address cheatcode access\\n    function allowCheatcodes(address account) external;\\n    // Fetches the given transaction from the active fork and executes it on the current state\\n    function transact(bytes32 txHash) external;\\n    // Fetches the given transaction from the given fork and executes it on the current state\\n    function transact(uint256 forkId, bytes32 txHash) external;\\n}\\n\",\"keccak256\":\"0x64827f48bafb014a69560bc980355f5c3351e4235ee43338c0f8a43a01cdff62\",\"license\":\"MIT\"},\"lib/forge-std/src/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n    }\\n\\n    function logUint(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\",\"keccak256\":\"0x91d5413c2434ca58fd278b6e1e79fd98d10c83931cc2596a6038eee4daeb34ba\",\"license\":\"MIT\"},\"lib/forge-std/src/console2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\\nlibrary console2 {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _castLogPayloadViewToPure(\\n        function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) internal pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\\n    }\\n\\n    function _sendLogPayloadView(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, int256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,int256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\",\"keccak256\":\"0x954646445d1014c3cd85c7918f5e7adeeca5ee44b68c00bafa237e597a4e35ea\",\"license\":\"MIT\"},\"lib/forge-std/src/interfaces/IMulticall3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\ninterface IMulticall3 {\\n    struct Call {\\n        address target;\\n        bytes callData;\\n    }\\n\\n    struct Call3 {\\n        address target;\\n        bool allowFailure;\\n        bytes callData;\\n    }\\n\\n    struct Call3Value {\\n        address target;\\n        bool allowFailure;\\n        uint256 value;\\n        bytes callData;\\n    }\\n\\n    struct Result {\\n        bool success;\\n        bytes returnData;\\n    }\\n\\n    function aggregate(Call[] calldata calls)\\n        external\\n        payable\\n        returns (uint256 blockNumber, bytes[] memory returnData);\\n\\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\\n\\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\\n\\n    function blockAndAggregate(Call[] calldata calls)\\n        external\\n        payable\\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\\n\\n    function getBasefee() external view returns (uint256 basefee);\\n\\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\\n\\n    function getBlockNumber() external view returns (uint256 blockNumber);\\n\\n    function getChainId() external view returns (uint256 chainid);\\n\\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\\n\\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\\n\\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\\n\\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\\n\\n    function getEthBalance(address addr) external view returns (uint256 balance);\\n\\n    function getLastBlockHash() external view returns (bytes32 blockHash);\\n\\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\\n        external\\n        payable\\n        returns (Result[] memory returnData);\\n\\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\\n        external\\n        payable\\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\\n}\\n\",\"keccak256\":\"0x7aac1389150499a922d1f9ef5749c908cef127cb2075b92fa17e9cb611263d0a\",\"license\":\"MIT\"},\"lib/forge-std/src/safeconsole.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\n/// @author philogy <https://github.com/philogy>\\n/// @dev Code generated automatically by script.\\nlibrary safeconsole {\\n    uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;\\n\\n    // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)\\n    // for the view-to-pure log trick.\\n    function _sendLogPayload(uint256 offset, uint256 size) private pure {\\n        function(uint256, uint256) internal view fnIn = _sendLogPayloadView;\\n        function(uint256, uint256) internal pure pureSendLogPayload;\\n        assembly {\\n            pureSendLogPayload := fnIn\\n        }\\n        pureSendLogPayload(offset, size);\\n    }\\n\\n    function _sendLogPayloadView(uint256 offset, uint256 size) private view {\\n        assembly {\\n            pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))\\n        }\\n    }\\n\\n    function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {\\n        function(uint256, uint256, uint256) internal view fnIn = _memcopyView;\\n        function(uint256, uint256, uint256) internal pure pureMemcopy;\\n        assembly {\\n            pureMemcopy := fnIn\\n        }\\n        pureMemcopy(fromOffset, toOffset, length);\\n    }\\n\\n    function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {\\n        assembly {\\n            pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))\\n        }\\n    }\\n\\n    function logMemory(uint256 offset, uint256 length) internal pure {\\n        if (offset >= 0x60) {\\n            // Sufficient memory before slice to prepare call header.\\n            bytes32 m0;\\n            bytes32 m1;\\n            bytes32 m2;\\n            assembly {\\n                m0 := mload(sub(offset, 0x60))\\n                m1 := mload(sub(offset, 0x40))\\n                m2 := mload(sub(offset, 0x20))\\n                // Selector of `logBytes(bytes)`.\\n                mstore(sub(offset, 0x60), 0xe17bf956)\\n                mstore(sub(offset, 0x40), 0x20)\\n                mstore(sub(offset, 0x20), length)\\n            }\\n            _sendLogPayload(offset - 0x44, length + 0x44);\\n            assembly {\\n                mstore(sub(offset, 0x60), m0)\\n                mstore(sub(offset, 0x40), m1)\\n                mstore(sub(offset, 0x20), m2)\\n            }\\n        } else {\\n            // Insufficient space, so copy slice forward, add header and reverse.\\n            bytes32 m0;\\n            bytes32 m1;\\n            bytes32 m2;\\n            uint256 endOffset = offset + length;\\n            assembly {\\n                m0 := mload(add(endOffset, 0x00))\\n                m1 := mload(add(endOffset, 0x20))\\n                m2 := mload(add(endOffset, 0x40))\\n            }\\n            _memcopy(offset, offset + 0x60, length);\\n            assembly {\\n                // Selector of `logBytes(bytes)`.\\n                mstore(add(offset, 0x00), 0xe17bf956)\\n                mstore(add(offset, 0x20), 0x20)\\n                mstore(add(offset, 0x40), length)\\n            }\\n            _sendLogPayload(offset + 0x1c, length + 0x44);\\n            _memcopy(offset + 0x60, offset, length);\\n            assembly {\\n                mstore(add(endOffset, 0x00), m0)\\n                mstore(add(endOffset, 0x20), m1)\\n                mstore(add(endOffset, 0x40), m2)\\n            }\\n        }\\n    }\\n\\n    function log(address p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            // Selector of `log(address)`.\\n            mstore(0x00, 0x2c2ecbc2)\\n            mstore(0x20, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x24);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n        }\\n    }\\n\\n    function log(bool p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            // Selector of `log(bool)`.\\n            mstore(0x00, 0x32458eed)\\n            mstore(0x20, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x24);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n        }\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            // Selector of `log(uint256)`.\\n            mstore(0x00, 0xf82c50f1)\\n            mstore(0x20, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x24);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n        }\\n    }\\n\\n    function log(bytes32 p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(string)`.\\n            mstore(0x00, 0x41304fac)\\n            mstore(0x20, 0x20)\\n            writeString(0x40, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(address,address)`.\\n            mstore(0x00, 0xdaf0d4aa)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(address,bool)`.\\n            mstore(0x00, 0x75b605d3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(address,uint256)`.\\n            mstore(0x00, 0x8309e8a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,string)`.\\n            mstore(0x00, 0x759f86bb)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x40)\\n            writeString(0x60, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(bool,address)`.\\n            mstore(0x00, 0x853c4849)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(bool,bool)`.\\n            mstore(0x00, 0x2a110e83)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(bool,uint256)`.\\n            mstore(0x00, 0x399174d3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,string)`.\\n            mstore(0x00, 0x8feac525)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x40)\\n            writeString(0x60, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(uint256,address)`.\\n            mstore(0x00, 0x69276c86)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(uint256,bool)`.\\n            mstore(0x00, 0x1c9d7eb3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(uint256,uint256)`.\\n            mstore(0x00, 0xf666715a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,string)`.\\n            mstore(0x00, 0x643fd0df)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x40)\\n            writeString(0x60, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(string,address)`.\\n            mstore(0x00, 0x319af333)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, p1)\\n            writeString(0x60, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(string,bool)`.\\n            mstore(0x00, 0xc3b55635)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, p1)\\n            writeString(0x60, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(string,uint256)`.\\n            mstore(0x00, 0xb60e72cc)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, p1)\\n            writeString(0x60, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,string)`.\\n            mstore(0x00, 0x4b5c4277)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, 0x80)\\n            writeString(0x60, p0)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,address,address)`.\\n            mstore(0x00, 0x018c84c2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,address,bool)`.\\n            mstore(0x00, 0xf2a66286)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,address,uint256)`.\\n            mstore(0x00, 0x17fe6185)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,address,string)`.\\n            mstore(0x00, 0x007150be)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,bool,address)`.\\n            mstore(0x00, 0xf11699ed)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,bool,bool)`.\\n            mstore(0x00, 0xeb830c92)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,bool,uint256)`.\\n            mstore(0x00, 0x9c4f99fb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,bool,string)`.\\n            mstore(0x00, 0x212255cc)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,uint256,address)`.\\n            mstore(0x00, 0x7bc0d848)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,uint256,bool)`.\\n            mstore(0x00, 0x678209a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,uint256,uint256)`.\\n            mstore(0x00, 0xb69bcaf6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,uint256,string)`.\\n            mstore(0x00, 0xa1f2e8aa)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,string,address)`.\\n            mstore(0x00, 0xf08744e8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,string,bool)`.\\n            mstore(0x00, 0xcf020fb1)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,string,uint256)`.\\n            mstore(0x00, 0x67dd6ff1)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(address,string,string)`.\\n            mstore(0x00, 0xfb772265)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p1)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,address,address)`.\\n            mstore(0x00, 0xd2763667)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,address,bool)`.\\n            mstore(0x00, 0x18c9c746)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,address,uint256)`.\\n            mstore(0x00, 0x5f7b9afb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,address,string)`.\\n            mstore(0x00, 0xde9a9270)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,bool,address)`.\\n            mstore(0x00, 0x1078f68d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,bool,bool)`.\\n            mstore(0x00, 0x50709698)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,bool,uint256)`.\\n            mstore(0x00, 0x12f21602)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,bool,string)`.\\n            mstore(0x00, 0x2555fa46)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,uint256,address)`.\\n            mstore(0x00, 0x088ef9d2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,uint256,bool)`.\\n            mstore(0x00, 0xe8defba9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,uint256,uint256)`.\\n            mstore(0x00, 0x37103367)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,uint256,string)`.\\n            mstore(0x00, 0xc3fc3970)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,string,address)`.\\n            mstore(0x00, 0x9591b953)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,string,bool)`.\\n            mstore(0x00, 0xdbb4c247)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,string,uint256)`.\\n            mstore(0x00, 0x1093ee11)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(bool,string,string)`.\\n            mstore(0x00, 0xb076847f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p1)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,address,address)`.\\n            mstore(0x00, 0xbcfd9be0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,address,bool)`.\\n            mstore(0x00, 0x9b6ec042)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,address,uint256)`.\\n            mstore(0x00, 0x5a9b5ed5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,address,string)`.\\n            mstore(0x00, 0x63cb41f9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,bool,address)`.\\n            mstore(0x00, 0x35085f7b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,bool,bool)`.\\n            mstore(0x00, 0x20718650)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,bool,uint256)`.\\n            mstore(0x00, 0x20098014)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,bool,string)`.\\n            mstore(0x00, 0x85775021)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,uint256,address)`.\\n            mstore(0x00, 0x5c96b331)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,uint256,bool)`.\\n            mstore(0x00, 0x4766da72)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,uint256,uint256)`.\\n            mstore(0x00, 0xd1ed7a3c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,uint256,string)`.\\n            mstore(0x00, 0x71d04af2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,string,address)`.\\n            mstore(0x00, 0x7afac959)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,string,bool)`.\\n            mstore(0x00, 0x4ceda75a)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,string,uint256)`.\\n            mstore(0x00, 0x37aa7d4c)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(uint256,string,string)`.\\n            mstore(0x00, 0xb115611f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p1)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,address,address)`.\\n            mstore(0x00, 0xfcec75e0)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,address,bool)`.\\n            mstore(0x00, 0xc91d5ed4)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,address,uint256)`.\\n            mstore(0x00, 0x0d26b925)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,address,string)`.\\n            mstore(0x00, 0xe0e9ad4f)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,bool,address)`.\\n            mstore(0x00, 0x932bbb38)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,bool,bool)`.\\n            mstore(0x00, 0x850b7ad6)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,bool,uint256)`.\\n            mstore(0x00, 0xc95958d6)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,bool,string)`.\\n            mstore(0x00, 0xe298f47d)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,uint256,address)`.\\n            mstore(0x00, 0x1c7ec448)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,uint256,bool)`.\\n            mstore(0x00, 0xca7733b1)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,uint256,uint256)`.\\n            mstore(0x00, 0xca47c4eb)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,uint256,string)`.\\n            mstore(0x00, 0x5970e089)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,string,address)`.\\n            mstore(0x00, 0x95ed0195)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,string,bool)`.\\n            mstore(0x00, 0xb0e0f9b5)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,string,uint256)`.\\n            mstore(0x00, 0x5821efa1)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            // Selector of `log(string,string,string)`.\\n            mstore(0x00, 0x2ced7cef)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, 0xe0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n            writeString(0x100, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x124);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,address,address)`.\\n            mstore(0x00, 0x665bf134)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,address,bool)`.\\n            mstore(0x00, 0x0e378994)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,address,uint256)`.\\n            mstore(0x00, 0x94250d77)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,address,string)`.\\n            mstore(0x00, 0xf808da20)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,bool,address)`.\\n            mstore(0x00, 0x9f1bc36e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,bool,bool)`.\\n            mstore(0x00, 0x2cd4134a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,bool,uint256)`.\\n            mstore(0x00, 0x3971e78c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,bool,string)`.\\n            mstore(0x00, 0xaa6540c8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,uint256,address)`.\\n            mstore(0x00, 0x8da6def5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,uint256,bool)`.\\n            mstore(0x00, 0x9b4254e2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,uint256,uint256)`.\\n            mstore(0x00, 0xbe553481)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,uint256,string)`.\\n            mstore(0x00, 0xfdb4f990)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,string,address)`.\\n            mstore(0x00, 0x8f736d16)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,string,bool)`.\\n            mstore(0x00, 0x6f1a594e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,string,uint256)`.\\n            mstore(0x00, 0xef1cefe7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,address,string,string)`.\\n            mstore(0x00, 0x21bdaf25)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,address,address)`.\\n            mstore(0x00, 0x660375dd)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,address,bool)`.\\n            mstore(0x00, 0xa6f50b0f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,address,uint256)`.\\n            mstore(0x00, 0xa75c59de)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,address,string)`.\\n            mstore(0x00, 0x2dd778e6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,bool,address)`.\\n            mstore(0x00, 0xcf394485)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,bool,bool)`.\\n            mstore(0x00, 0xcac43479)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,bool,uint256)`.\\n            mstore(0x00, 0x8c4e5de6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,bool,string)`.\\n            mstore(0x00, 0xdfc4a2e8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,uint256,address)`.\\n            mstore(0x00, 0xccf790a1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,uint256,bool)`.\\n            mstore(0x00, 0xc4643e20)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,uint256,uint256)`.\\n            mstore(0x00, 0x386ff5f4)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,uint256,string)`.\\n            mstore(0x00, 0x0aa6cfad)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,string,address)`.\\n            mstore(0x00, 0x19fd4956)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,string,bool)`.\\n            mstore(0x00, 0x50ad461d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,string,uint256)`.\\n            mstore(0x00, 0x80e6a20b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,bool,string,string)`.\\n            mstore(0x00, 0x475c5c33)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,address,address)`.\\n            mstore(0x00, 0x478d1c62)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,address,bool)`.\\n            mstore(0x00, 0xa1bcc9b3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,address,uint256)`.\\n            mstore(0x00, 0x100f650e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,address,string)`.\\n            mstore(0x00, 0x1da986ea)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,bool,address)`.\\n            mstore(0x00, 0xa31bfdcc)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,bool,bool)`.\\n            mstore(0x00, 0x3bf5e537)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,bool,uint256)`.\\n            mstore(0x00, 0x22f6b999)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,bool,string)`.\\n            mstore(0x00, 0xc5ad85f9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,uint256,address)`.\\n            mstore(0x00, 0x20e3984d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,uint256,bool)`.\\n            mstore(0x00, 0x66f1bc67)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,uint256,uint256)`.\\n            mstore(0x00, 0x34f0e636)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,uint256,string)`.\\n            mstore(0x00, 0x4a28c017)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,string,address)`.\\n            mstore(0x00, 0x5c430d47)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,string,bool)`.\\n            mstore(0x00, 0xcf18105c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,string,uint256)`.\\n            mstore(0x00, 0xbf01f891)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,uint256,string,string)`.\\n            mstore(0x00, 0x88a8c406)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,address,address)`.\\n            mstore(0x00, 0x0d36fa20)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,address,bool)`.\\n            mstore(0x00, 0x0df12b76)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,address,uint256)`.\\n            mstore(0x00, 0x457fe3cf)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,address,string)`.\\n            mstore(0x00, 0xf7e36245)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,bool,address)`.\\n            mstore(0x00, 0x205871c2)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,bool,bool)`.\\n            mstore(0x00, 0x5f1d5c9f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,bool,uint256)`.\\n            mstore(0x00, 0x515e38b6)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,bool,string)`.\\n            mstore(0x00, 0xbc0b61fe)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,uint256,address)`.\\n            mstore(0x00, 0x63183678)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,uint256,bool)`.\\n            mstore(0x00, 0x0ef7e050)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,uint256,uint256)`.\\n            mstore(0x00, 0x1dc8e1b8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,uint256,string)`.\\n            mstore(0x00, 0x448830a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,string,address)`.\\n            mstore(0x00, 0xa04e2f87)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,string,bool)`.\\n            mstore(0x00, 0x35a5071f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,string,uint256)`.\\n            mstore(0x00, 0x159f8927)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(address,string,string,string)`.\\n            mstore(0x00, 0x5d02c50b)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,address,address)`.\\n            mstore(0x00, 0x1d14d001)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,address,bool)`.\\n            mstore(0x00, 0x46600be0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,address,uint256)`.\\n            mstore(0x00, 0x0c66d1be)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,address,string)`.\\n            mstore(0x00, 0xd812a167)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,bool,address)`.\\n            mstore(0x00, 0x1c41a336)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,bool,bool)`.\\n            mstore(0x00, 0x6a9c478b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,bool,uint256)`.\\n            mstore(0x00, 0x07831502)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,bool,string)`.\\n            mstore(0x00, 0x4a66cb34)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,uint256,address)`.\\n            mstore(0x00, 0x136b05dd)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,uint256,bool)`.\\n            mstore(0x00, 0xd6019f1c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,uint256,uint256)`.\\n            mstore(0x00, 0x7bf181a1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,uint256,string)`.\\n            mstore(0x00, 0x51f09ff8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,string,address)`.\\n            mstore(0x00, 0x6f7c603e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,string,bool)`.\\n            mstore(0x00, 0xe2bfd60b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,string,uint256)`.\\n            mstore(0x00, 0xc21f64c7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,address,string,string)`.\\n            mstore(0x00, 0xa73c1db6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,address,address)`.\\n            mstore(0x00, 0xf4880ea4)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,address,bool)`.\\n            mstore(0x00, 0xc0a302d8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,address,uint256)`.\\n            mstore(0x00, 0x4c123d57)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,address,string)`.\\n            mstore(0x00, 0xa0a47963)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,bool,address)`.\\n            mstore(0x00, 0x8c329b1a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,bool,bool)`.\\n            mstore(0x00, 0x3b2a5ce0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,bool,uint256)`.\\n            mstore(0x00, 0x6d7045c1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,bool,string)`.\\n            mstore(0x00, 0x2ae408d4)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,uint256,address)`.\\n            mstore(0x00, 0x54a7a9a0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,uint256,bool)`.\\n            mstore(0x00, 0x619e4d0e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,uint256,uint256)`.\\n            mstore(0x00, 0x0bb00eab)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,uint256,string)`.\\n            mstore(0x00, 0x7dd4d0e0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,string,address)`.\\n            mstore(0x00, 0xf9ad2b89)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,string,bool)`.\\n            mstore(0x00, 0xb857163a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,string,uint256)`.\\n            mstore(0x00, 0xe3a9ca2f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,bool,string,string)`.\\n            mstore(0x00, 0x6d1e8751)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,address,address)`.\\n            mstore(0x00, 0x26f560a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,address,bool)`.\\n            mstore(0x00, 0xb4c314ff)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,address,uint256)`.\\n            mstore(0x00, 0x1537dc87)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,address,string)`.\\n            mstore(0x00, 0x1bb3b09a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,bool,address)`.\\n            mstore(0x00, 0x9acd3616)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,bool,bool)`.\\n            mstore(0x00, 0xceb5f4d7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,bool,uint256)`.\\n            mstore(0x00, 0x7f9bbca2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,bool,string)`.\\n            mstore(0x00, 0x9143dbb1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,uint256,address)`.\\n            mstore(0x00, 0x00dd87b9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,uint256,bool)`.\\n            mstore(0x00, 0xbe984353)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,uint256,uint256)`.\\n            mstore(0x00, 0x374bb4b2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,uint256,string)`.\\n            mstore(0x00, 0x8e69fb5d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,string,address)`.\\n            mstore(0x00, 0xfedd1fff)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,string,bool)`.\\n            mstore(0x00, 0xe5e70b2b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,string,uint256)`.\\n            mstore(0x00, 0x6a1199e2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,uint256,string,string)`.\\n            mstore(0x00, 0xf5bc2249)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,address,address)`.\\n            mstore(0x00, 0x2b2b18dc)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,address,bool)`.\\n            mstore(0x00, 0x6dd434ca)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,address,uint256)`.\\n            mstore(0x00, 0xa5cada94)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,address,string)`.\\n            mstore(0x00, 0x12d6c788)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,bool,address)`.\\n            mstore(0x00, 0x538e06ab)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,bool,bool)`.\\n            mstore(0x00, 0xdc5e935b)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,bool,uint256)`.\\n            mstore(0x00, 0x1606a393)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,bool,string)`.\\n            mstore(0x00, 0x483d0416)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,uint256,address)`.\\n            mstore(0x00, 0x1596a1ce)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,uint256,bool)`.\\n            mstore(0x00, 0x6b0e5d53)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,uint256,uint256)`.\\n            mstore(0x00, 0x28863fcb)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,uint256,string)`.\\n            mstore(0x00, 0x1ad96de6)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,string,address)`.\\n            mstore(0x00, 0x97d394d8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,string,bool)`.\\n            mstore(0x00, 0x1e4b87e5)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,string,uint256)`.\\n            mstore(0x00, 0x7be0c3eb)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(bool,string,string,string)`.\\n            mstore(0x00, 0x1762e32a)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,address,address)`.\\n            mstore(0x00, 0x2488b414)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,address,bool)`.\\n            mstore(0x00, 0x091ffaf5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,address,uint256)`.\\n            mstore(0x00, 0x736efbb6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,address,string)`.\\n            mstore(0x00, 0x031c6f73)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,bool,address)`.\\n            mstore(0x00, 0xef72c513)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,bool,bool)`.\\n            mstore(0x00, 0xe351140f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,bool,uint256)`.\\n            mstore(0x00, 0x5abd992a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,bool,string)`.\\n            mstore(0x00, 0x90fb06aa)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,uint256,address)`.\\n            mstore(0x00, 0x15c127b5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,uint256,bool)`.\\n            mstore(0x00, 0x5f743a7c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,uint256,uint256)`.\\n            mstore(0x00, 0x0c9cd9c1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,uint256,string)`.\\n            mstore(0x00, 0xddb06521)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,string,address)`.\\n            mstore(0x00, 0x9cba8fff)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,string,bool)`.\\n            mstore(0x00, 0xcc32ab07)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,string,uint256)`.\\n            mstore(0x00, 0x46826b5d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,address,string,string)`.\\n            mstore(0x00, 0x3e128ca3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,address,address)`.\\n            mstore(0x00, 0xa1ef4cbb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,address,bool)`.\\n            mstore(0x00, 0x454d54a5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,address,uint256)`.\\n            mstore(0x00, 0x078287f5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,address,string)`.\\n            mstore(0x00, 0xade052c7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,bool,address)`.\\n            mstore(0x00, 0x69640b59)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,bool,bool)`.\\n            mstore(0x00, 0xb6f577a1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,bool,uint256)`.\\n            mstore(0x00, 0x7464ce23)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,bool,string)`.\\n            mstore(0x00, 0xdddb9561)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,uint256,address)`.\\n            mstore(0x00, 0x88cb6041)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,uint256,bool)`.\\n            mstore(0x00, 0x91a02e2a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,uint256,uint256)`.\\n            mstore(0x00, 0xc6acc7a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,uint256,string)`.\\n            mstore(0x00, 0xde03e774)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,string,address)`.\\n            mstore(0x00, 0xef529018)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,string,bool)`.\\n            mstore(0x00, 0xeb928d7f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,string,uint256)`.\\n            mstore(0x00, 0x2c1d0746)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,bool,string,string)`.\\n            mstore(0x00, 0x68c8b8bd)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,address,address)`.\\n            mstore(0x00, 0x56a5d1b1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,address,bool)`.\\n            mstore(0x00, 0x15cac476)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,address,uint256)`.\\n            mstore(0x00, 0x88f6e4b2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,address,string)`.\\n            mstore(0x00, 0x6cde40b8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,bool,address)`.\\n            mstore(0x00, 0x9a816a83)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,bool,bool)`.\\n            mstore(0x00, 0xab085ae6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,bool,uint256)`.\\n            mstore(0x00, 0xeb7f6fd2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,bool,string)`.\\n            mstore(0x00, 0xa5b4fc99)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,uint256,address)`.\\n            mstore(0x00, 0xfa8185af)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,uint256,bool)`.\\n            mstore(0x00, 0xc598d185)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,uint256,uint256)`.\\n            mstore(0x00, 0x193fb800)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,uint256,string)`.\\n            mstore(0x00, 0x59cfcbe3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,string,address)`.\\n            mstore(0x00, 0x42d21db7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,string,bool)`.\\n            mstore(0x00, 0x7af6ab25)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,string,uint256)`.\\n            mstore(0x00, 0x5da297eb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,uint256,string,string)`.\\n            mstore(0x00, 0x27d8afd2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,address,address)`.\\n            mstore(0x00, 0x6168ed61)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,address,bool)`.\\n            mstore(0x00, 0x90c30a56)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,address,uint256)`.\\n            mstore(0x00, 0xe8d3018d)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,address,string)`.\\n            mstore(0x00, 0x9c3adfa1)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,bool,address)`.\\n            mstore(0x00, 0xae2ec581)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,bool,bool)`.\\n            mstore(0x00, 0xba535d9c)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,bool,uint256)`.\\n            mstore(0x00, 0xcf009880)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,bool,string)`.\\n            mstore(0x00, 0xd2d423cd)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,uint256,address)`.\\n            mstore(0x00, 0x3b2279b4)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,uint256,bool)`.\\n            mstore(0x00, 0x691a8f74)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,uint256,uint256)`.\\n            mstore(0x00, 0x82c25b74)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,uint256,string)`.\\n            mstore(0x00, 0xb7b914ca)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,string,address)`.\\n            mstore(0x00, 0xd583c602)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,string,bool)`.\\n            mstore(0x00, 0xb3a6b6bd)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,string,uint256)`.\\n            mstore(0x00, 0xb028c9bd)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(uint256,string,string,string)`.\\n            mstore(0x00, 0x21ad0683)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,address,address)`.\\n            mstore(0x00, 0xed8f28f6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,address,bool)`.\\n            mstore(0x00, 0xb59dbd60)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,address,uint256)`.\\n            mstore(0x00, 0x8ef3f399)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,address,string)`.\\n            mstore(0x00, 0x800a1c67)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,bool,address)`.\\n            mstore(0x00, 0x223603bd)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,bool,bool)`.\\n            mstore(0x00, 0x79884c2b)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,bool,uint256)`.\\n            mstore(0x00, 0x3e9f866a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,bool,string)`.\\n            mstore(0x00, 0x0454c079)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,uint256,address)`.\\n            mstore(0x00, 0x63fb8bc5)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,uint256,bool)`.\\n            mstore(0x00, 0xfc4845f0)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,uint256,uint256)`.\\n            mstore(0x00, 0xf8f51b1e)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,uint256,string)`.\\n            mstore(0x00, 0x5a477632)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,string,address)`.\\n            mstore(0x00, 0xaabc9a31)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,string,bool)`.\\n            mstore(0x00, 0x5f15d28c)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,string,uint256)`.\\n            mstore(0x00, 0x91d1112e)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,address,string,string)`.\\n            mstore(0x00, 0x245986f2)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,address,address)`.\\n            mstore(0x00, 0x33e9dd1d)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,address,bool)`.\\n            mstore(0x00, 0x958c28c6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,address,uint256)`.\\n            mstore(0x00, 0x5d08bb05)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,address,string)`.\\n            mstore(0x00, 0x2d8e33a4)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,bool,address)`.\\n            mstore(0x00, 0x7190a529)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,bool,bool)`.\\n            mstore(0x00, 0x895af8c5)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,bool,uint256)`.\\n            mstore(0x00, 0x8e3f78a9)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,bool,string)`.\\n            mstore(0x00, 0x9d22d5dd)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,uint256,address)`.\\n            mstore(0x00, 0x935e09bf)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,uint256,bool)`.\\n            mstore(0x00, 0x8af7cf8a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,uint256,uint256)`.\\n            mstore(0x00, 0x64b5bb67)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,uint256,string)`.\\n            mstore(0x00, 0x742d6ee7)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,string,address)`.\\n            mstore(0x00, 0xe0625b29)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,string,bool)`.\\n            mstore(0x00, 0x3f8a701d)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,string,uint256)`.\\n            mstore(0x00, 0x24f91465)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,bool,string,string)`.\\n            mstore(0x00, 0xa826caeb)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,address,address)`.\\n            mstore(0x00, 0x5ea2b7ae)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,address,bool)`.\\n            mstore(0x00, 0x82112a42)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,address,uint256)`.\\n            mstore(0x00, 0x4f04fdc6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,address,string)`.\\n            mstore(0x00, 0x9ffb2f93)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,bool,address)`.\\n            mstore(0x00, 0xe0e95b98)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,bool,bool)`.\\n            mstore(0x00, 0x354c36d6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,bool,uint256)`.\\n            mstore(0x00, 0xe41b6f6f)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,bool,string)`.\\n            mstore(0x00, 0xabf73a98)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,uint256,address)`.\\n            mstore(0x00, 0xe21de278)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,uint256,bool)`.\\n            mstore(0x00, 0x7626db92)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,uint256,uint256)`.\\n            mstore(0x00, 0xa7a87853)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,uint256,string)`.\\n            mstore(0x00, 0x854b3496)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,string,address)`.\\n            mstore(0x00, 0x7c4632a4)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,string,bool)`.\\n            mstore(0x00, 0x7d24491d)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,string,uint256)`.\\n            mstore(0x00, 0xc67ea9d1)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,uint256,string,string)`.\\n            mstore(0x00, 0x5ab84e1f)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,address,address)`.\\n            mstore(0x00, 0x439c7bef)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,address,bool)`.\\n            mstore(0x00, 0x5ccd4e37)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,address,uint256)`.\\n            mstore(0x00, 0x7cc3c607)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,address,string)`.\\n            mstore(0x00, 0xeb1bff80)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,bool,address)`.\\n            mstore(0x00, 0xc371c7db)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,bool,bool)`.\\n            mstore(0x00, 0x40785869)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,bool,uint256)`.\\n            mstore(0x00, 0xd6aefad2)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,bool,string)`.\\n            mstore(0x00, 0x5e84b0ea)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,uint256,address)`.\\n            mstore(0x00, 0x1023f7b2)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,uint256,bool)`.\\n            mstore(0x00, 0xc3a8a654)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,uint256,uint256)`.\\n            mstore(0x00, 0xf45d7d2c)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,uint256,string)`.\\n            mstore(0x00, 0x5d1a971a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,string,address)`.\\n            mstore(0x00, 0x6d572f44)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,string,bool)`.\\n            mstore(0x00, 0x2c1754ed)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,string,uint256)`.\\n            mstore(0x00, 0x8eafb02b)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        bytes32 m11;\\n        bytes32 m12;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            m11 := mload(0x160)\\n            m12 := mload(0x180)\\n            // Selector of `log(string,string,string,string)`.\\n            mstore(0x00, 0xde68f20a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, 0x140)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n            writeString(0x160, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x184);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n            mstore(0x160, m11)\\n            mstore(0x180, m12)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbaf41fdc6c54297e7cd8250e48b0f20eaac918e342a1028cef3f9a52ac086381\",\"license\":\"MIT\"},\"node_modules/@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"node_modules/@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x58b21219689909c4f8339af00813760337f7e2e7f169a97fe49e2896dcfb3b9a\",\"license\":\"MIT\"},\"tests/libraries/math/LibPowMath.t.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {Test, console} from \\\"forge-std/Test.sol\\\";\\nimport \\\"@solit/contracts/libraries/math/LibPowMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\ncontract LibPowMathTest is Test {\\n    uint64 public constant PRECISION = 18;\\n\\n    modifier skipOverflow(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d,\\n        uint8 n\\n    ) {\\n        vm.assume(d != 0);\\n        vm.assume(LibPowMath.findMaxExponent(x) <= n);\\n        vm.assume(LibPowMath.findMaxExponent(y) <= n);\\n        (bool ok, ) = address(this).staticcall(\\n            abi.encodeCall(this.unsafePow, (x, y, d, n))\\n        );\\n        vm.assume(ok);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Ensures the method {LibPowMath.findMaxExponent} works without reverting.\\n     */\\n    function test_findMaxExponent(uint256 n) public pure returns (uint256 res) {\\n        uint16 e = LibPowMath.findMaxExponent(n);\\n        res = n ** uint256(e);\\n    }\\n\\n    /**\\n     * @notice Should fail when the exponent k+1.\\n     */\\n    function testFail_findMaxExponent_ExponentWhenPlus1(\\n        uint256 n\\n    ) public pure returns (uint256 res) {\\n        vm.assume(7132 < n && n < 340282366920938463463374607431768211456);\\n        uint16 k = LibPowMath.findMaxExponent(n);\\n        res = n ** uint256(k + 1);\\n    }\\n\\n    /**\\n     * @notice Gas report for {safeUnutilizedPow}.\\n     */\\n    function testGas_safeUnutilizedPow(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d,\\n        uint8 n\\n    ) public view skipOverflow(x, y, d, n) {\\n        safeUnutilizedPow(x, y, d, n);\\n    }\\n\\n    /**\\n     * @notice Gas report for {LibPowMath.mulDiv}.\\n     */\\n    function testGas_mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d,\\n        uint8 n\\n    ) public view skipOverflow(x, y, d, n) {\\n        x = 5739;\\n        y = 1293;\\n        d = 242;\\n        n = 21;\\n        LibPowMath.mulDiv(x, y, d, n);\\n    }\\n\\n    /**\\n     * @notice Gas report for {LibPowMath.mulDivLowPrecision}.\\n     */\\n    function testGas_mulDivLowPrecision(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d,\\n        uint8 n\\n    ) public view skipOverflow(x, y, d, n) {\\n        LibPowMath.mulDivLowPrecision(x, y, d, n);\\n    }\\n\\n    /**\\n     * @notice Gas report for {LibPowMath.unsafePow}.\\n     */\\n    function testGas_unsafePow(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d,\\n        uint8 n\\n    ) public view skipOverflow(x, y, d, n) {\\n        unsafePow(x, y, d, n);\\n    }\\n\\n    /**\\n     * @notice Test the correctness of the mul div method {LibPowMath.mulDiv}.\\n     */\\n    function test_mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d,\\n        uint8 n\\n    ) public skipOverflow(x, y, d, n) {\\n        uint256 calc = LibPowMath.mulDiv(x, y, d, n);\\n        uint256 expt = safeUnutilizedPow(x, y, d, n);\\n        assertEq(\\n            calc,\\n            expt,\\n            string.concat(\\n                \\\"Expression: \\\",\\n                vm.toString(x),\\n                \\\"*(\\\",\\n                vm.toString(y),\\n                \\\"/\\\",\\n                vm.toString(d),\\n                \\\")**\\\",\\n                vm.toString(n)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Helper method to compute scale: x * (y / d) ^ n.\\n     */\\n    function unsafePow(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d,\\n        uint8 n\\n    ) public pure returns (uint256 r) {\\n        r = x;\\n        for (uint256 i = 0; i < n; i++) {\\n            r = Math.mulDiv(r, y, d);\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper method to compute scale: x * (y / d) ^ n.\\n     */\\n    function safeUnutilizedPow(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d,\\n        uint8 n\\n    ) public pure returns (uint256 res) {\\n        res = x;\\n        uint8 ndReverse;\\n        while (n > 0) {\\n            (bool ok, uint256 res_) = SafeMath.tryMul(res, y);\\n            if (!ok) {\\n                if (ndReverse > 0) {\\n                    res /= d;\\n                    ndReverse--;\\n                    continue;\\n                }\\n\\n                res_ = Math.mulDiv(res, y, d);\\n            } else {\\n                ndReverse++;\\n            }\\n\\n            res = res_;\\n            n--;\\n        }\\n\\n        while (ndReverse > 0) {\\n            res = res / d;\\n            ndReverse--;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x914075595778360c2aca4ee13b4b1fc4a54524655757ad27cf687578e2abe1bc\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "metadata": {
    "compiler": {
      "version": "0.8.21+commit.d9974bed"
    },
    "language": "Solidity",
    "output": {
      "abi": [
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_address",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "uint256[]",
              "name": "val",
              "type": "uint256[]",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_array",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "int256[]",
              "name": "val",
              "type": "int256[]",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_array",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "address[]",
              "name": "val",
              "type": "address[]",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_array",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "bytes",
              "name": "",
              "type": "bytes",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_bytes",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "bytes32",
              "name": "",
              "type": "bytes32",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_bytes32",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "",
              "type": "int256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_int",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "key",
              "type": "string",
              "indexed": false
            },
            {
              "internalType": "address",
              "name": "val",
              "type": "address",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_named_address",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "key",
              "type": "string",
              "indexed": false
            },
            {
              "internalType": "uint256[]",
              "name": "val",
              "type": "uint256[]",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_named_array",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "key",
              "type": "string",
              "indexed": false
            },
            {
              "internalType": "int256[]",
              "name": "val",
              "type": "int256[]",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_named_array",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "key",
              "type": "string",
              "indexed": false
            },
            {
              "internalType": "address[]",
              "name": "val",
              "type": "address[]",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_named_array",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "key",
              "type": "string",
              "indexed": false
            },
            {
              "internalType": "bytes",
              "name": "val",
              "type": "bytes",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_named_bytes",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "key",
              "type": "string",
              "indexed": false
            },
            {
              "internalType": "bytes32",
              "name": "val",
              "type": "bytes32",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_named_bytes32",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "key",
              "type": "string",
              "indexed": false
            },
            {
              "internalType": "int256",
              "name": "val",
              "type": "int256",
              "indexed": false
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_named_decimal_int",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "key",
              "type": "string",
              "indexed": false
            },
            {
              "internalType": "uint256",
              "name": "val",
              "type": "uint256",
              "indexed": false
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_named_decimal_uint",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "key",
              "type": "string",
              "indexed": false
            },
            {
              "internalType": "int256",
              "name": "val",
              "type": "int256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_named_int",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "key",
              "type": "string",
              "indexed": false
            },
            {
              "internalType": "string",
              "name": "val",
              "type": "string",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_named_string",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "key",
              "type": "string",
              "indexed": false
            },
            {
              "internalType": "uint256",
              "name": "val",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_named_uint",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_string",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "",
              "type": "uint256",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "log_uint",
          "anonymous": false
        },
        {
          "inputs": [
            {
              "internalType": "bytes",
              "name": "",
              "type": "bytes",
              "indexed": false
            }
          ],
          "type": "event",
          "name": "logs",
          "anonymous": false
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "IS_TEST",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "PRECISION",
          "outputs": [
            {
              "internalType": "uint64",
              "name": "",
              "type": "uint64"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "excludeArtifacts",
          "outputs": [
            {
              "internalType": "string[]",
              "name": "excludedArtifacts_",
              "type": "string[]"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "excludeContracts",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "excludedContracts_",
              "type": "address[]"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "excludeSenders",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "excludedSenders_",
              "type": "address[]"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "failed",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "x",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "y",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "d",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "n",
              "type": "uint8"
            }
          ],
          "stateMutability": "pure",
          "type": "function",
          "name": "safeUnutilizedPow",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "res",
              "type": "uint256"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "targetArtifactSelectors",
          "outputs": [
            {
              "internalType": "struct StdInvariant.FuzzSelector[]",
              "name": "targetedArtifactSelectors_",
              "type": "tuple[]",
              "components": [
                {
                  "internalType": "address",
                  "name": "addr",
                  "type": "address"
                },
                {
                  "internalType": "bytes4[]",
                  "name": "selectors",
                  "type": "bytes4[]"
                }
              ]
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "targetArtifacts",
          "outputs": [
            {
              "internalType": "string[]",
              "name": "targetedArtifacts_",
              "type": "string[]"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "targetContracts",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "targetedContracts_",
              "type": "address[]"
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "targetInterfaces",
          "outputs": [
            {
              "internalType": "struct StdInvariant.FuzzInterface[]",
              "name": "targetedInterfaces_",
              "type": "tuple[]",
              "components": [
                {
                  "internalType": "address",
                  "name": "addr",
                  "type": "address"
                },
                {
                  "internalType": "string[]",
                  "name": "artifacts",
                  "type": "string[]"
                }
              ]
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "targetSelectors",
          "outputs": [
            {
              "internalType": "struct StdInvariant.FuzzSelector[]",
              "name": "targetedSelectors_",
              "type": "tuple[]",
              "components": [
                {
                  "internalType": "address",
                  "name": "addr",
                  "type": "address"
                },
                {
                  "internalType": "bytes4[]",
                  "name": "selectors",
                  "type": "bytes4[]"
                }
              ]
            }
          ]
        },
        {
          "inputs": [],
          "stateMutability": "view",
          "type": "function",
          "name": "targetSenders",
          "outputs": [
            {
              "internalType": "address[]",
              "name": "targetedSenders_",
              "type": "address[]"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "n",
              "type": "uint256"
            }
          ],
          "stateMutability": "pure",
          "type": "function",
          "name": "testFail_findMaxExponent_ExponentWhenPlus1",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "res",
              "type": "uint256"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "x",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "y",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "d",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "n",
              "type": "uint8"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "testGas_mulDiv"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "x",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "y",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "d",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "n",
              "type": "uint8"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "testGas_mulDivLowPrecision"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "x",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "y",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "d",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "n",
              "type": "uint8"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "testGas_safeUnutilizedPow"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "x",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "y",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "d",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "n",
              "type": "uint8"
            }
          ],
          "stateMutability": "view",
          "type": "function",
          "name": "testGas_unsafePow"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "n",
              "type": "uint256"
            }
          ],
          "stateMutability": "pure",
          "type": "function",
          "name": "test_findMaxExponent",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "res",
              "type": "uint256"
            }
          ]
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "x",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "y",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "d",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "n",
              "type": "uint8"
            }
          ],
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "test_mulDiv"
        },
        {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "x",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "y",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "d",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "n",
              "type": "uint8"
            }
          ],
          "stateMutability": "pure",
          "type": "function",
          "name": "unsafePow",
          "outputs": [
            {
              "internalType": "uint256",
              "name": "r",
              "type": "uint256"
            }
          ]
        }
      ],
      "devdoc": {
        "kind": "dev",
        "methods": {},
        "version": 1
      },
      "userdoc": {
        "kind": "user",
        "methods": {
          "safeUnutilizedPow(uint256,uint256,uint256,uint8)": {
            "notice": "Helper method to compute scale: x * (y / d) ^ n."
          },
          "testFail_findMaxExponent_ExponentWhenPlus1(uint256)": {
            "notice": "Should fail when the exponent k+1."
          },
          "testGas_mulDiv(uint256,uint256,uint256,uint8)": {
            "notice": "Gas report for {LibPowMath.mulDiv}."
          },
          "testGas_mulDivLowPrecision(uint256,uint256,uint256,uint8)": {
            "notice": "Gas report for {LibPowMath.mulDivLowPrecision}."
          },
          "testGas_safeUnutilizedPow(uint256,uint256,uint256,uint8)": {
            "notice": "Gas report for {safeUnutilizedPow}."
          },
          "testGas_unsafePow(uint256,uint256,uint256,uint8)": {
            "notice": "Gas report for {LibPowMath.unsafePow}."
          },
          "test_findMaxExponent(uint256)": {
            "notice": "Ensures the method {LibPowMath.findMaxExponent} works without reverting."
          },
          "test_mulDiv(uint256,uint256,uint256,uint8)": {
            "notice": "Test the correctness of the mul div method {LibPowMath.mulDiv}."
          },
          "unsafePow(uint256,uint256,uint256,uint8)": {
            "notice": "Helper method to compute scale: x * (y / d) ^ n."
          }
        },
        "version": 1
      }
    },
    "settings": {
      "remappings": [
        "@openzeppelin/=node_modules/@openzeppelin/",
        "@solit/contracts/=contracts/",
        "contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/",
        "ds-test/=lib/forge-std/lib/ds-test/src/",
        "eth-gas-reporter/=node_modules/eth-gas-reporter/",
        "forge-std/=lib/forge-std/src/",
        "hardhat/=node_modules/hardhat/",
        "sample-projects/=node_modules/hardhat/sample-projects/",
        "solady/=node_modules/solady/",
        "solmate/=node_modules/solmate/"
      ],
      "optimizer": {
        "enabled": true,
        "runs": 1000000
      },
      "metadata": {
        "useLiteralContent": true,
        "bytecodeHash": "ipfs"
      },
      "compilationTarget": {
        "tests/libraries/math/LibPowMath.t.sol": "LibPowMathTest"
      },
      "libraries": {}
    },
    "sources": {
      "contracts/libraries/math/LibPowMath.sol": {
        "keccak256": "0xb33ae0dd981e4854e8742b36c417b077f7b2cd1ce1371d0cabf08edbe43a6f51",
        "urls": [],
        "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary LibPowMath {\n    using Math for uint256;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Calculates floor(x * (y / d)**n) with full precision.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d,\n        uint16 n\n    ) internal pure returns (uint256 r) {\n        unchecked {\n            if (y == d || n == 0) return x;\n            r = x;\n\n            bool ok;\n            uint256 r_;\n            uint16 nd_;\n\n            {\n                uint16 ye = uint16(Math.min(n, findMaxExponent(y)));\n                while (ye > 0) {\n                    (ok, r_) = r.tryMul(y ** ye);\n                    if (ok) {\n                        r = r_;\n                        n -= ye;\n                        nd_ += ye;\n                    }\n                    ye = uint16(Math.min(ye / 2, n));\n                }\n            }\n\n            while (n > 0) {\n                (ok, r_) = r.tryMul(y);\n                if (ok) {\n                    r = r_;\n                    n--;\n                    nd_++;\n                } else if (nd_ > 0) {\n                    r /= d;\n                    nd_--;\n                } else {\n                    r = r.mulDiv(y, d);\n                    n--;\n                }\n            }\n\n            uint16 de = findMaxExponent(d);\n            while (nd_ > 0) {\n                uint16 e = uint16(Math.min(de, nd_));\n                r /= d ** e;\n                nd_ -= e;\n            }\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * (y / d)**n) with low precision.\n     */\n    function mulDivLowPrecision(\n        uint256 x,\n        uint256 y,\n        uint256 d,\n        uint16 n\n    ) internal pure returns (uint256) {\n        return uncheckedMulDiv(x, y, d, n, findMaxExponent(Math.max(y, d)));\n    }\n\n    /**\n     * @dev Aggregated calculate multiplications.\n     * ```\n     * r = x*(y/d)^k\n     *   = \\prod(x*(y/d)^{k_i}) \\ where \\ sum(k_i) = k\n     * ```\n     */\n    function uncheckedMulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d,\n        uint16 n,\n        uint16 maxE\n    ) internal pure returns (uint256 r) {\n        unchecked {\n            r = x;\n            uint16 e;\n            while (n > 0) {\n                e = uint16(Math.min(n, maxE));\n                r = r.mulDiv(y ** e, d ** e);\n                n -= e;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the largest exponent `k` where, x^k <= 2^256-1\n     * Note: n = Surd[2^256-1,k]\n     *         = 10^( log2(2^256-1) / k * log10(2) )\n     */\n    function findMaxExponent(uint256 x) internal pure returns (uint16 k) {\n        if (x < 3) k = 255;\n        else if (x < 4) k = 128;\n        else if (x < 16) k = 64;\n        else if (x < 256) k = 32;\n        else if (x < 7132) k = 20;\n        else if (x < 11376) k = 19;\n        else if (x < 19113) k = 18;\n        else if (x < 34132) k = 17;\n        else if (x < 65536) k = 16;\n        else if (x < 137271) k = 15;\n        else if (x < 319558) k = 14;\n        else if (x < 847180) k = 13;\n        else if (x < 2642246) k = 12;\n        else if (x < 10134189) k = 11;\n        else if (x < 50859009) k = 10;\n        else if (x < 365284285) k = 9;\n        else if (x < 4294967296) k = 8;\n        else if (x < 102116749983) k = 7;\n        else if (x < 6981463658332) k = 6;\n        else if (x < 2586638741762875) k = 5;\n        else if (x < 18446744073709551616) k = 4;\n        else if (x < 48740834812604276470692695) k = 3;\n        else if (x < 340282366920938463463374607431768211456) k = 2;\n        else k = 1;\n    }\n}\n",
        "license": "MIT"
      },
      "lib/forge-std/lib/ds-test/src/test.sol": {
        "keccak256": "0x8758531bbac3972efcf1fa46383dbe1d276406fe527bc7abb2f236486278e83b",
        "urls": [],
        "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    }\n\n    function fail() internal virtual {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"      Left\", a);\n            emit log_named_address(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"      Left\", a);\n            emit log_named_bytes32(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"      Left\", a);\n            emit log_named_int(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertNotEq(address a, address b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [address]\");\n            emit log_named_address(\"      Left\", a);\n            emit log_named_address(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(address a, address b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string (\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n\n    function assertNotEq(bytes32 a, bytes32 b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"      Left\", a);\n            emit log_named_bytes32(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string (\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n    function assertNotEq32(bytes32 a, bytes32 b) internal {\n        assertNotEq(a, b);\n    }\n    function assertNotEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertNotEq(a, b, err);\n    }\n\n    function assertNotEq(int a, int b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [int]\");\n            emit log_named_int(\"      Left\", a);\n            emit log_named_int(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(int a, int b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n    function assertNotEq(uint a, uint b) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(uint a, uint b, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n    function assertNotEqDecimal(int a, int b, uint decimals) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertNotEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEqDecimal(a, b, decimals);\n        }\n    }\n    function assertNotEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a == b) {\n            emit log(\"Error: a != b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertNotEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a == b) {\n            emit log_named_string(\"Error\", err);\n            assertNotEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"      Left\", a);\n            emit log_named_string(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertNotEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a != b not satisfied [string]\");\n            emit log_named_string(\"      Left\", a);\n            emit log_named_string(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"      Left\", a);\n            emit log_named_bytes(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n\n    function assertNotEq0(bytes memory a, bytes memory b) internal {\n        if (checkEq0(a, b)) {\n            emit log(\"Error: a != b not satisfied [bytes]\");\n            emit log_named_bytes(\"      Left\", a);\n            emit log_named_bytes(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertNotEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertNotEq0(a, b);\n        }\n    }\n}\n",
        "license": "GPL-3.0-or-later"
      },
      "lib/forge-std/src/Base.sol": {
        "keccak256": "0x4ff1a785311017d1eedb1b4737956fa383067ad34eb439abfec1d989754dde1c",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\"hevm cheat code\"))));\n    // console.sol and console2.sol work by executing a staticcall to this address.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\"foundry default caller\"))));\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    // Deterministic deployment address of the Multicall3 contract.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n    // The order of the secp256k1 curve.\n    uint256 internal constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    Vm internal constant vm = Vm(VM_ADDRESS);\n    StdStorage internal stdstore;\n}\n\nabstract contract TestBase is CommonBase {}\n\nabstract contract ScriptBase is CommonBase {\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\n}\n",
        "license": "MIT"
      },
      "lib/forge-std/src/StdAssertions.sol": {
        "keccak256": "0x1a0dee4d8b2c81e9318e87dd85ef009467ebf7dba6575530d1fce94d34dbae60",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {DSTest} from \"ds-test/test.sol\";\nimport {stdMath} from \"./StdMath.sol\";\n\nabstract contract StdAssertions is DSTest {\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal virtual {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bool]\");\n            emit log_named_string(\"      Left\", a ? \"true\" : \"false\");\n            emit log_named_string(\"     Right\", b ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal virtual {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal virtual {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    // Legacy helper\n    function assertEqUint(uint256 a, uint256 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"       Left\", a);\n            emit log_named_int(\"      Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"        Left\", a);\n            emit log_named_uint(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"        Left\", a, decimals);\n            emit log_named_decimal_uint(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"        Left\", a);\n            emit log_named_int(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"        Left\", a, decimals);\n            emit log_named_decimal_int(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta * 100, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta * 100, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\n        assertEqCall(target, callDataA, target, callDataB, true);\n    }\n\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\n        internal\n        virtual\n    {\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\n        internal\n        virtual\n    {\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\n    }\n\n    function assertEqCall(\n        address targetA,\n        bytes memory callDataA,\n        address targetB,\n        bytes memory callDataB,\n        bool strictRevertData\n    ) internal virtual {\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\n\n        if (successA && successB) {\n            assertEq(returnDataA, returnDataB, \"Call return data does not match\");\n        }\n\n        if (!successA && !successB && strictRevertData) {\n            assertEq(returnDataA, returnDataB, \"Call revert data does not match\");\n        }\n\n        if (!successA && successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call revert data\", returnDataA);\n            emit log_named_bytes(\" Right call return data\", returnDataB);\n            fail();\n        }\n\n        if (successA && !successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call return data\", returnDataA);\n            emit log_named_bytes(\" Right call revert data\", returnDataB);\n            fail();\n        }\n    }\n}\n",
        "license": "MIT"
      },
      "lib/forge-std/src/StdChains.sol": {
        "keccak256": "0xdbb593a36db1fde25c398f38312cfedc5b39c4bad1c65c2f58b7515c4dd76be8",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve the RPC URL for `mainnet`:\n *   - If you have specified data with `setChain`, it will return that.\n *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it\n *     is valid (e.g. a URL is specified, or an environment variable is given and exists).\n *   - If neither of the above conditions is met, the default data is returned.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private stdChainsInitialized;\n\n    struct ChainData {\n        string name;\n        uint256 chainId;\n        string rpcUrl;\n    }\n\n    struct Chain {\n        // The chain name.\n        string name;\n        // The chain's Chain ID.\n        uint256 chainId;\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\n        string chainAlias;\n        // A default RPC endpoint for this chain.\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\n        string rpcUrl;\n    }\n\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\n    mapping(string => Chain) private chains;\n    // Maps from the chain's alias to it's default RPC URL.\n    mapping(string => string) private defaultRpcUrls;\n    // Maps from a chain ID to it's alias.\n    mapping(uint256 => string) private idToAlias;\n\n    bool private fallbackToDefaultRpcUrls = true;\n\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\n        require(bytes(chainAlias).length != 0, \"StdChains getChain(string): Chain alias cannot be the empty string.\");\n\n        initializeStdChains();\n        chain = chains[chainAlias];\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(string): Chain with alias \\\"\", chainAlias, \"\\\" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\n        require(chainId != 0, \"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        initializeStdChains();\n        string memory chainAlias = idToAlias[chainId];\n\n        chain = chains[chainAlias];\n\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(uint256): Chain with ID \", vm.toString(chainId), \" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\n        require(\n            bytes(chainAlias).length != 0,\n            \"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\"\n        );\n\n        require(chain.chainId != 0, \"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n\n        initializeStdChains();\n        string memory foundAlias = idToAlias[chain.chainId];\n\n        require(\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\n            string(\n                abi.encodePacked(\n                    \"StdChains setChain(string,ChainData): Chain ID \",\n                    vm.toString(chain.chainId),\n                    \" already used by \\\"\",\n                    foundAlias,\n                    \"\\\".\"\n                )\n            )\n        );\n\n        uint256 oldChainId = chains[chainAlias].chainId;\n        delete idToAlias[oldChainId];\n\n        chains[chainAlias] =\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\n        idToAlias[chain.chainId] = chainAlias;\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\n    }\n\n    function _toUpper(string memory str) private pure returns (string memory) {\n        bytes memory strb = bytes(str);\n        bytes memory copy = new bytes(strb.length);\n        for (uint256 i = 0; i < strb.length; i++) {\n            bytes1 b = strb[i];\n            if (b >= 0x61 && b <= 0x7A) {\n                copy[i] = bytes1(uint8(b) - 32);\n            } else {\n                copy[i] = b;\n            }\n        }\n        return string(copy);\n    }\n\n    // lookup rpcUrl, in descending order of priority:\n    // current -> config (foundry.toml) -> environment variable -> default\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain) private returns (Chain memory) {\n        if (bytes(chain.rpcUrl).length == 0) {\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\n                chain.rpcUrl = configRpcUrl;\n            } catch (bytes memory err) {\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \"_RPC_URL\"));\n                if (fallbackToDefaultRpcUrls) {\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\n                } else {\n                    chain.rpcUrl = vm.envString(envName);\n                }\n                // distinguish 'not found' from 'cannot read'\n                bytes memory notFoundError =\n                    abi.encodeWithSignature(\"CheatCodeError\", string(abi.encodePacked(\"invalid rpc url \", chainAlias)));\n                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, err), mload(err))\n                    }\n                }\n            }\n        }\n        return chain;\n    }\n\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\n        fallbackToDefaultRpcUrls = useDefault;\n    }\n\n    function initializeStdChains() private {\n        if (stdChainsInitialized) return;\n\n        stdChainsInitialized = true;\n\n        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`\n        setChainWithDefaultRpcUrl(\"anvil\", ChainData(\"Anvil\", 31337, \"http://127.0.0.1:8545\"));\n        setChainWithDefaultRpcUrl(\n            \"mainnet\", ChainData(\"Mainnet\", 1, \"https://mainnet.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"goerli\", ChainData(\"Goerli\", 5, \"https://goerli.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"sepolia\", ChainData(\"Sepolia\", 11155111, \"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\"optimism\", ChainData(\"Optimism\", 10, \"https://mainnet.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"optimism_goerli\", ChainData(\"Optimism Goerli\", 420, \"https://goerli.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"arbitrum_one\", ChainData(\"Arbitrum One\", 42161, \"https://arb1.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"arbitrum_one_goerli\", ChainData(\"Arbitrum One Goerli\", 421613, \"https://goerli-rollup.arbitrum.io/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_nova\", ChainData(\"Arbitrum Nova\", 42170, \"https://nova.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\"polygon\", ChainData(\"Polygon\", 137, \"https://polygon-rpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"polygon_mumbai\", ChainData(\"Polygon Mumbai\", 80001, \"https://rpc-mumbai.maticvigil.com\")\n        );\n        setChainWithDefaultRpcUrl(\"avalanche\", ChainData(\"Avalanche\", 43114, \"https://api.avax.network/ext/bc/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"avalanche_fuji\", ChainData(\"Avalanche Fuji\", 43113, \"https://api.avax-test.network/ext/bc/C/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain\", ChainData(\"BNB Smart Chain\", 56, \"https://bsc-dataseed1.binance.org\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain_testnet\",\n            ChainData(\"BNB Smart Chain Testnet\", 97, \"https://rpc.ankr.com/bsc_testnet_chapel\")\n        );\n        setChainWithDefaultRpcUrl(\"gnosis_chain\", ChainData(\"Gnosis Chain\", 100, \"https://rpc.gnosischain.com\"));\n        setChainWithDefaultRpcUrl(\"moonbeam\", ChainData(\"Moonbeam\", 1284, \"https://rpc.api.moonbeam.network\"));\n        setChainWithDefaultRpcUrl(\n            \"moonriver\", ChainData(\"Moonriver\", 1285, \"https://rpc.api.moonriver.moonbeam.network\")\n        );\n        setChainWithDefaultRpcUrl(\"moonbase\", ChainData(\"Moonbase\", 1287, \"https://rpc.testnet.moonbeam.network\"));\n        setChainWithDefaultRpcUrl(\"base_goerli\", ChainData(\"Base Goerli\", 84531, \"https://goerli.base.org\"));\n        setChainWithDefaultRpcUrl(\"base\", ChainData(\"Base\", 8453, \"https://mainnet.base.org\"));\n    }\n\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\n        string memory rpcUrl = chain.rpcUrl;\n        defaultRpcUrls[chainAlias] = rpcUrl;\n        chain.rpcUrl = \"\";\n        setChain(chainAlias, chain);\n        chain.rpcUrl = rpcUrl; // restore argument\n    }\n}\n",
        "license": "MIT"
      },
      "lib/forge-std/src/StdCheats.sol": {
        "keccak256": "0xa0bac08b3d12d561fadf74c83c69f3ee54fe40e0c7766611766f6db70c202373",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {console2} from \"./console2.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy {\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList {\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n    struct Account {\n        address addr;\n        uint256 key;\n    }\n\n    enum AddressType {\n        Payable,\n        NonPayable,\n        ZeroAddress,\n        Precompile,\n        ForgeAddress\n    }\n\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\n    function assumeNotBlacklisted(address token, address addr) internal view virtual {\n        // Nothing to check if `token` is not a contract.\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.\");\n\n        bool success;\n        bytes memory returnData;\n\n        // 4-byte selector for `isBlacklisted(address)`, used by USDC.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n\n        // 4-byte selector for `isBlackListed(address)`, used by USDT.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n    }\n\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\n    // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for\n    // backwards compatibility, since this name was used in the original PR which has already has\n    // a release. This function can be removed in a future release once we want a breaking change.\n    function assumeNoBlacklisted(address token, address addr) internal view virtual {\n        assumeNotBlacklisted(token, addr);\n    }\n\n    function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {\n        if (addressType == AddressType.Payable) {\n            assumeNotPayable(addr);\n        } else if (addressType == AddressType.NonPayable) {\n            assumePayable(addr);\n        } else if (addressType == AddressType.ZeroAddress) {\n            assumeNotZeroAddress(addr);\n        } else if (addressType == AddressType.Precompile) {\n            assumeNotPrecompile(addr);\n        } else if (addressType == AddressType.ForgeAddress) {\n            assumeNotForgeAddress(addr);\n        }\n    }\n\n    function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n    }\n\n    function assumeAddressIsNot(\n        address addr,\n        AddressType addressType1,\n        AddressType addressType2,\n        AddressType addressType3\n    ) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n        assumeAddressIsNot(addr, addressType3);\n    }\n\n    function assumeAddressIsNot(\n        address addr,\n        AddressType addressType1,\n        AddressType addressType2,\n        AddressType addressType3,\n        AddressType addressType4\n    ) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n        assumeAddressIsNot(addr, addressType3);\n        assumeAddressIsNot(addr, addressType4);\n    }\n\n    // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to\n    // `addr` and checking the `success` return value.\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\n    // implemented by `addr`, which should be taken into account when this function is used.\n    function _isPayable(address addr) private returns (bool) {\n        require(\n            addr.balance < UINT256_MAX,\n            \"StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds\"\n        );\n        uint256 origBalanceTest = address(this).balance;\n        uint256 origBalanceAddr = address(addr).balance;\n\n        vm.deal(address(this), 1);\n        (bool success,) = payable(addr).call{value: 1}(\"\");\n\n        // reset balances\n        vm.deal(address(this), origBalanceTest);\n        vm.deal(addr, origBalanceAddr);\n\n        return success;\n    }\n\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\n    // implemented by `addr`, which should be taken into account when this function is used. See the\n    // `_isPayable` method for more information.\n    function assumePayable(address addr) internal virtual {\n        vm.assume(_isPayable(addr));\n    }\n\n    function assumeNotPayable(address addr) internal virtual {\n        vm.assume(!_isPayable(addr));\n    }\n\n    function assumeNotZeroAddress(address addr) internal pure virtual {\n        vm.assume(addr != address(0));\n    }\n\n    function assumeNotPrecompile(address addr) internal pure virtual {\n        assumeNotPrecompile(addr, _pureChainId());\n    }\n\n    function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\n        // address), but the same rationale for excluding them applies so we include those too.\n\n        // These should be present on all EVM-compatible chains.\n        vm.assume(addr < address(0x1) || addr > address(0x9));\n\n        // forgefmt: disable-start\n        if (chainId == 10 || chainId == 420) {\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\n        } else if (chainId == 42161 || chainId == 421613) {\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\n        } else if (chainId == 43114 || chainId == 43113) {\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\n        }\n        // forgefmt: disable-end\n    }\n\n    function assumeNotForgeAddress(address addr) internal pure virtual {\n        // vm, console, and Create2Deployer addresses\n        vm.assume(\n            addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67\n                && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C\n        );\n    }\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        view\n        virtual\n        returns (EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint256 i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash = rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode = rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        pure\n        virtual\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\n        txDetail.txType = _bytesToUint(rawDetail.txType);\n        txDetail.value = _bytesToUint(rawDetail.value);\n        txDetail.gas = _bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n    }\n\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint256 i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\n        receipt.status = _bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        pure\n        virtual\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint256 i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes): Deployment failed.\");\n    }\n\n    function deployCode(string memory what) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string): Deployment failed.\");\n    }\n\n    /// @dev deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes,uint256): Deployment failed.\");\n    }\n\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,uint256): Deployment failed.\");\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal virtual returns (address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // Destroys an account immediately, sending the balance to beneficiary.\n    // Destroying means: balance will be zero, code will be empty, and nonce will be 0\n    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce\n    // only after tx ends, this will run immediately.\n    function destroyAccount(address who, address beneficiary) internal virtual {\n        uint256 currBalance = who.balance;\n        vm.etch(who, abi.encode());\n        vm.deal(who, 0);\n        vm.resetNonce(who);\n\n        uint256 beneficiaryBalance = beneficiary.balance;\n        vm.deal(beneficiary, currBalance + beneficiaryBalance);\n    }\n\n    // creates a struct containing both a labeled address and the corresponding private key\n    function makeAccount(string memory name) internal virtual returns (Account memory account) {\n        (account.addr, account.key) = makeAddrAndKey(name);\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index)\n        internal\n        virtual\n        returns (address who, uint256 privateKey)\n    {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\n        require(b.length <= 32, \"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    function isFork() internal view virtual returns (bool status) {\n        try vm.activeFork() {\n            status = true;\n        } catch (bytes memory) {}\n    }\n\n    modifier skipWhenForking() {\n        if (!isFork()) {\n            _;\n        }\n    }\n\n    modifier skipWhenNotForking() {\n        if (isFork()) {\n            _;\n        }\n    }\n\n    modifier noGasMetering() {\n        vm.pauseGasMetering();\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\n        // it back on until we exit the top level function that used the modifier\n        //\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\n        // so we only turn metering back on at the end of the funcA\n        bool gasStartedOff = gasMeteringOff;\n        gasMeteringOff = true;\n\n        _;\n\n        // if gas metering was on when this modifier was called, turn it back on at the end\n        if (!gasStartedOff) {\n            gasMeteringOff = false;\n            vm.resumeGasMetering();\n        }\n    }\n\n    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no\n    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We\n    // can't simply access the chain ID in a normal view or pure function because the solc View Pure\n    // Checker changed `chainid` from pure to view in 0.8.0.\n    function _viewChainId() private view returns (uint256 chainId) {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        assembly {\n            chainId := chainid()\n        }\n\n        address(this); // Silence warnings in older Solc versions.\n    }\n\n    function _pureChainId() private pure returns (uint256 chainId) {\n        function() internal view returns (uint256) fnIn = _viewChainId;\n        function() internal pure returns (uint256) pureChainId;\n        assembly {\n            pureChainId := fnIn\n        }\n        chainId = pureChainId();\n    }\n}\n\n// Wrappers around cheatcodes to avoid footguns\nabstract contract StdCheats is StdCheatsSafe {\n    using stdStorage for StdStorage;\n\n    StdStorage private stdstore;\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal virtual {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal virtual {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender, origin);\n    }\n\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender);\n    }\n\n    function startHoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function changePrank(address msgSender) internal virtual {\n        console2_log(\"changePrank is deprecated. Please use vm.startPrank instead.\");\n        vm.stopPrank();\n        vm.startPrank(msgSender);\n    }\n\n    function changePrank(address msgSender, address txOrigin) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender, txOrigin);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal virtual {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal virtual {\n        deal(token, to, give, false);\n    }\n\n    // Set the balance of an account for any ERC1155 token\n    // Use the alternative signature to update `totalSupply`\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\n        dealERC1155(token, to, id, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\n        }\n    }\n\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));\n            require(\n                totSupData.length != 0,\n                \"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\"\n            );\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\n        }\n    }\n\n    function dealERC721(address token, address to, uint256 id) internal virtual {\n        // check if token id is already minted and the actual owner.\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n        require(successMinted, \"StdCheats deal(address,address,uint,bool): id not minted.\");\n\n        // get owner current balance\n        (, bytes memory fromBalData) =\n            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\n\n        // get new user current balance\n        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\n\n        // update balances\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\n\n        // update owner\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\n    }\n\n    function deployCodeTo(string memory what, address where) internal virtual {\n        deployCodeTo(what, \"\", 0, where);\n    }\n\n    function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {\n        deployCodeTo(what, args, 0, where);\n    }\n\n    function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {\n        bytes memory creationCode = vm.getCode(what);\n        vm.etch(where, abi.encodePacked(creationCode, args));\n        (bool success, bytes memory runtimeBytecode) = where.call{value: value}(\"\");\n        require(success, \"StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.\");\n        vm.etch(where, runtimeBytecode);\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n    function console2_log(string memory p0) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n        status;\n    }\n}\n",
        "license": "MIT"
      },
      "lib/forge-std/src/StdError.sol": {
        "keccak256": "0xbf477b11a42d7611696956546bcfaa29317d1166bf65e402344599c05943fc77",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n",
        "license": "MIT"
      },
      "lib/forge-std/src/StdInvariant.sol": {
        "keccak256": "0x67299bfacd77fddfa2a67b8e2b901e0e333618a4975fb94850b07475e51f6de6",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nabstract contract StdInvariant {\n    struct FuzzSelector {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    struct FuzzInterface {\n        address addr;\n        string[] artifacts;\n    }\n\n    address[] private _excludedContracts;\n    address[] private _excludedSenders;\n    address[] private _targetedContracts;\n    address[] private _targetedSenders;\n\n    string[] private _excludedArtifacts;\n    string[] private _targetedArtifacts;\n\n    FuzzSelector[] private _targetedArtifactSelectors;\n    FuzzSelector[] private _targetedSelectors;\n\n    FuzzInterface[] private _targetedInterfaces;\n\n    // Functions for users:\n    // These are intended to be called in tests.\n\n    function excludeContract(address newExcludedContract_) internal {\n        _excludedContracts.push(newExcludedContract_);\n    }\n\n    function excludeSender(address newExcludedSender_) internal {\n        _excludedSenders.push(newExcludedSender_);\n    }\n\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\n        _excludedArtifacts.push(newExcludedArtifact_);\n    }\n\n    function targetArtifact(string memory newTargetedArtifact_) internal {\n        _targetedArtifacts.push(newTargetedArtifact_);\n    }\n\n    function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\n    }\n\n    function targetContract(address newTargetedContract_) internal {\n        _targetedContracts.push(newTargetedContract_);\n    }\n\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\n        _targetedSelectors.push(newTargetedSelector_);\n    }\n\n    function targetSender(address newTargetedSender_) internal {\n        _targetedSenders.push(newTargetedSender_);\n    }\n\n    function targetInterface(FuzzInterface memory newTargetedInterface_) internal {\n        _targetedInterfaces.push(newTargetedInterface_);\n    }\n\n    // Functions for forge:\n    // These are called by forge to run invariant tests and don't need to be called in tests.\n\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n\n    function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {\n        targetedInterfaces_ = _targetedInterfaces;\n    }\n}\n",
        "license": "MIT"
      },
      "lib/forge-std/src/StdJson.sol": {
        "keccak256": "0x8f914dbd016bd0e318fe2b8bd556fbc8256c7cddc24e3e4fcb9f3c1c1935592d",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"some_peth\");\n// json.parseUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"deploymentArtifact\";\n// Contract contract = new Contract();\n// json.serialize(\"contractAddress\", address(contract));\n// json = json.serialize(\"deploymentTimes\", uint(1));\n// // store the stringified JSON to the 'json' variable we have been using as a key\n// // as we won't need it any longer\n// string memory json2 = \"finalArtifact\";\n// string memory final = json2.serialize(\"depArtifact\", json);\n// final.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal pure returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal pure returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) internal pure returns (string memory) {\n        return vm.parseJsonString(json, key);\n    }\n\n    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {\n        return vm.parseJsonStringArray(json, key);\n    }\n\n    function readAddress(string memory json, string memory key) internal pure returns (address) {\n        return vm.parseJsonAddress(json, key);\n    }\n\n    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {\n        return vm.parseJsonAddressArray(json, key);\n    }\n\n    function readBool(string memory json, string memory key) internal pure returns (bool) {\n        return vm.parseJsonBool(json, key);\n    }\n\n    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {\n        return vm.parseJsonBoolArray(json, key);\n    }\n\n    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJsonBytes(json, key);\n    }\n\n    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {\n        return vm.parseJsonBytesArray(json, key);\n    }\n\n    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {\n        return vm.serializeJson(jsonKey, rootObject);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeJson(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeJson(jsonKey, path, valueKey);\n    }\n}\n",
        "license": "MIT"
      },
      "lib/forge-std/src/StdMath.sol": {
        "keccak256": "0xd90ad4fd8aeaeb8929964e686e769fdedd5eded3fc3815df194a0ab9f91a3fb2",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n",
        "license": "MIT"
      },
      "lib/forge-std/src/StdStorage.sol": {
        "keccak256": "0x4298f3f4cedaedb07029820b1daad2c03af45379559392201f7bf3ec71105811",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n\n        (bytes32[] memory reads,) = vm.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(\n                    false,\n                    \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n                );\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                if (prev != fdat) {\n                    continue;\n                }\n                bytes32 new_val = ~prev;\n                // store\n                vm.store(who, reads[i], new_val);\n                bool success;\n                {\n                    bytes memory rdat;\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32 * field_depth);\n                }\n\n                if (success && fdat == new_val) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm.store(who, reads[i], prev);\n                    break;\n                }\n                vm.store(who, reads[i], prev);\n            }\n        } else {\n            revert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],\n            \"stdStorage find(StdStorage): Slot(s) not found.\"\n        );\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\n        address who = self._target;\n        uint256 field_depth = self._depth;\n        vm.startMappingRecording();\n        uint256 child = find(self) - field_depth;\n        (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\n        if (!found) {\n            revert(\n                \"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\"\n            );\n        }\n        return (uint256(parent_slot), key);\n    }\n\n    function root(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        uint256 field_depth = self._depth;\n        vm.startMappingRecording();\n        uint256 child = find(self) - field_depth;\n        bool found;\n        bytes32 root_slot;\n        bytes32 parent_slot;\n        (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\n        if (!found) {\n            revert(\n                \"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\"\n            );\n        }\n        while (found) {\n            root_slot = parent_slot;\n            (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));\n        }\n        return uint256(root_slot);\n    }\n\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\nlibrary stdStorage {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return stdStorageSafe.sigs(sigStr);\n    }\n\n    function find(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.find(self);\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        return stdStorageSafe.target(self, _target);\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, who);\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, amt);\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, key);\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        return stdStorageSafe.depth(self, _depth);\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write_int(StdStorage storage self, int256 val) internal {\n        checked_write(self, bytes32(uint256(val)));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(StdStorage storage self, bytes32 set) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n        bytes32 curr = vm.load(who, slot);\n\n        if (fdat != curr) {\n            require(\n                false,\n                \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n            );\n        }\n        vm.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return stdStorageSafe.read_bytes32(self);\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return stdStorageSafe.read_bool(self);\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return stdStorageSafe.read_address(self);\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.read_uint(self);\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return stdStorageSafe.read_int(self);\n    }\n\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\n        return stdStorageSafe.parent(self);\n    }\n\n    function root(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.root(self);\n    }\n\n    // Private function so needs to be copied over\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    // Private function so needs to be copied over\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n",
        "license": "MIT"
      },
      "lib/forge-std/src/StdStyle.sol": {
        "keccak256": "0x43e2a8a9b9c2574dabe74f11adf6f782df218f463540e3b5b563609fe108597d",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\nlibrary StdStyle {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    string constant RED = \"\\u001b[91m\";\n    string constant GREEN = \"\\u001b[92m\";\n    string constant YELLOW = \"\\u001b[93m\";\n    string constant BLUE = \"\\u001b[94m\";\n    string constant MAGENTA = \"\\u001b[95m\";\n    string constant CYAN = \"\\u001b[96m\";\n    string constant BOLD = \"\\u001b[1m\";\n    string constant DIM = \"\\u001b[2m\";\n    string constant ITALIC = \"\\u001b[3m\";\n    string constant UNDERLINE = \"\\u001b[4m\";\n    string constant INVERSE = \"\\u001b[7m\";\n    string constant RESET = \"\\u001b[0m\";\n\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\n        return string(abi.encodePacked(style, self, RESET));\n    }\n\n    function red(string memory self) internal pure returns (string memory) {\n        return styleConcat(RED, self);\n    }\n\n    function red(uint256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(int256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(address self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(bool self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes(bytes memory self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function green(string memory self) internal pure returns (string memory) {\n        return styleConcat(GREEN, self);\n    }\n\n    function green(uint256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(int256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(address self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(bool self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function yellow(string memory self) internal pure returns (string memory) {\n        return styleConcat(YELLOW, self);\n    }\n\n    function yellow(uint256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(int256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(address self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(bool self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function blue(string memory self) internal pure returns (string memory) {\n        return styleConcat(BLUE, self);\n    }\n\n    function blue(uint256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(int256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(address self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(bool self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function magenta(string memory self) internal pure returns (string memory) {\n        return styleConcat(MAGENTA, self);\n    }\n\n    function magenta(uint256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(int256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(address self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(bool self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function cyan(string memory self) internal pure returns (string memory) {\n        return styleConcat(CYAN, self);\n    }\n\n    function cyan(uint256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(int256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(address self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(bool self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function bold(string memory self) internal pure returns (string memory) {\n        return styleConcat(BOLD, self);\n    }\n\n    function bold(uint256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(int256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(address self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(bool self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function dim(string memory self) internal pure returns (string memory) {\n        return styleConcat(DIM, self);\n    }\n\n    function dim(uint256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(int256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(address self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(bool self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function italic(string memory self) internal pure returns (string memory) {\n        return styleConcat(ITALIC, self);\n    }\n\n    function italic(uint256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(int256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(address self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(bool self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function underline(string memory self) internal pure returns (string memory) {\n        return styleConcat(UNDERLINE, self);\n    }\n\n    function underline(uint256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(int256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(address self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(bool self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function inverse(string memory self) internal pure returns (string memory) {\n        return styleConcat(INVERSE, self);\n    }\n\n    function inverse(uint256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(int256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(address self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(bool self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n}\n",
        "license": "MIT"
      },
      "lib/forge-std/src/StdUtils.sol": {
        "keccak256": "0x8758c42ba9d9e46868b796e2330ac239006ede07bd438a4b36dd6f2c47d27dc1",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\n\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\n        if (x > max) {\n            uint256 diff = x - max;\n            uint256 rem = diff % size;\n            if (rem == 0) return max;\n            result = min + rem - 1;\n        } else if (x < min) {\n            uint256 diff = min - x;\n            uint256 rem = diff % size;\n            if (rem == 0) return min;\n            result = max - rem + 1;\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {\n        result = _bound(x, min, max);\n        console2_log(\"Bound Result\", result);\n    }\n\n    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\n        require(min <= max, \"StdUtils bound(int256,int256,int256): Max is less than min.\");\n\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\n        // int256 : -(2**255) ~ (2**255 - 1)\n        // uint256:     0     ~ (2**256 - 1)\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\n        //\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\n        // So, use `~uint256(x) + 1` instead.\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\n\n        uint256 y = _bound(_x, _min, _max);\n\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\n    }\n\n    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {\n        result = _bound(x, min, max);\n        console2_log(\"Bound result\", vm.toString(result));\n    }\n\n    function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {\n        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);\n    }\n\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\n        require(b.length <= 32, \"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\n        // forgefmt: disable-start\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n        // forgefmt: disable-end\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(\n            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))\n        );\n    }\n\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\n        internal\n        pure\n        virtual\n        returns (address)\n    {\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));\n    }\n\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\n        return computeCreate2Address(salt, initCodeHash, CREATE2_FACTORY);\n    }\n\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\n        return hashInitCode(creationCode, \"\");\n    }\n\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    /// @param args the ABI-encoded arguments to the constructor of C\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(creationCode, args));\n    }\n\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\n    function getTokenBalances(address token, address[] memory addresses)\n        internal\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n\n        // ABI encode the aggregate call to Multicall3.\n        uint256 length = addresses.length;\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            // 0x70a08231 = bytes4(\"balanceOf(address)\"))\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\n        }\n\n        // Make the aggregate call.\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\n\n        // ABI decode the return data and return the balances.\n        balances = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            balances[i] = abi.decode(returnData[i], (uint256));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n\n    function console2_log(string memory p0, uint256 p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n        status;\n    }\n\n    function console2_log(string memory p0, string memory p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n        status;\n    }\n}\n",
        "license": "MIT"
      },
      "lib/forge-std/src/Test.sol": {
        "keccak256": "0x39b1729d5868c8e94ab8af16751eb500a17fe3870dc627d2b7ddcd5df18d7ad0",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n//  ABOUT\n// Forge Std's default Test.\n\n//  MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {safeconsole} from \"./safeconsole.sol\";\nimport {StdAssertions} from \"./StdAssertions.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheats} from \"./StdCheats.sol\";\nimport {stdError} from \"./StdError.sol\";\nimport {StdInvariant} from \"./StdInvariant.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {Vm} from \"./Vm.sol\";\n\n//  BOILERPLATE\nimport {TestBase} from \"./Base.sol\";\nimport {DSTest} from \"ds-test/test.sol\";\n\n//  TEST\nabstract contract Test is TestBase, DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {\n// Note: IS_TEST() must return true.\n// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.\n}\n",
        "license": "MIT"
      },
      "lib/forge-std/src/Vm.sol": {
        "keccak256": "0x64827f48bafb014a69560bc980355f5c3351e4235ee43338c0f8a43a01cdff62",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// Cheatcodes are marked as view/pure/none using the following rules:\n// 0. A call's observable behaviour includes its return value, logs, reverts and state writes,\n// 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),\n// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,\n// 3. Otherwise you're `pure`.\n\ninterface VmSafe {\n    enum CallerMode {\n        None,\n        Broadcast,\n        RecurrentBroadcast,\n        Prank,\n        RecurrentPrank\n    }\n\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n        address emitter;\n    }\n\n    struct Rpc {\n        string key;\n        string url;\n    }\n\n    struct DirEntry {\n        string errorMessage;\n        string path;\n        uint64 depth;\n        bool isDir;\n        bool isSymlink;\n    }\n\n    struct FsMetadata {\n        bool isDir;\n        bool isSymlink;\n        uint256 length;\n        bool readOnly;\n        uint256 modified;\n        uint256 accessed;\n        uint256 created;\n    }\n\n    struct Wallet {\n        address addr;\n        uint256 publicKeyX;\n        uint256 publicKeyY;\n        uint256 privateKey;\n    }\n\n    struct FfiResult {\n        int32 exit_code;\n        bytes stdout;\n        bytes stderr;\n    }\n\n    // Derives a private key from the name, labels the account with that name, and returns the wallet\n    function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);\n    // Generates a wallet from the private key and returns the wallet\n    function createWallet(uint256 privateKey) external returns (Wallet memory wallet);\n    // Generates a wallet from the private key, labels the account with that name, and returns the wallet\n    function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);\n    // Signs data, (Wallet, digest) => (v, r, s)\n    function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);\n    // Get nonce for a Wallet\n    function getNonce(Wallet calldata wallet) external returns (uint64 nonce);\n\n    // Loads a storage slot from an address\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n    // Signs data\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n    // Gets the address for a given private key\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n    // Gets the nonce of an account\n    function getNonce(address account) external view returns (uint64 nonce);\n    // Performs a foreign function call via the terminal\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n    // Performs a foreign function call via terminal and returns the exit code, stdout, and stderr\n    function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);\n    // Sets environment variables\n    function setEnv(string calldata name, string calldata value) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata name) external view returns (bool value);\n    function envUint(string calldata name) external view returns (uint256 value);\n    function envInt(string calldata name) external view returns (int256 value);\n    function envAddress(string calldata name) external view returns (address value);\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n    function envString(string calldata name) external view returns (string memory value);\n    function envBytes(string calldata name) external view returns (bytes memory value);\n    // Reads environment variables as arrays\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n    // Read environment variables with default value\n    function envOr(string calldata name, bool defaultValue) external returns (bool value);\n    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);\n    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);\n    function envOr(string calldata name, address defaultValue) external returns (address value);\n    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);\n    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);\n    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);\n    // Read environment variables as arrays with default value\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        returns (bool[] memory value);\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        returns (uint256[] memory value);\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        returns (int256[] memory value);\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        returns (address[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        returns (bytes32[] memory value);\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        returns (string[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        returns (bytes[] memory value);\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n    // Labels an address in call traces\n    function label(address account, string calldata newLabel) external;\n    // Gets the label for the specified address\n    function getLabel(address account) external returns (string memory currentLabel);\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address signer) external;\n    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain\n    function broadcast(uint256 privateKey) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain\n    function startBroadcast(address signer) external;\n    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain\n    function startBroadcast(uint256 privateKey) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n\n    // Get the path of the current project root.\n    function projectRoot() external view returns (string memory path);\n    // Reads the entire content of file to string. `path` is relative to the project root.\n    function readFile(string calldata path) external view returns (string memory data);\n    // Reads the entire content of file as binary. `path` is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n    // Reads next line of file to string.\n    function readLine(string calldata path) external view returns (string memory line);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // `path` is relative to the project root.\n    function writeFile(string calldata path, string calldata data) external;\n    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // `path` is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n    // Writes line to file, creating a file if it does not exist.\n    // `path` is relative to the project root.\n    function writeLine(string calldata path, string calldata data) external;\n    // Copies the contents of one file to another. This function will **overwrite** the contents of `to`.\n    // On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.\n    // Both `from` and `to` are relative to the project root.\n    function copyFile(string calldata from, string calldata to) external returns (uint64 copied);\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    // `path` is relative to the project root.\n    function closeFile(string calldata path) external;\n    // Removes a file from the filesystem.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - `path` points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    // `path` is relative to the project root.\n    function removeFile(string calldata path) external;\n    // Creates a new, empty directory at the provided path.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - User lacks permissions to modify `path`.\n    // - A parent of the given path doesn't exist and `recursive` is false.\n    // - `path` already exists and `recursive` is false.\n    // `path` is relative to the project root.\n    function createDir(string calldata path, bool recursive) external;\n    // Removes a directory at the provided path.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - `path` doesn't exist.\n    // - `path` isn't a directory.\n    // - User lacks permissions to modify `path`.\n    // - The directory is not empty and `recursive` is false.\n    // `path` is relative to the project root.\n    function removeDir(string calldata path, bool recursive) external;\n    // Reads the directory at the given path recursively, up to `max_depth`.\n    // `max_depth` defaults to 1, meaning only the direct children of the given directory will be returned.\n    // Follows symbolic links if `follow_links` is true.\n    function readDir(string calldata path) external view returns (DirEntry[] memory entries);\n    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);\n    function readDir(string calldata path, uint64 maxDepth, bool followLinks)\n        external\n        view\n        returns (DirEntry[] memory entries);\n    // Reads a symbolic link, returning the path that the link points to.\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - `path` is not a symbolic link.\n    // - `path` does not exist.\n    function readLink(string calldata linkPath) external view returns (string memory targetPath);\n    // Given a path, query the file system to get information about a file, directory, etc.\n    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);\n    // Returns true if the given path points to an existing entity, else returns false\n    function exists(string calldata path) external returns (bool result);\n    // Returns true if the path exists on disk and is pointing at a regular file, else returns false\n    function isFile(string calldata path) external returns (bool result);\n    // Returns true if the path exists on disk and is pointing at a directory, else returns false\n    function isDir(string calldata path) external returns (bool result);\n\n    // Convert values to a string\n    function toString(address value) external pure returns (string memory stringifiedValue);\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n    // Convert values from a string\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs\n    function getRecordedLogs() external returns (Log[] memory logs);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n    // Adds a private key to the local forge wallet and returns the address\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n    //\n    // parseJson\n    //\n    // ----\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\n    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\n    // as tuples, with the attributes in the order in which they are defined.\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\n    // a: uint256\n    // b: address\n    // To decode that json, we need to define a struct or a tuple as follows:\n    // struct json = { uint256 a; address b; }\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\n    // decode the tuple in that order, and thus fail.\n    // ----\n    // Given a string of JSON, return it as ABI-encoded\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    // The following parseJson cheatcodes will do type coercion, for the type that they indicate.\n    // For example, parseJsonUint will coerce all values to a uint256. That includes stringified numbers '12'\n    // and hex numbers '0xEF'.\n    // Type coercion works ONLY for discrete values or arrays. That means that the key must return a value or array, not\n    // a JSON object.\n    function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);\n    function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);\n    function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);\n    function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);\n    function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);\n    function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);\n    function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);\n    function parseJsonAddressArray(string calldata json, string calldata key)\n        external\n        pure\n        returns (address[] memory);\n    function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);\n    function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);\n    function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);\n    function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);\n    function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);\n    function parseJsonBytes32Array(string calldata json, string calldata key)\n        external\n        pure\n        returns (bytes32[] memory);\n\n    // Checks if a key exists in a JSON or TOML object.\n    function keyExists(string calldata json, string calldata key) external view returns (bool);\n\n    // Returns array of keys for a JSON object\n    function parseJsonKeys(string calldata json, string calldata key) external returns (string[] memory keys);\n\n    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file\n    // It returns the stringified version of the specific JSON file up to that moment.\n    function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    //\n    // writeJson\n    //\n    // ----\n    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    // Let's assume we want to write the following JSON to a file:\n    //\n    // { \"boolean\": true, \"number\": 342, \"object\": { \"title\": \"finally json serialization\" } }\n    //\n    // ```\n    //  string memory json1 = \"some key\";\n    //  vm.serializeBool(json1, \"boolean\", true);\n    //  vm.serializeBool(json1, \"number\", uint256(342));\n    //  json2 = \"some other key\";\n    //  string memory output = vm.serializeString(json2, \"title\", \"finally json serialization\");\n    //  string memory finalJson = vm.serialize(json1, \"object\", output);\n    //  vm.writeJson(finalJson, \"./output/example.json\");\n    // ```\n    // The critical insight is that every invocation of serialization will return the stringified version of the JSON\n    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version\n    // to serialize them as values to another JSON object.\n    //\n    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)\n    // will find the object in-memory that is keyed by \"some key\".\n    function writeJson(string calldata json, string calldata path) external;\n    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>\n    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n    // Returns the RPC url for the given alias\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n    // Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external view returns (string[2][] memory urls);\n    // Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n    // If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n    // Starts recording all map SSTOREs for later retrieval.\n    function startMappingRecording() external;\n    // Stops recording all map SSTOREs for later retrieval and clears the recorded data.\n    function stopMappingRecording() external;\n    // Gets the number of elements in the mapping at the given slot, for a given address.\n    function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);\n    // Gets the elements at index idx of the mapping at the given slot, for a given address. The\n    // index must be less than the length of the mapping (i.e. the number of keys in the mapping).\n    function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);\n    // Gets the map key and parent of a mapping at a given slot, for a given address.\n    function getMappingKeyAndParentOf(address target, bytes32 elementSlot)\n        external\n        returns (bool found, bytes32 key, bytes32 parent);\n    // Writes a breakpoint to jump to in the debugger\n    function breakpoint(string calldata char) external;\n    // Writes a conditional breakpoint to jump to in the debugger\n    function breakpoint(string calldata char, bool value) external;\n    // Suspends execution of the main thread for `duration` milliseconds\n    function sleep(uint256 duration) external;\n}\n\ninterface Vm is VmSafe {\n    // Sets block.timestamp\n    function warp(uint256 newTimestamp) external;\n    // Sets block.height\n    function roll(uint256 newHeight) external;\n    // Sets block.basefee\n    function fee(uint256 newBasefee) external;\n    // Sets block.difficulty\n    // Not available on EVM versions from Paris onwards. Use `prevrandao` instead.\n    // If used on unsupported EVM versions it will revert.\n    function difficulty(uint256 newDifficulty) external;\n    // Sets block.prevrandao\n    // Not available on EVM versions before Paris. Use `difficulty` instead.\n    // If used on unsupported EVM versions it will revert.\n    function prevrandao(bytes32 newPrevrandao) external;\n    // Sets block.chainid\n    function chainId(uint256 newChainId) external;\n    // Sets tx.gasprice\n    function txGasPrice(uint256 newGasPrice) external;\n    // Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address account, uint64 newNonce) external;\n    // Sets the nonce of an account to an arbitrary value\n    function setNonceUnsafe(address account, uint64 newNonce) external;\n    // Resets the nonce of an account to 0 for EOAs and 1 for contract accounts\n    function resetNonce(address account) external;\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address msgSender) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address msgSender) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address msgSender, address txOrigin) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address msgSender, address txOrigin) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification\n    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);\n    // Sets an address' balance\n    function deal(address account, uint256 newBalance) external;\n    // Sets an address' code\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n    // Marks a test as skipped. Must be called at the top of the test.\n    function skip(bool skipTest) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata revertData) external;\n    function expectRevert(bytes4 revertData) external;\n    function expectRevert() external;\n\n    // Prepare an expected log with all four checks enabled.\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data.\n    // Second form also checks supplied address against emitting contract.\n    function expectEmit() external;\n    function expectEmit(address emitter) external;\n\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    // Second form also checks supplied address against emitting contract.\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n    // Reverts a call to an address with specified revert data.\n    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;\n    // Reverts a call to an address with a specific msg.value, with specified revert data.\n    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)\n        external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address callee, bytes calldata data) external;\n    // Expects given number of calls to an address with the specified calldata.\n    function expectCall(address callee, bytes calldata data, uint64 count) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n    // Expects given number of calls to an address with the specified msg.value and calldata\n    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;\n    // Expect a call to an address with the specified msg.value, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\n    // Expects given number of calls to an address with the specified msg.value, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;\n    // Expect a call to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\n    // Expect given number of calls to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)\n        external;\n    // Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the current subcontext. If any other\n    // memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\n    function expectSafeMemory(uint64 min, uint64 max) external;\n    // Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the next created subcontext.\n    // If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\n    // to the set.\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\n    // Sets block.coinbase\n    function coinbase(address newCoinbase) external;\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns (uint256 snapshotId);\n    // Revert the state of the EVM to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,\n    // and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before\n    // the transaction, returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256 blockNumber) external;\n    // Updates the currently active fork to given transaction\n    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block\n    function rollFork(bytes32 txHash) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address account) external;\n    function makePersistent(address account0, address account1) external;\n    function makePersistent(address account0, address account1, address account2) external;\n    function makePersistent(address[] calldata accounts) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address account) external;\n    function revokePersistent(address[] calldata accounts) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address account) external view returns (bool persistent);\n    // In forking mode, explicitly grant the given address cheatcode access\n    function allowCheatcodes(address account) external;\n    // Fetches the given transaction from the active fork and executes it on the current state\n    function transact(bytes32 txHash) external;\n    // Fetches the given transaction from the given fork and executes it on the current state\n    function transact(uint256 forkId, bytes32 txHash) external;\n}\n",
        "license": "MIT"
      },
      "lib/forge-std/src/console.sol": {
        "keccak256": "0x91d5413c2434ca58fd278b6e1e79fd98d10c83931cc2596a6038eee4daeb34ba",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}",
        "license": "MIT"
      },
      "lib/forge-std/src/console2.sol": {
        "keccak256": "0x954646445d1014c3cd85c7918f5e7adeeca5ee44b68c00bafa237e597a4e35ea",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _castLogPayloadViewToPure(\n        function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) internal pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\n    }\n\n    function _sendLogPayloadView(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}",
        "license": "MIT"
      },
      "lib/forge-std/src/interfaces/IMulticall3.sol": {
        "keccak256": "0x7aac1389150499a922d1f9ef5749c908cef127cb2075b92fa17e9cb611263d0a",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n}\n",
        "license": "MIT"
      },
      "lib/forge-std/src/safeconsole.sol": {
        "keccak256": "0xbaf41fdc6c54297e7cd8250e48b0f20eaac918e342a1028cef3f9a52ac086381",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Code generated automatically by script.\nlibrary safeconsole {\n    uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;\n\n    // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)\n    // for the view-to-pure log trick.\n    function _sendLogPayload(uint256 offset, uint256 size) private pure {\n        function(uint256, uint256) internal view fnIn = _sendLogPayloadView;\n        function(uint256, uint256) internal pure pureSendLogPayload;\n        assembly {\n            pureSendLogPayload := fnIn\n        }\n        pureSendLogPayload(offset, size);\n    }\n\n    function _sendLogPayloadView(uint256 offset, uint256 size) private view {\n        assembly {\n            pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))\n        }\n    }\n\n    function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {\n        function(uint256, uint256, uint256) internal view fnIn = _memcopyView;\n        function(uint256, uint256, uint256) internal pure pureMemcopy;\n        assembly {\n            pureMemcopy := fnIn\n        }\n        pureMemcopy(fromOffset, toOffset, length);\n    }\n\n    function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {\n        assembly {\n            pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))\n        }\n    }\n\n    function logMemory(uint256 offset, uint256 length) internal pure {\n        if (offset >= 0x60) {\n            // Sufficient memory before slice to prepare call header.\n            bytes32 m0;\n            bytes32 m1;\n            bytes32 m2;\n            assembly {\n                m0 := mload(sub(offset, 0x60))\n                m1 := mload(sub(offset, 0x40))\n                m2 := mload(sub(offset, 0x20))\n                // Selector of `logBytes(bytes)`.\n                mstore(sub(offset, 0x60), 0xe17bf956)\n                mstore(sub(offset, 0x40), 0x20)\n                mstore(sub(offset, 0x20), length)\n            }\n            _sendLogPayload(offset - 0x44, length + 0x44);\n            assembly {\n                mstore(sub(offset, 0x60), m0)\n                mstore(sub(offset, 0x40), m1)\n                mstore(sub(offset, 0x20), m2)\n            }\n        } else {\n            // Insufficient space, so copy slice forward, add header and reverse.\n            bytes32 m0;\n            bytes32 m1;\n            bytes32 m2;\n            uint256 endOffset = offset + length;\n            assembly {\n                m0 := mload(add(endOffset, 0x00))\n                m1 := mload(add(endOffset, 0x20))\n                m2 := mload(add(endOffset, 0x40))\n            }\n            _memcopy(offset, offset + 0x60, length);\n            assembly {\n                // Selector of `logBytes(bytes)`.\n                mstore(add(offset, 0x00), 0xe17bf956)\n                mstore(add(offset, 0x20), 0x20)\n                mstore(add(offset, 0x40), length)\n            }\n            _sendLogPayload(offset + 0x1c, length + 0x44);\n            _memcopy(offset + 0x60, offset, length);\n            assembly {\n                mstore(add(endOffset, 0x00), m0)\n                mstore(add(endOffset, 0x20), m1)\n                mstore(add(endOffset, 0x40), m2)\n            }\n        }\n    }\n\n    function log(address p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(address)`.\n            mstore(0x00, 0x2c2ecbc2)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(bool p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(bool)`.\n            mstore(0x00, 0x32458eed)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(uint256 p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(uint256)`.\n            mstore(0x00, 0xf82c50f1)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(bytes32 p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(string)`.\n            mstore(0x00, 0x41304fac)\n            mstore(0x20, 0x20)\n            writeString(0x40, p0)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,address)`.\n            mstore(0x00, 0xdaf0d4aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,bool)`.\n            mstore(0x00, 0x75b605d3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,uint256)`.\n            mstore(0x00, 0x8309e8a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,string)`.\n            mstore(0x00, 0x759f86bb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,address)`.\n            mstore(0x00, 0x853c4849)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,bool)`.\n            mstore(0x00, 0x2a110e83)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,uint256)`.\n            mstore(0x00, 0x399174d3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,string)`.\n            mstore(0x00, 0x8feac525)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,address)`.\n            mstore(0x00, 0x69276c86)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,bool)`.\n            mstore(0x00, 0x1c9d7eb3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,uint256)`.\n            mstore(0x00, 0xf666715a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,string)`.\n            mstore(0x00, 0x643fd0df)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,address)`.\n            mstore(0x00, 0x319af333)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,bool)`.\n            mstore(0x00, 0xc3b55635)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,uint256)`.\n            mstore(0x00, 0xb60e72cc)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,string)`.\n            mstore(0x00, 0x4b5c4277)\n            mstore(0x20, 0x40)\n            mstore(0x40, 0x80)\n            writeString(0x60, p0)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,address)`.\n            mstore(0x00, 0x018c84c2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,bool)`.\n            mstore(0x00, 0xf2a66286)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,uint256)`.\n            mstore(0x00, 0x17fe6185)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,address,string)`.\n            mstore(0x00, 0x007150be)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,address)`.\n            mstore(0x00, 0xf11699ed)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,bool)`.\n            mstore(0x00, 0xeb830c92)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,uint256)`.\n            mstore(0x00, 0x9c4f99fb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,bool,string)`.\n            mstore(0x00, 0x212255cc)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,address)`.\n            mstore(0x00, 0x7bc0d848)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,bool)`.\n            mstore(0x00, 0x678209a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,uint256)`.\n            mstore(0x00, 0xb69bcaf6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,uint256,string)`.\n            mstore(0x00, 0xa1f2e8aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,address)`.\n            mstore(0x00, 0xf08744e8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,bool)`.\n            mstore(0x00, 0xcf020fb1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,uint256)`.\n            mstore(0x00, 0x67dd6ff1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(address,string,string)`.\n            mstore(0x00, 0xfb772265)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,address)`.\n            mstore(0x00, 0xd2763667)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,bool)`.\n            mstore(0x00, 0x18c9c746)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,uint256)`.\n            mstore(0x00, 0x5f7b9afb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,address,string)`.\n            mstore(0x00, 0xde9a9270)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,address)`.\n            mstore(0x00, 0x1078f68d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,bool)`.\n            mstore(0x00, 0x50709698)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,uint256)`.\n            mstore(0x00, 0x12f21602)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,bool,string)`.\n            mstore(0x00, 0x2555fa46)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,address)`.\n            mstore(0x00, 0x088ef9d2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,bool)`.\n            mstore(0x00, 0xe8defba9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,uint256)`.\n            mstore(0x00, 0x37103367)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,uint256,string)`.\n            mstore(0x00, 0xc3fc3970)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,address)`.\n            mstore(0x00, 0x9591b953)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,bool)`.\n            mstore(0x00, 0xdbb4c247)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,uint256)`.\n            mstore(0x00, 0x1093ee11)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(bool,string,string)`.\n            mstore(0x00, 0xb076847f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,address)`.\n            mstore(0x00, 0xbcfd9be0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,bool)`.\n            mstore(0x00, 0x9b6ec042)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,uint256)`.\n            mstore(0x00, 0x5a9b5ed5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,address,string)`.\n            mstore(0x00, 0x63cb41f9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,address)`.\n            mstore(0x00, 0x35085f7b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,bool)`.\n            mstore(0x00, 0x20718650)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,uint256)`.\n            mstore(0x00, 0x20098014)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,bool,string)`.\n            mstore(0x00, 0x85775021)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,address)`.\n            mstore(0x00, 0x5c96b331)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,bool)`.\n            mstore(0x00, 0x4766da72)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,uint256)`.\n            mstore(0x00, 0xd1ed7a3c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,uint256,string)`.\n            mstore(0x00, 0x71d04af2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,address)`.\n            mstore(0x00, 0x7afac959)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,bool)`.\n            mstore(0x00, 0x4ceda75a)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,uint256)`.\n            mstore(0x00, 0x37aa7d4c)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(uint256,string,string)`.\n            mstore(0x00, 0xb115611f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,address)`.\n            mstore(0x00, 0xfcec75e0)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,bool)`.\n            mstore(0x00, 0xc91d5ed4)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,uint256)`.\n            mstore(0x00, 0x0d26b925)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,address,string)`.\n            mstore(0x00, 0xe0e9ad4f)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,address)`.\n            mstore(0x00, 0x932bbb38)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,bool)`.\n            mstore(0x00, 0x850b7ad6)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,uint256)`.\n            mstore(0x00, 0xc95958d6)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,bool,string)`.\n            mstore(0x00, 0xe298f47d)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,address)`.\n            mstore(0x00, 0x1c7ec448)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,bool)`.\n            mstore(0x00, 0xca7733b1)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,uint256)`.\n            mstore(0x00, 0xca47c4eb)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,uint256,string)`.\n            mstore(0x00, 0x5970e089)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,address)`.\n            mstore(0x00, 0x95ed0195)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,bool)`.\n            mstore(0x00, 0xb0e0f9b5)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,uint256)`.\n            mstore(0x00, 0x5821efa1)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            // Selector of `log(string,string,string)`.\n            mstore(0x00, 0x2ced7cef)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, 0xe0)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n            writeString(0x100, p2)\n        }\n        _sendLogPayload(0x1c, 0x124);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n        }\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,address)`.\n            mstore(0x00, 0x665bf134)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,bool)`.\n            mstore(0x00, 0x0e378994)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,uint256)`.\n            mstore(0x00, 0x94250d77)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,address,string)`.\n            mstore(0x00, 0xf808da20)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,address)`.\n            mstore(0x00, 0x9f1bc36e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,bool)`.\n            mstore(0x00, 0x2cd4134a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,uint256)`.\n            mstore(0x00, 0x3971e78c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,bool,string)`.\n            mstore(0x00, 0xaa6540c8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,address)`.\n            mstore(0x00, 0x8da6def5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,bool)`.\n            mstore(0x00, 0x9b4254e2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,uint256)`.\n            mstore(0x00, 0xbe553481)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,uint256,string)`.\n            mstore(0x00, 0xfdb4f990)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,address)`.\n            mstore(0x00, 0x8f736d16)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,bool)`.\n            mstore(0x00, 0x6f1a594e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,uint256)`.\n            mstore(0x00, 0xef1cefe7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,address,string,string)`.\n            mstore(0x00, 0x21bdaf25)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,address)`.\n            mstore(0x00, 0x660375dd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,bool)`.\n            mstore(0x00, 0xa6f50b0f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,uint256)`.\n            mstore(0x00, 0xa75c59de)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,address,string)`.\n            mstore(0x00, 0x2dd778e6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,address)`.\n            mstore(0x00, 0xcf394485)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,bool)`.\n            mstore(0x00, 0xcac43479)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,uint256)`.\n            mstore(0x00, 0x8c4e5de6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,bool,string)`.\n            mstore(0x00, 0xdfc4a2e8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,address)`.\n            mstore(0x00, 0xccf790a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,bool)`.\n            mstore(0x00, 0xc4643e20)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,uint256)`.\n            mstore(0x00, 0x386ff5f4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,uint256,string)`.\n            mstore(0x00, 0x0aa6cfad)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,address)`.\n            mstore(0x00, 0x19fd4956)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,bool)`.\n            mstore(0x00, 0x50ad461d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,uint256)`.\n            mstore(0x00, 0x80e6a20b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,bool,string,string)`.\n            mstore(0x00, 0x475c5c33)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,address)`.\n            mstore(0x00, 0x478d1c62)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,bool)`.\n            mstore(0x00, 0xa1bcc9b3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,uint256)`.\n            mstore(0x00, 0x100f650e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,address,string)`.\n            mstore(0x00, 0x1da986ea)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,address)`.\n            mstore(0x00, 0xa31bfdcc)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,bool)`.\n            mstore(0x00, 0x3bf5e537)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,uint256)`.\n            mstore(0x00, 0x22f6b999)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,bool,string)`.\n            mstore(0x00, 0xc5ad85f9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,address)`.\n            mstore(0x00, 0x20e3984d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,bool)`.\n            mstore(0x00, 0x66f1bc67)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,uint256)`.\n            mstore(0x00, 0x34f0e636)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,uint256,string)`.\n            mstore(0x00, 0x4a28c017)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,address)`.\n            mstore(0x00, 0x5c430d47)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,bool)`.\n            mstore(0x00, 0xcf18105c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,uint256)`.\n            mstore(0x00, 0xbf01f891)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,uint256,string,string)`.\n            mstore(0x00, 0x88a8c406)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,address)`.\n            mstore(0x00, 0x0d36fa20)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,bool)`.\n            mstore(0x00, 0x0df12b76)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,uint256)`.\n            mstore(0x00, 0x457fe3cf)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,address,string)`.\n            mstore(0x00, 0xf7e36245)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,address)`.\n            mstore(0x00, 0x205871c2)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,bool)`.\n            mstore(0x00, 0x5f1d5c9f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,uint256)`.\n            mstore(0x00, 0x515e38b6)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,bool,string)`.\n            mstore(0x00, 0xbc0b61fe)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,address)`.\n            mstore(0x00, 0x63183678)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,bool)`.\n            mstore(0x00, 0x0ef7e050)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,uint256)`.\n            mstore(0x00, 0x1dc8e1b8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,uint256,string)`.\n            mstore(0x00, 0x448830a8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,address)`.\n            mstore(0x00, 0xa04e2f87)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,bool)`.\n            mstore(0x00, 0x35a5071f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,uint256)`.\n            mstore(0x00, 0x159f8927)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(address,string,string,string)`.\n            mstore(0x00, 0x5d02c50b)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,address)`.\n            mstore(0x00, 0x1d14d001)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,bool)`.\n            mstore(0x00, 0x46600be0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,uint256)`.\n            mstore(0x00, 0x0c66d1be)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,address,string)`.\n            mstore(0x00, 0xd812a167)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,address)`.\n            mstore(0x00, 0x1c41a336)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,bool)`.\n            mstore(0x00, 0x6a9c478b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,uint256)`.\n            mstore(0x00, 0x07831502)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,bool,string)`.\n            mstore(0x00, 0x4a66cb34)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,address)`.\n            mstore(0x00, 0x136b05dd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,bool)`.\n            mstore(0x00, 0xd6019f1c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,uint256)`.\n            mstore(0x00, 0x7bf181a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,uint256,string)`.\n            mstore(0x00, 0x51f09ff8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,address)`.\n            mstore(0x00, 0x6f7c603e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,bool)`.\n            mstore(0x00, 0xe2bfd60b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,uint256)`.\n            mstore(0x00, 0xc21f64c7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,address,string,string)`.\n            mstore(0x00, 0xa73c1db6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,address)`.\n            mstore(0x00, 0xf4880ea4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,bool)`.\n            mstore(0x00, 0xc0a302d8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,uint256)`.\n            mstore(0x00, 0x4c123d57)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,address,string)`.\n            mstore(0x00, 0xa0a47963)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,address)`.\n            mstore(0x00, 0x8c329b1a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,bool)`.\n            mstore(0x00, 0x3b2a5ce0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,uint256)`.\n            mstore(0x00, 0x6d7045c1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,bool,string)`.\n            mstore(0x00, 0x2ae408d4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,address)`.\n            mstore(0x00, 0x54a7a9a0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,bool)`.\n            mstore(0x00, 0x619e4d0e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,uint256)`.\n            mstore(0x00, 0x0bb00eab)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,uint256,string)`.\n            mstore(0x00, 0x7dd4d0e0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,address)`.\n            mstore(0x00, 0xf9ad2b89)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,bool)`.\n            mstore(0x00, 0xb857163a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,uint256)`.\n            mstore(0x00, 0xe3a9ca2f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,bool,string,string)`.\n            mstore(0x00, 0x6d1e8751)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,address)`.\n            mstore(0x00, 0x26f560a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,bool)`.\n            mstore(0x00, 0xb4c314ff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,uint256)`.\n            mstore(0x00, 0x1537dc87)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,address,string)`.\n            mstore(0x00, 0x1bb3b09a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,address)`.\n            mstore(0x00, 0x9acd3616)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,bool)`.\n            mstore(0x00, 0xceb5f4d7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,uint256)`.\n            mstore(0x00, 0x7f9bbca2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,bool,string)`.\n            mstore(0x00, 0x9143dbb1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,address)`.\n            mstore(0x00, 0x00dd87b9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,bool)`.\n            mstore(0x00, 0xbe984353)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,uint256)`.\n            mstore(0x00, 0x374bb4b2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,uint256,string)`.\n            mstore(0x00, 0x8e69fb5d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,address)`.\n            mstore(0x00, 0xfedd1fff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,bool)`.\n            mstore(0x00, 0xe5e70b2b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,uint256)`.\n            mstore(0x00, 0x6a1199e2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,uint256,string,string)`.\n            mstore(0x00, 0xf5bc2249)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,address)`.\n            mstore(0x00, 0x2b2b18dc)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,bool)`.\n            mstore(0x00, 0x6dd434ca)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,uint256)`.\n            mstore(0x00, 0xa5cada94)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,address,string)`.\n            mstore(0x00, 0x12d6c788)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,address)`.\n            mstore(0x00, 0x538e06ab)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,bool)`.\n            mstore(0x00, 0xdc5e935b)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,uint256)`.\n            mstore(0x00, 0x1606a393)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,bool,string)`.\n            mstore(0x00, 0x483d0416)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,address)`.\n            mstore(0x00, 0x1596a1ce)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,bool)`.\n            mstore(0x00, 0x6b0e5d53)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,uint256)`.\n            mstore(0x00, 0x28863fcb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,uint256,string)`.\n            mstore(0x00, 0x1ad96de6)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,address)`.\n            mstore(0x00, 0x97d394d8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,bool)`.\n            mstore(0x00, 0x1e4b87e5)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,uint256)`.\n            mstore(0x00, 0x7be0c3eb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(bool,string,string,string)`.\n            mstore(0x00, 0x1762e32a)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,address)`.\n            mstore(0x00, 0x2488b414)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,bool)`.\n            mstore(0x00, 0x091ffaf5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,uint256)`.\n            mstore(0x00, 0x736efbb6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,address,string)`.\n            mstore(0x00, 0x031c6f73)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,address)`.\n            mstore(0x00, 0xef72c513)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,bool)`.\n            mstore(0x00, 0xe351140f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,uint256)`.\n            mstore(0x00, 0x5abd992a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,bool,string)`.\n            mstore(0x00, 0x90fb06aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,address)`.\n            mstore(0x00, 0x15c127b5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,bool)`.\n            mstore(0x00, 0x5f743a7c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,uint256)`.\n            mstore(0x00, 0x0c9cd9c1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,uint256,string)`.\n            mstore(0x00, 0xddb06521)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,address)`.\n            mstore(0x00, 0x9cba8fff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,bool)`.\n            mstore(0x00, 0xcc32ab07)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,uint256)`.\n            mstore(0x00, 0x46826b5d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,address,string,string)`.\n            mstore(0x00, 0x3e128ca3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,address)`.\n            mstore(0x00, 0xa1ef4cbb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,bool)`.\n            mstore(0x00, 0x454d54a5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,uint256)`.\n            mstore(0x00, 0x078287f5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,address,string)`.\n            mstore(0x00, 0xade052c7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,address)`.\n            mstore(0x00, 0x69640b59)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,bool)`.\n            mstore(0x00, 0xb6f577a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,uint256)`.\n            mstore(0x00, 0x7464ce23)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,bool,string)`.\n            mstore(0x00, 0xdddb9561)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,address)`.\n            mstore(0x00, 0x88cb6041)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,bool)`.\n            mstore(0x00, 0x91a02e2a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,uint256)`.\n            mstore(0x00, 0xc6acc7a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,uint256,string)`.\n            mstore(0x00, 0xde03e774)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,address)`.\n            mstore(0x00, 0xef529018)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,bool)`.\n            mstore(0x00, 0xeb928d7f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,uint256)`.\n            mstore(0x00, 0x2c1d0746)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,bool,string,string)`.\n            mstore(0x00, 0x68c8b8bd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,address)`.\n            mstore(0x00, 0x56a5d1b1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,bool)`.\n            mstore(0x00, 0x15cac476)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,uint256)`.\n            mstore(0x00, 0x88f6e4b2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,address,string)`.\n            mstore(0x00, 0x6cde40b8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,address)`.\n            mstore(0x00, 0x9a816a83)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,bool)`.\n            mstore(0x00, 0xab085ae6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,uint256)`.\n            mstore(0x00, 0xeb7f6fd2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,bool,string)`.\n            mstore(0x00, 0xa5b4fc99)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,address)`.\n            mstore(0x00, 0xfa8185af)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,bool)`.\n            mstore(0x00, 0xc598d185)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,uint256)`.\n            mstore(0x00, 0x193fb800)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,uint256,string)`.\n            mstore(0x00, 0x59cfcbe3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,address)`.\n            mstore(0x00, 0x42d21db7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,bool)`.\n            mstore(0x00, 0x7af6ab25)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,uint256)`.\n            mstore(0x00, 0x5da297eb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,uint256,string,string)`.\n            mstore(0x00, 0x27d8afd2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,address)`.\n            mstore(0x00, 0x6168ed61)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,bool)`.\n            mstore(0x00, 0x90c30a56)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,uint256)`.\n            mstore(0x00, 0xe8d3018d)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,address,string)`.\n            mstore(0x00, 0x9c3adfa1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,address)`.\n            mstore(0x00, 0xae2ec581)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,bool)`.\n            mstore(0x00, 0xba535d9c)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,uint256)`.\n            mstore(0x00, 0xcf009880)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,bool,string)`.\n            mstore(0x00, 0xd2d423cd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,address)`.\n            mstore(0x00, 0x3b2279b4)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,bool)`.\n            mstore(0x00, 0x691a8f74)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,uint256)`.\n            mstore(0x00, 0x82c25b74)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,uint256,string)`.\n            mstore(0x00, 0xb7b914ca)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,address)`.\n            mstore(0x00, 0xd583c602)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,bool)`.\n            mstore(0x00, 0xb3a6b6bd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,uint256)`.\n            mstore(0x00, 0xb028c9bd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(uint256,string,string,string)`.\n            mstore(0x00, 0x21ad0683)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,address)`.\n            mstore(0x00, 0xed8f28f6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,bool)`.\n            mstore(0x00, 0xb59dbd60)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,uint256)`.\n            mstore(0x00, 0x8ef3f399)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,address,string)`.\n            mstore(0x00, 0x800a1c67)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,address)`.\n            mstore(0x00, 0x223603bd)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,bool)`.\n            mstore(0x00, 0x79884c2b)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,uint256)`.\n            mstore(0x00, 0x3e9f866a)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,bool,string)`.\n            mstore(0x00, 0x0454c079)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,address)`.\n            mstore(0x00, 0x63fb8bc5)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,bool)`.\n            mstore(0x00, 0xfc4845f0)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,uint256)`.\n            mstore(0x00, 0xf8f51b1e)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,uint256,string)`.\n            mstore(0x00, 0x5a477632)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,address)`.\n            mstore(0x00, 0xaabc9a31)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,bool)`.\n            mstore(0x00, 0x5f15d28c)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,uint256)`.\n            mstore(0x00, 0x91d1112e)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,address,string,string)`.\n            mstore(0x00, 0x245986f2)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,address)`.\n            mstore(0x00, 0x33e9dd1d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,bool)`.\n            mstore(0x00, 0x958c28c6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,uint256)`.\n            mstore(0x00, 0x5d08bb05)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,address,string)`.\n            mstore(0x00, 0x2d8e33a4)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,address)`.\n            mstore(0x00, 0x7190a529)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,bool)`.\n            mstore(0x00, 0x895af8c5)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,uint256)`.\n            mstore(0x00, 0x8e3f78a9)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,bool,string)`.\n            mstore(0x00, 0x9d22d5dd)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,address)`.\n            mstore(0x00, 0x935e09bf)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,bool)`.\n            mstore(0x00, 0x8af7cf8a)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,uint256)`.\n            mstore(0x00, 0x64b5bb67)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,uint256,string)`.\n            mstore(0x00, 0x742d6ee7)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,address)`.\n            mstore(0x00, 0xe0625b29)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,bool)`.\n            mstore(0x00, 0x3f8a701d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,uint256)`.\n            mstore(0x00, 0x24f91465)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,bool,string,string)`.\n            mstore(0x00, 0xa826caeb)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,address)`.\n            mstore(0x00, 0x5ea2b7ae)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,bool)`.\n            mstore(0x00, 0x82112a42)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,uint256)`.\n            mstore(0x00, 0x4f04fdc6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,address,string)`.\n            mstore(0x00, 0x9ffb2f93)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,address)`.\n            mstore(0x00, 0xe0e95b98)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,bool)`.\n            mstore(0x00, 0x354c36d6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,uint256)`.\n            mstore(0x00, 0xe41b6f6f)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,bool,string)`.\n            mstore(0x00, 0xabf73a98)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,address)`.\n            mstore(0x00, 0xe21de278)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,bool)`.\n            mstore(0x00, 0x7626db92)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,uint256)`.\n            mstore(0x00, 0xa7a87853)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,uint256,string)`.\n            mstore(0x00, 0x854b3496)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,address)`.\n            mstore(0x00, 0x7c4632a4)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,bool)`.\n            mstore(0x00, 0x7d24491d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,uint256)`.\n            mstore(0x00, 0xc67ea9d1)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,uint256,string,string)`.\n            mstore(0x00, 0x5ab84e1f)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,address)`.\n            mstore(0x00, 0x439c7bef)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,bool)`.\n            mstore(0x00, 0x5ccd4e37)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,uint256)`.\n            mstore(0x00, 0x7cc3c607)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,address,string)`.\n            mstore(0x00, 0xeb1bff80)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,address)`.\n            mstore(0x00, 0xc371c7db)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,bool)`.\n            mstore(0x00, 0x40785869)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,uint256)`.\n            mstore(0x00, 0xd6aefad2)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,bool,string)`.\n            mstore(0x00, 0x5e84b0ea)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,address)`.\n            mstore(0x00, 0x1023f7b2)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,bool)`.\n            mstore(0x00, 0xc3a8a654)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,uint256)`.\n            mstore(0x00, 0xf45d7d2c)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,uint256,string)`.\n            mstore(0x00, 0x5d1a971a)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,address)`.\n            mstore(0x00, 0x6d572f44)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,bool)`.\n            mstore(0x00, 0x2c1754ed)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,uint256)`.\n            mstore(0x00, 0x8eafb02b)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        bytes32 m11;\n        bytes32 m12;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            m11 := mload(0x160)\n            m12 := mload(0x180)\n            // Selector of `log(string,string,string,string)`.\n            mstore(0x00, 0xde68f20a)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, 0x140)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n            writeString(0x160, p3)\n        }\n        _sendLogPayload(0x1c, 0x184);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n            mstore(0x160, m11)\n            mstore(0x180, m12)\n        }\n    }\n}\n",
        "license": "MIT"
      },
      "node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
        "keccak256": "0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n",
        "license": "MIT"
      },
      "node_modules/@openzeppelin/contracts/utils/math/SafeMath.sol": {
        "keccak256": "0x58b21219689909c4f8339af00813760337f7e2e7f169a97fe49e2896dcfb3b9a",
        "urls": [],
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n",
        "license": "MIT"
      },
      "tests/libraries/math/LibPowMath.t.sol": {
        "keccak256": "0x914075595778360c2aca4ee13b4b1fc4a54524655757ad27cf687578e2abe1bc",
        "urls": [],
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Test, console} from \"forge-std/Test.sol\";\nimport \"@solit/contracts/libraries/math/LibPowMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract LibPowMathTest is Test {\n    uint64 public constant PRECISION = 18;\n\n    modifier skipOverflow(\n        uint256 x,\n        uint256 y,\n        uint256 d,\n        uint8 n\n    ) {\n        vm.assume(d != 0);\n        vm.assume(LibPowMath.findMaxExponent(x) <= n);\n        vm.assume(LibPowMath.findMaxExponent(y) <= n);\n        (bool ok, ) = address(this).staticcall(\n            abi.encodeCall(this.unsafePow, (x, y, d, n))\n        );\n        vm.assume(ok);\n        _;\n    }\n\n    /**\n     * @notice Ensures the method {LibPowMath.findMaxExponent} works without reverting.\n     */\n    function test_findMaxExponent(uint256 n) public pure returns (uint256 res) {\n        uint16 e = LibPowMath.findMaxExponent(n);\n        res = n ** uint256(e);\n    }\n\n    /**\n     * @notice Should fail when the exponent k+1.\n     */\n    function testFail_findMaxExponent_ExponentWhenPlus1(\n        uint256 n\n    ) public pure returns (uint256 res) {\n        vm.assume(7132 < n && n < 340282366920938463463374607431768211456);\n        uint16 k = LibPowMath.findMaxExponent(n);\n        res = n ** uint256(k + 1);\n    }\n\n    /**\n     * @notice Gas report for {safeUnutilizedPow}.\n     */\n    function testGas_safeUnutilizedPow(\n        uint256 x,\n        uint256 y,\n        uint256 d,\n        uint8 n\n    ) public view skipOverflow(x, y, d, n) {\n        safeUnutilizedPow(x, y, d, n);\n    }\n\n    /**\n     * @notice Gas report for {LibPowMath.mulDiv}.\n     */\n    function testGas_mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d,\n        uint8 n\n    ) public view skipOverflow(x, y, d, n) {\n        x = 5739;\n        y = 1293;\n        d = 242;\n        n = 21;\n        LibPowMath.mulDiv(x, y, d, n);\n    }\n\n    /**\n     * @notice Gas report for {LibPowMath.mulDivLowPrecision}.\n     */\n    function testGas_mulDivLowPrecision(\n        uint256 x,\n        uint256 y,\n        uint256 d,\n        uint8 n\n    ) public view skipOverflow(x, y, d, n) {\n        LibPowMath.mulDivLowPrecision(x, y, d, n);\n    }\n\n    /**\n     * @notice Gas report for {LibPowMath.unsafePow}.\n     */\n    function testGas_unsafePow(\n        uint256 x,\n        uint256 y,\n        uint256 d,\n        uint8 n\n    ) public view skipOverflow(x, y, d, n) {\n        unsafePow(x, y, d, n);\n    }\n\n    /**\n     * @notice Test the correctness of the mul div method {LibPowMath.mulDiv}.\n     */\n    function test_mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d,\n        uint8 n\n    ) public skipOverflow(x, y, d, n) {\n        uint256 calc = LibPowMath.mulDiv(x, y, d, n);\n        uint256 expt = safeUnutilizedPow(x, y, d, n);\n        assertEq(\n            calc,\n            expt,\n            string.concat(\n                \"Expression: \",\n                vm.toString(x),\n                \"*(\",\n                vm.toString(y),\n                \"/\",\n                vm.toString(d),\n                \")**\",\n                vm.toString(n)\n            )\n        );\n    }\n\n    /**\n     * @notice Helper method to compute scale: x * (y / d) ^ n.\n     */\n    function unsafePow(\n        uint256 x,\n        uint256 y,\n        uint256 d,\n        uint8 n\n    ) public pure returns (uint256 r) {\n        r = x;\n        for (uint256 i = 0; i < n; i++) {\n            r = Math.mulDiv(r, y, d);\n        }\n    }\n\n    /**\n     * @notice Helper method to compute scale: x * (y / d) ^ n.\n     */\n    function safeUnutilizedPow(\n        uint256 x,\n        uint256 y,\n        uint256 d,\n        uint8 n\n    ) public pure returns (uint256 res) {\n        res = x;\n        uint8 ndReverse;\n        while (n > 0) {\n            (bool ok, uint256 res_) = SafeMath.tryMul(res, y);\n            if (!ok) {\n                if (ndReverse > 0) {\n                    res /= d;\n                    ndReverse--;\n                    continue;\n                }\n\n                res_ = Math.mulDiv(res, y, d);\n            } else {\n                ndReverse++;\n            }\n\n            res = res_;\n            n--;\n        }\n\n        while (ndReverse > 0) {\n            res = res / d;\n            ndReverse--;\n        }\n    }\n}\n",
        "license": "UNLICENSED"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 5031,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "stdstore",
        "offset": 0,
        "slot": "0",
        "type": "t_struct(StdStorage)11144_storage"
      },
      {
        "astId": 2766,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "IS_TEST",
        "offset": 0,
        "slot": "7",
        "type": "t_bool"
      },
      {
        "astId": 2768,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "_failed",
        "offset": 1,
        "slot": "7",
        "type": "t_bool"
      },
      {
        "astId": 6486,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "stdChainsInitialized",
        "offset": 2,
        "slot": "7",
        "type": "t_bool"
      },
      {
        "astId": 6507,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "chains",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_string_memory_ptr,t_struct(Chain)6502_storage)"
      },
      {
        "astId": 6511,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "defaultRpcUrls",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_string_memory_ptr,t_string_storage)"
      },
      {
        "astId": 6515,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "idToAlias",
        "offset": 0,
        "slot": "10",
        "type": "t_mapping(t_uint256,t_string_storage)"
      },
      {
        "astId": 6518,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "fallbackToDefaultRpcUrls",
        "offset": 0,
        "slot": "11",
        "type": "t_bool"
      },
      {
        "astId": 7232,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "gasMeteringOff",
        "offset": 1,
        "slot": "11",
        "type": "t_bool"
      },
      {
        "astId": 9269,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "stdstore",
        "offset": 0,
        "slot": "12",
        "type": "t_struct(StdStorage)11144_storage"
      },
      {
        "astId": 10137,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "_excludedContracts",
        "offset": 0,
        "slot": "19",
        "type": "t_array(t_address)dyn_storage"
      },
      {
        "astId": 10140,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "_excludedSenders",
        "offset": 0,
        "slot": "20",
        "type": "t_array(t_address)dyn_storage"
      },
      {
        "astId": 10143,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "_targetedContracts",
        "offset": 0,
        "slot": "21",
        "type": "t_array(t_address)dyn_storage"
      },
      {
        "astId": 10146,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "_targetedSenders",
        "offset": 0,
        "slot": "22",
        "type": "t_array(t_address)dyn_storage"
      },
      {
        "astId": 10149,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "_excludedArtifacts",
        "offset": 0,
        "slot": "23",
        "type": "t_array(t_string_storage)dyn_storage"
      },
      {
        "astId": 10152,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "_targetedArtifacts",
        "offset": 0,
        "slot": "24",
        "type": "t_array(t_string_storage)dyn_storage"
      },
      {
        "astId": 10156,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "_targetedArtifactSelectors",
        "offset": 0,
        "slot": "25",
        "type": "t_array(t_struct(FuzzSelector)10128_storage)dyn_storage"
      },
      {
        "astId": 10160,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "_targetedSelectors",
        "offset": 0,
        "slot": "26",
        "type": "t_array(t_struct(FuzzSelector)10128_storage)dyn_storage"
      },
      {
        "astId": 10164,
        "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
        "label": "_targetedInterfaces",
        "offset": 0,
        "slot": "27",
        "type": "t_array(t_struct(FuzzInterface)10134_storage)dyn_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32",
        "base": "t_address"
      },
      "t_array(t_bytes32)dyn_storage": {
        "encoding": "dynamic_array",
        "label": "bytes32[]",
        "numberOfBytes": "32",
        "base": "t_bytes32"
      },
      "t_array(t_bytes4)dyn_storage": {
        "encoding": "dynamic_array",
        "label": "bytes4[]",
        "numberOfBytes": "32",
        "base": "t_bytes4"
      },
      "t_array(t_string_storage)dyn_storage": {
        "encoding": "dynamic_array",
        "label": "string[]",
        "numberOfBytes": "32",
        "base": "t_string_storage"
      },
      "t_array(t_struct(FuzzInterface)10134_storage)dyn_storage": {
        "encoding": "dynamic_array",
        "label": "struct StdInvariant.FuzzInterface[]",
        "numberOfBytes": "32",
        "base": "t_struct(FuzzInterface)10134_storage"
      },
      "t_array(t_struct(FuzzSelector)10128_storage)dyn_storage": {
        "encoding": "dynamic_array",
        "label": "struct StdInvariant.FuzzSelector[]",
        "numberOfBytes": "32",
        "base": "t_struct(FuzzSelector)10128_storage"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_bytes4": {
        "encoding": "inplace",
        "label": "bytes4",
        "numberOfBytes": "4"
      },
      "t_mapping(t_address,t_mapping(t_bytes4,t_mapping(t_bytes32,t_bool)))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(bytes4 => mapping(bytes32 => bool)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes4,t_mapping(t_bytes32,t_bool))"
      },
      "t_mapping(t_address,t_mapping(t_bytes4,t_mapping(t_bytes32,t_uint256)))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(bytes4 => mapping(bytes32 => uint256)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes4,t_mapping(t_bytes32,t_uint256))"
      },
      "t_mapping(t_bytes32,t_bool)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes4,t_mapping(t_bytes32,t_bool))": {
        "encoding": "mapping",
        "key": "t_bytes4",
        "label": "mapping(bytes4 => mapping(bytes32 => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_bool)"
      },
      "t_mapping(t_bytes4,t_mapping(t_bytes32,t_uint256))": {
        "encoding": "mapping",
        "key": "t_bytes4",
        "label": "mapping(bytes4 => mapping(bytes32 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_uint256)"
      },
      "t_mapping(t_string_memory_ptr,t_string_storage)": {
        "encoding": "mapping",
        "key": "t_string_memory_ptr",
        "label": "mapping(string => string)",
        "numberOfBytes": "32",
        "value": "t_string_storage"
      },
      "t_mapping(t_string_memory_ptr,t_struct(Chain)6502_storage)": {
        "encoding": "mapping",
        "key": "t_string_memory_ptr",
        "label": "mapping(string => struct StdChains.Chain)",
        "numberOfBytes": "32",
        "value": "t_struct(Chain)6502_storage"
      },
      "t_mapping(t_uint256,t_string_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => string)",
        "numberOfBytes": "32",
        "value": "t_string_storage"
      },
      "t_string_memory_ptr": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Chain)6502_storage": {
        "encoding": "inplace",
        "label": "struct StdChains.Chain",
        "numberOfBytes": "128",
        "members": [
          {
            "astId": 6495,
            "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
            "label": "name",
            "offset": 0,
            "slot": "0",
            "type": "t_string_storage"
          },
          {
            "astId": 6497,
            "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
            "label": "chainId",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 6499,
            "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
            "label": "chainAlias",
            "offset": 0,
            "slot": "2",
            "type": "t_string_storage"
          },
          {
            "astId": 6501,
            "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
            "label": "rpcUrl",
            "offset": 0,
            "slot": "3",
            "type": "t_string_storage"
          }
        ]
      },
      "t_struct(FuzzInterface)10134_storage": {
        "encoding": "inplace",
        "label": "struct StdInvariant.FuzzInterface",
        "numberOfBytes": "64",
        "members": [
          {
            "astId": 10130,
            "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
            "label": "addr",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 10133,
            "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
            "label": "artifacts",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_string_storage)dyn_storage"
          }
        ]
      },
      "t_struct(FuzzSelector)10128_storage": {
        "encoding": "inplace",
        "label": "struct StdInvariant.FuzzSelector",
        "numberOfBytes": "64",
        "members": [
          {
            "astId": 10124,
            "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
            "label": "addr",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 10127,
            "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
            "label": "selectors",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_bytes4)dyn_storage"
          }
        ]
      },
      "t_struct(StdStorage)11144_storage": {
        "encoding": "inplace",
        "label": "struct StdStorage",
        "numberOfBytes": "224",
        "members": [
          {
            "astId": 11124,
            "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
            "label": "slots",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_mapping(t_bytes4,t_mapping(t_bytes32,t_uint256)))"
          },
          {
            "astId": 11132,
            "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
            "label": "finds",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_address,t_mapping(t_bytes4,t_mapping(t_bytes32,t_bool)))"
          },
          {
            "astId": 11135,
            "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
            "label": "_keys",
            "offset": 0,
            "slot": "2",
            "type": "t_array(t_bytes32)dyn_storage"
          },
          {
            "astId": 11137,
            "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
            "label": "_sig",
            "offset": 0,
            "slot": "3",
            "type": "t_bytes4"
          },
          {
            "astId": 11139,
            "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
            "label": "_depth",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 11141,
            "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
            "label": "_target",
            "offset": 0,
            "slot": "5",
            "type": "t_address"
          },
          {
            "astId": 11143,
            "contract": "tests/libraries/math/LibPowMath.t.sol:LibPowMathTest",
            "label": "_set",
            "offset": 0,
            "slot": "6",
            "type": "t_bytes32"
          }
        ]
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  },
  "userdoc": {
    "version": 1,
    "kind": "user",
    "methods": {
      "safeUnutilizedPow(uint256,uint256,uint256,uint8)": {
        "notice": "Helper method to compute scale: x * (y / d) ^ n."
      },
      "testFail_findMaxExponent_ExponentWhenPlus1(uint256)": {
        "notice": "Should fail when the exponent k+1."
      },
      "testGas_mulDiv(uint256,uint256,uint256,uint8)": {
        "notice": "Gas report for {LibPowMath.mulDiv}."
      },
      "testGas_mulDivLowPrecision(uint256,uint256,uint256,uint8)": {
        "notice": "Gas report for {LibPowMath.mulDivLowPrecision}."
      },
      "testGas_safeUnutilizedPow(uint256,uint256,uint256,uint8)": {
        "notice": "Gas report for {safeUnutilizedPow}."
      },
      "testGas_unsafePow(uint256,uint256,uint256,uint8)": {
        "notice": "Gas report for {LibPowMath.unsafePow}."
      },
      "test_findMaxExponent(uint256)": {
        "notice": "Ensures the method {LibPowMath.findMaxExponent} works without reverting."
      },
      "test_mulDiv(uint256,uint256,uint256,uint8)": {
        "notice": "Test the correctness of the mul div method {LibPowMath.mulDiv}."
      },
      "unsafePow(uint256,uint256,uint256,uint8)": {
        "notice": "Helper method to compute scale: x * (y / d) ^ n."
      }
    }
  },
  "devdoc": {
    "version": 1,
    "kind": "dev"
  },
  "ast": {
    "absolutePath": "tests/libraries/math/LibPowMath.t.sol",
    "id": 51626,
    "exportedSymbols": {
      "LibPowMath": [
        2098
      ],
      "LibPowMathTest": [
        51625
      ],
      "Math": [
        50849
      ],
      "SafeMath": [
        51161
      ],
      "Test": [
        14893
      ],
      "console": [
        24659
      ]
    },
    "nodeType": "SourceUnit",
    "src": "39:4307:52",
    "nodes": [
      {
        "id": 51163,
        "nodeType": "PragmaDirective",
        "src": "39:24:52",
        "nodes": [],
        "literals": [
          "solidity",
          "^",
          "0.8",
          ".13"
        ]
      },
      {
        "id": 51166,
        "nodeType": "ImportDirective",
        "src": "65:49:52",
        "nodes": [],
        "absolutePath": "lib/forge-std/src/Test.sol",
        "file": "forge-std/Test.sol",
        "nameLocation": "-1:-1:-1",
        "scope": 51626,
        "sourceUnit": 14894,
        "symbolAliases": [
          {
            "foreign": {
              "id": 51164,
              "name": "Test",
              "nodeType": "Identifier",
              "overloadedDeclarations": [],
              "referencedDeclaration": 14893,
              "src": "73:4:52",
              "typeDescriptions": {}
            },
            "nameLocation": "-1:-1:-1"
          },
          {
            "foreign": {
              "id": 51165,
              "name": "console",
              "nodeType": "Identifier",
              "overloadedDeclarations": [],
              "referencedDeclaration": 24659,
              "src": "79:7:52",
              "typeDescriptions": {}
            },
            "nameLocation": "-1:-1:-1"
          }
        ],
        "unitAlias": ""
      },
      {
        "id": 51167,
        "nodeType": "ImportDirective",
        "src": "115:56:52",
        "nodes": [],
        "absolutePath": "contracts/libraries/math/LibPowMath.sol",
        "file": "@solit/contracts/libraries/math/LibPowMath.sol",
        "nameLocation": "-1:-1:-1",
        "scope": 51626,
        "sourceUnit": 2099,
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "id": 51168,
        "nodeType": "ImportDirective",
        "src": "172:53:52",
        "nodes": [],
        "absolutePath": "node_modules/@openzeppelin/contracts/utils/math/Math.sol",
        "file": "@openzeppelin/contracts/utils/math/Math.sol",
        "nameLocation": "-1:-1:-1",
        "scope": 51626,
        "sourceUnit": 50850,
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "id": 51169,
        "nodeType": "ImportDirective",
        "src": "226:57:52",
        "nodes": [],
        "absolutePath": "node_modules/@openzeppelin/contracts/utils/math/SafeMath.sol",
        "file": "@openzeppelin/contracts/utils/math/SafeMath.sol",
        "nameLocation": "-1:-1:-1",
        "scope": 51626,
        "sourceUnit": 51162,
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "id": 51625,
        "nodeType": "ContractDefinition",
        "src": "285:4060:52",
        "nodes": [
          {
            "id": 51174,
            "nodeType": "VariableDeclaration",
            "src": "323:37:52",
            "nodes": [],
            "constant": true,
            "functionSelector": "aaf5eb68",
            "mutability": "constant",
            "name": "PRECISION",
            "nameLocation": "346:9:52",
            "scope": 51625,
            "stateVariable": true,
            "storageLocation": "default",
            "typeDescriptions": {
              "typeIdentifier": "t_uint64",
              "typeString": "uint64"
            },
            "typeName": {
              "id": 51172,
              "name": "uint64",
              "nodeType": "ElementaryTypeName",
              "src": "323:6:52",
              "typeDescriptions": {
                "typeIdentifier": "t_uint64",
                "typeString": "uint64"
              }
            },
            "value": {
              "hexValue": "3138",
              "id": 51173,
              "isConstant": false,
              "isLValue": false,
              "isPure": true,
              "kind": "number",
              "lValueRequested": false,
              "nodeType": "Literal",
              "src": "358:2:52",
              "typeDescriptions": {
                "typeIdentifier": "t_rational_18_by_1",
                "typeString": "int_const 18"
              },
              "value": "18"
            },
            "visibility": "public"
          },
          {
            "id": 51241,
            "nodeType": "ModifierDefinition",
            "src": "367:396:52",
            "nodes": [],
            "body": {
              "id": 51240,
              "nodeType": "Block",
              "src": "469:294:52",
              "nodes": [],
              "statements": [
                {
                  "expression": {
                    "arguments": [
                      {
                        "commonType": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        "id": 51189,
                        "isConstant": false,
                        "isLValue": false,
                        "isPure": false,
                        "lValueRequested": false,
                        "leftExpression": {
                          "id": 51187,
                          "name": "d",
                          "nodeType": "Identifier",
                          "overloadedDeclarations": [],
                          "referencedDeclaration": 51180,
                          "src": "489:1:52",
                          "typeDescriptions": {
                            "typeIdentifier": "t_uint256",
                            "typeString": "uint256"
                          }
                        },
                        "nodeType": "BinaryOperation",
                        "operator": "!=",
                        "rightExpression": {
                          "hexValue": "30",
                          "id": 51188,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": true,
                          "kind": "number",
                          "lValueRequested": false,
                          "nodeType": "Literal",
                          "src": "494:1:52",
                          "typeDescriptions": {
                            "typeIdentifier": "t_rational_0_by_1",
                            "typeString": "int_const 0"
                          },
                          "value": "0"
                        },
                        "src": "489:6:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_bool",
                          "typeString": "bool"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_bool",
                          "typeString": "bool"
                        }
                      ],
                      "expression": {
                        "id": 51184,
                        "name": "vm",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 5028,
                        "src": "479:2:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_contract$_Vm_$16595",
                          "typeString": "contract Vm"
                        }
                      },
                      "id": 51186,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberLocation": "482:6:52",
                      "memberName": "assume",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 16060,
                      "src": "479:9:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_external_pure$_t_bool_$returns$__$",
                        "typeString": "function (bool) pure external"
                      }
                    },
                    "id": 51190,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "nameLocations": [],
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "479:17:52",
                    "tryCall": false,
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$__$",
                      "typeString": "tuple()"
                    }
                  },
                  "id": 51191,
                  "nodeType": "ExpressionStatement",
                  "src": "479:17:52"
                },
                {
                  "expression": {
                    "arguments": [
                      {
                        "commonType": {
                          "typeIdentifier": "t_uint16",
                          "typeString": "uint16"
                        },
                        "id": 51200,
                        "isConstant": false,
                        "isLValue": false,
                        "isPure": false,
                        "lValueRequested": false,
                        "leftExpression": {
                          "arguments": [
                            {
                              "id": 51197,
                              "name": "x",
                              "nodeType": "Identifier",
                              "overloadedDeclarations": [],
                              "referencedDeclaration": 51176,
                              "src": "543:1:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_uint256",
                                "typeString": "uint256"
                              }
                            }
                          ],
                          "expression": {
                            "argumentTypes": [
                              {
                                "typeIdentifier": "t_uint256",
                                "typeString": "uint256"
                              }
                            ],
                            "expression": {
                              "id": 51195,
                              "name": "LibPowMath",
                              "nodeType": "Identifier",
                              "overloadedDeclarations": [],
                              "referencedDeclaration": 2098,
                              "src": "516:10:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_type$_t_contract$_LibPowMath_$2098_$",
                                "typeString": "type(library LibPowMath)"
                              }
                            },
                            "id": 51196,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": false,
                            "lValueRequested": false,
                            "memberLocation": "527:15:52",
                            "memberName": "findMaxExponent",
                            "nodeType": "MemberAccess",
                            "referencedDeclaration": 2097,
                            "src": "516:26:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_function_internal_pure$_t_uint256_$returns$_t_uint16_$",
                              "typeString": "function (uint256) pure returns (uint16)"
                            }
                          },
                          "id": 51198,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": false,
                          "kind": "functionCall",
                          "lValueRequested": false,
                          "nameLocations": [],
                          "names": [],
                          "nodeType": "FunctionCall",
                          "src": "516:29:52",
                          "tryCall": false,
                          "typeDescriptions": {
                            "typeIdentifier": "t_uint16",
                            "typeString": "uint16"
                          }
                        },
                        "nodeType": "BinaryOperation",
                        "operator": "<=",
                        "rightExpression": {
                          "id": 51199,
                          "name": "n",
                          "nodeType": "Identifier",
                          "overloadedDeclarations": [],
                          "referencedDeclaration": 51182,
                          "src": "549:1:52",
                          "typeDescriptions": {
                            "typeIdentifier": "t_uint8",
                            "typeString": "uint8"
                          }
                        },
                        "src": "516:34:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_bool",
                          "typeString": "bool"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_bool",
                          "typeString": "bool"
                        }
                      ],
                      "expression": {
                        "id": 51192,
                        "name": "vm",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 5028,
                        "src": "506:2:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_contract$_Vm_$16595",
                          "typeString": "contract Vm"
                        }
                      },
                      "id": 51194,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberLocation": "509:6:52",
                      "memberName": "assume",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 16060,
                      "src": "506:9:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_external_pure$_t_bool_$returns$__$",
                        "typeString": "function (bool) pure external"
                      }
                    },
                    "id": 51201,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "nameLocations": [],
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "506:45:52",
                    "tryCall": false,
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$__$",
                      "typeString": "tuple()"
                    }
                  },
                  "id": 51202,
                  "nodeType": "ExpressionStatement",
                  "src": "506:45:52"
                },
                {
                  "expression": {
                    "arguments": [
                      {
                        "commonType": {
                          "typeIdentifier": "t_uint16",
                          "typeString": "uint16"
                        },
                        "id": 51211,
                        "isConstant": false,
                        "isLValue": false,
                        "isPure": false,
                        "lValueRequested": false,
                        "leftExpression": {
                          "arguments": [
                            {
                              "id": 51208,
                              "name": "y",
                              "nodeType": "Identifier",
                              "overloadedDeclarations": [],
                              "referencedDeclaration": 51178,
                              "src": "598:1:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_uint256",
                                "typeString": "uint256"
                              }
                            }
                          ],
                          "expression": {
                            "argumentTypes": [
                              {
                                "typeIdentifier": "t_uint256",
                                "typeString": "uint256"
                              }
                            ],
                            "expression": {
                              "id": 51206,
                              "name": "LibPowMath",
                              "nodeType": "Identifier",
                              "overloadedDeclarations": [],
                              "referencedDeclaration": 2098,
                              "src": "571:10:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_type$_t_contract$_LibPowMath_$2098_$",
                                "typeString": "type(library LibPowMath)"
                              }
                            },
                            "id": 51207,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": false,
                            "lValueRequested": false,
                            "memberLocation": "582:15:52",
                            "memberName": "findMaxExponent",
                            "nodeType": "MemberAccess",
                            "referencedDeclaration": 2097,
                            "src": "571:26:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_function_internal_pure$_t_uint256_$returns$_t_uint16_$",
                              "typeString": "function (uint256) pure returns (uint16)"
                            }
                          },
                          "id": 51209,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": false,
                          "kind": "functionCall",
                          "lValueRequested": false,
                          "nameLocations": [],
                          "names": [],
                          "nodeType": "FunctionCall",
                          "src": "571:29:52",
                          "tryCall": false,
                          "typeDescriptions": {
                            "typeIdentifier": "t_uint16",
                            "typeString": "uint16"
                          }
                        },
                        "nodeType": "BinaryOperation",
                        "operator": "<=",
                        "rightExpression": {
                          "id": 51210,
                          "name": "n",
                          "nodeType": "Identifier",
                          "overloadedDeclarations": [],
                          "referencedDeclaration": 51182,
                          "src": "604:1:52",
                          "typeDescriptions": {
                            "typeIdentifier": "t_uint8",
                            "typeString": "uint8"
                          }
                        },
                        "src": "571:34:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_bool",
                          "typeString": "bool"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_bool",
                          "typeString": "bool"
                        }
                      ],
                      "expression": {
                        "id": 51203,
                        "name": "vm",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 5028,
                        "src": "561:2:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_contract$_Vm_$16595",
                          "typeString": "contract Vm"
                        }
                      },
                      "id": 51205,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberLocation": "564:6:52",
                      "memberName": "assume",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 16060,
                      "src": "561:9:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_external_pure$_t_bool_$returns$__$",
                        "typeString": "function (bool) pure external"
                      }
                    },
                    "id": 51212,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "nameLocations": [],
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "561:45:52",
                    "tryCall": false,
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$__$",
                      "typeString": "tuple()"
                    }
                  },
                  "id": 51213,
                  "nodeType": "ExpressionStatement",
                  "src": "561:45:52"
                },
                {
                  "assignments": [
                    51215,
                    null
                  ],
                  "declarations": [
                    {
                      "constant": false,
                      "id": 51215,
                      "mutability": "mutable",
                      "name": "ok",
                      "nameLocation": "622:2:52",
                      "nodeType": "VariableDeclaration",
                      "scope": 51240,
                      "src": "617:7:52",
                      "stateVariable": false,
                      "storageLocation": "default",
                      "typeDescriptions": {
                        "typeIdentifier": "t_bool",
                        "typeString": "bool"
                      },
                      "typeName": {
                        "id": 51214,
                        "name": "bool",
                        "nodeType": "ElementaryTypeName",
                        "src": "617:4:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_bool",
                          "typeString": "bool"
                        }
                      },
                      "visibility": "internal"
                    },
                    null
                  ],
                  "id": 51232,
                  "initialValue": {
                    "arguments": [
                      {
                        "arguments": [
                          {
                            "expression": {
                              "id": 51223,
                              "name": "this",
                              "nodeType": "Identifier",
                              "overloadedDeclarations": [],
                              "referencedDeclaration": -28,
                              "src": "683:4:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_contract$_LibPowMathTest_$51625",
                                "typeString": "contract LibPowMathTest"
                              }
                            },
                            "id": 51224,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": false,
                            "lValueRequested": false,
                            "memberLocation": "688:9:52",
                            "memberName": "unsafePow",
                            "nodeType": "MemberAccess",
                            "referencedDeclaration": 51536,
                            "src": "683:14:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_function_external_pure$_t_uint256_$_t_uint256_$_t_uint256_$_t_uint8_$returns$_t_uint256_$",
                              "typeString": "function (uint256,uint256,uint256,uint8) pure external returns (uint256)"
                            }
                          },
                          {
                            "components": [
                              {
                                "id": 51225,
                                "name": "x",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 51176,
                                "src": "700:1:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                }
                              },
                              {
                                "id": 51226,
                                "name": "y",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 51178,
                                "src": "703:1:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                }
                              },
                              {
                                "id": 51227,
                                "name": "d",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 51180,
                                "src": "706:1:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                }
                              },
                              {
                                "id": 51228,
                                "name": "n",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 51182,
                                "src": "709:1:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_uint8",
                                  "typeString": "uint8"
                                }
                              }
                            ],
                            "id": 51229,
                            "isConstant": false,
                            "isInlineArray": false,
                            "isLValue": false,
                            "isPure": false,
                            "lValueRequested": false,
                            "nodeType": "TupleExpression",
                            "src": "699:12:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_tuple$_t_uint256_$_t_uint256_$_t_uint256_$_t_uint8_$",
                              "typeString": "tuple(uint256,uint256,uint256,uint8)"
                            }
                          }
                        ],
                        "expression": {
                          "argumentTypes": [
                            {
                              "typeIdentifier": "t_function_external_pure$_t_uint256_$_t_uint256_$_t_uint256_$_t_uint8_$returns$_t_uint256_$",
                              "typeString": "function (uint256,uint256,uint256,uint8) pure external returns (uint256)"
                            },
                            {
                              "typeIdentifier": "t_tuple$_t_uint256_$_t_uint256_$_t_uint256_$_t_uint8_$",
                              "typeString": "tuple(uint256,uint256,uint256,uint8)"
                            }
                          ],
                          "expression": {
                            "id": 51221,
                            "name": "abi",
                            "nodeType": "Identifier",
                            "overloadedDeclarations": [],
                            "referencedDeclaration": -1,
                            "src": "668:3:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_magic_abi",
                              "typeString": "abi"
                            }
                          },
                          "id": 51222,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": true,
                          "lValueRequested": false,
                          "memberLocation": "672:10:52",
                          "memberName": "encodeCall",
                          "nodeType": "MemberAccess",
                          "src": "668:14:52",
                          "typeDescriptions": {
                            "typeIdentifier": "t_function_abiencodecall_pure$__$returns$_t_bytes_memory_ptr_$",
                            "typeString": "function () pure returns (bytes memory)"
                          }
                        },
                        "id": 51230,
                        "isConstant": false,
                        "isLValue": false,
                        "isPure": false,
                        "kind": "functionCall",
                        "lValueRequested": false,
                        "nameLocations": [],
                        "names": [],
                        "nodeType": "FunctionCall",
                        "src": "668:44:52",
                        "tryCall": false,
                        "typeDescriptions": {
                          "typeIdentifier": "t_bytes_memory_ptr",
                          "typeString": "bytes memory"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_bytes_memory_ptr",
                          "typeString": "bytes memory"
                        }
                      ],
                      "expression": {
                        "arguments": [
                          {
                            "id": 51218,
                            "name": "this",
                            "nodeType": "Identifier",
                            "overloadedDeclarations": [],
                            "referencedDeclaration": -28,
                            "src": "638:4:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_contract$_LibPowMathTest_$51625",
                              "typeString": "contract LibPowMathTest"
                            }
                          }
                        ],
                        "expression": {
                          "argumentTypes": [
                            {
                              "typeIdentifier": "t_contract$_LibPowMathTest_$51625",
                              "typeString": "contract LibPowMathTest"
                            }
                          ],
                          "id": 51217,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": true,
                          "lValueRequested": false,
                          "nodeType": "ElementaryTypeNameExpression",
                          "src": "630:7:52",
                          "typeDescriptions": {
                            "typeIdentifier": "t_type$_t_address_$",
                            "typeString": "type(address)"
                          },
                          "typeName": {
                            "id": 51216,
                            "name": "address",
                            "nodeType": "ElementaryTypeName",
                            "src": "630:7:52",
                            "typeDescriptions": {}
                          }
                        },
                        "id": 51219,
                        "isConstant": false,
                        "isLValue": false,
                        "isPure": false,
                        "kind": "typeConversion",
                        "lValueRequested": false,
                        "nameLocations": [],
                        "names": [],
                        "nodeType": "FunctionCall",
                        "src": "630:13:52",
                        "tryCall": false,
                        "typeDescriptions": {
                          "typeIdentifier": "t_address",
                          "typeString": "address"
                        }
                      },
                      "id": 51220,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberLocation": "644:10:52",
                      "memberName": "staticcall",
                      "nodeType": "MemberAccess",
                      "src": "630:24:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_barestaticcall_view$_t_bytes_memory_ptr_$returns$_t_bool_$_t_bytes_memory_ptr_$",
                        "typeString": "function (bytes memory) view returns (bool,bytes memory)"
                      }
                    },
                    "id": 51231,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "nameLocations": [],
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "630:92:52",
                    "tryCall": false,
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$_t_bool_$_t_bytes_memory_ptr_$",
                      "typeString": "tuple(bool,bytes memory)"
                    }
                  },
                  "nodeType": "VariableDeclarationStatement",
                  "src": "616:106:52"
                },
                {
                  "expression": {
                    "arguments": [
                      {
                        "id": 51236,
                        "name": "ok",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51215,
                        "src": "742:2:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_bool",
                          "typeString": "bool"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_bool",
                          "typeString": "bool"
                        }
                      ],
                      "expression": {
                        "id": 51233,
                        "name": "vm",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 5028,
                        "src": "732:2:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_contract$_Vm_$16595",
                          "typeString": "contract Vm"
                        }
                      },
                      "id": 51235,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberLocation": "735:6:52",
                      "memberName": "assume",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 16060,
                      "src": "732:9:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_external_pure$_t_bool_$returns$__$",
                        "typeString": "function (bool) pure external"
                      }
                    },
                    "id": 51237,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "nameLocations": [],
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "732:13:52",
                    "tryCall": false,
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$__$",
                      "typeString": "tuple()"
                    }
                  },
                  "id": 51238,
                  "nodeType": "ExpressionStatement",
                  "src": "732:13:52"
                },
                {
                  "id": 51239,
                  "nodeType": "PlaceholderStatement",
                  "src": "755:1:52"
                }
              ]
            },
            "name": "skipOverflow",
            "nameLocation": "376:12:52",
            "parameters": {
              "id": 51183,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 51176,
                  "mutability": "mutable",
                  "name": "x",
                  "nameLocation": "406:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51241,
                  "src": "398:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51175,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "398:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51178,
                  "mutability": "mutable",
                  "name": "y",
                  "nameLocation": "425:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51241,
                  "src": "417:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51177,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "417:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51180,
                  "mutability": "mutable",
                  "name": "d",
                  "nameLocation": "444:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51241,
                  "src": "436:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51179,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "436:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51182,
                  "mutability": "mutable",
                  "name": "n",
                  "nameLocation": "461:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51241,
                  "src": "455:7:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint8",
                    "typeString": "uint8"
                  },
                  "typeName": {
                    "id": 51181,
                    "name": "uint8",
                    "nodeType": "ElementaryTypeName",
                    "src": "455:5:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "388:80:52"
            },
            "virtual": false,
            "visibility": "internal"
          },
          {
            "id": 51266,
            "nodeType": "FunctionDefinition",
            "src": "873:163:52",
            "nodes": [],
            "body": {
              "id": 51265,
              "nodeType": "Block",
              "src": "948:88:52",
              "nodes": [],
              "statements": [
                {
                  "assignments": [
                    51250
                  ],
                  "declarations": [
                    {
                      "constant": false,
                      "id": 51250,
                      "mutability": "mutable",
                      "name": "e",
                      "nameLocation": "965:1:52",
                      "nodeType": "VariableDeclaration",
                      "scope": 51265,
                      "src": "958:8:52",
                      "stateVariable": false,
                      "storageLocation": "default",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint16",
                        "typeString": "uint16"
                      },
                      "typeName": {
                        "id": 51249,
                        "name": "uint16",
                        "nodeType": "ElementaryTypeName",
                        "src": "958:6:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint16",
                          "typeString": "uint16"
                        }
                      },
                      "visibility": "internal"
                    }
                  ],
                  "id": 51255,
                  "initialValue": {
                    "arguments": [
                      {
                        "id": 51253,
                        "name": "n",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51244,
                        "src": "996:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      ],
                      "expression": {
                        "id": 51251,
                        "name": "LibPowMath",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 2098,
                        "src": "969:10:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_type$_t_contract$_LibPowMath_$2098_$",
                          "typeString": "type(library LibPowMath)"
                        }
                      },
                      "id": 51252,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberLocation": "980:15:52",
                      "memberName": "findMaxExponent",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 2097,
                      "src": "969:26:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_pure$_t_uint256_$returns$_t_uint16_$",
                        "typeString": "function (uint256) pure returns (uint16)"
                      }
                    },
                    "id": 51254,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "nameLocations": [],
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "969:29:52",
                    "tryCall": false,
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint16",
                      "typeString": "uint16"
                    }
                  },
                  "nodeType": "VariableDeclarationStatement",
                  "src": "958:40:52"
                },
                {
                  "expression": {
                    "id": 51263,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftHandSide": {
                      "id": 51256,
                      "name": "res",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51247,
                      "src": "1008:3:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "nodeType": "Assignment",
                    "operator": "=",
                    "rightHandSide": {
                      "commonType": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      },
                      "id": 51262,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "leftExpression": {
                        "id": 51257,
                        "name": "n",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51244,
                        "src": "1014:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      "nodeType": "BinaryOperation",
                      "operator": "**",
                      "rightExpression": {
                        "arguments": [
                          {
                            "id": 51260,
                            "name": "e",
                            "nodeType": "Identifier",
                            "overloadedDeclarations": [],
                            "referencedDeclaration": 51250,
                            "src": "1027:1:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_uint16",
                              "typeString": "uint16"
                            }
                          }
                        ],
                        "expression": {
                          "argumentTypes": [
                            {
                              "typeIdentifier": "t_uint16",
                              "typeString": "uint16"
                            }
                          ],
                          "id": 51259,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": true,
                          "lValueRequested": false,
                          "nodeType": "ElementaryTypeNameExpression",
                          "src": "1019:7:52",
                          "typeDescriptions": {
                            "typeIdentifier": "t_type$_t_uint256_$",
                            "typeString": "type(uint256)"
                          },
                          "typeName": {
                            "id": 51258,
                            "name": "uint256",
                            "nodeType": "ElementaryTypeName",
                            "src": "1019:7:52",
                            "typeDescriptions": {}
                          }
                        },
                        "id": 51261,
                        "isConstant": false,
                        "isLValue": false,
                        "isPure": false,
                        "kind": "typeConversion",
                        "lValueRequested": false,
                        "nameLocations": [],
                        "names": [],
                        "nodeType": "FunctionCall",
                        "src": "1019:10:52",
                        "tryCall": false,
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      "src": "1014:15:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "src": "1008:21:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 51264,
                  "nodeType": "ExpressionStatement",
                  "src": "1008:21:52"
                }
              ]
            },
            "documentation": {
              "id": 51242,
              "nodeType": "StructuredDocumentation",
              "src": "769:99:52",
              "text": " @notice Ensures the method {LibPowMath.findMaxExponent} works without reverting."
            },
            "functionSelector": "1b7188a7",
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "test_findMaxExponent",
            "nameLocation": "882:20:52",
            "parameters": {
              "id": 51245,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 51244,
                  "mutability": "mutable",
                  "name": "n",
                  "nameLocation": "911:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51266,
                  "src": "903:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51243,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "903:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "902:11:52"
            },
            "returnParameters": {
              "id": 51248,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 51247,
                  "mutability": "mutable",
                  "name": "res",
                  "nameLocation": "943:3:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51266,
                  "src": "935:11:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51246,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "935:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "934:13:52"
            },
            "scope": 51625,
            "stateMutability": "pure",
            "virtual": false,
            "visibility": "public"
          },
          {
            "id": 51305,
            "nodeType": "FunctionDefinition",
            "src": "1108:279:52",
            "nodes": [],
            "body": {
              "id": 51304,
              "nodeType": "Block",
              "src": "1219:168:52",
              "nodes": [],
              "statements": [
                {
                  "expression": {
                    "arguments": [
                      {
                        "commonType": {
                          "typeIdentifier": "t_bool",
                          "typeString": "bool"
                        },
                        "id": 51283,
                        "isConstant": false,
                        "isLValue": false,
                        "isPure": false,
                        "lValueRequested": false,
                        "leftExpression": {
                          "commonType": {
                            "typeIdentifier": "t_uint256",
                            "typeString": "uint256"
                          },
                          "id": 51279,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": false,
                          "lValueRequested": false,
                          "leftExpression": {
                            "hexValue": "37313332",
                            "id": 51277,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": true,
                            "kind": "number",
                            "lValueRequested": false,
                            "nodeType": "Literal",
                            "src": "1239:4:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_rational_7132_by_1",
                              "typeString": "int_const 7132"
                            },
                            "value": "7132"
                          },
                          "nodeType": "BinaryOperation",
                          "operator": "<",
                          "rightExpression": {
                            "id": 51278,
                            "name": "n",
                            "nodeType": "Identifier",
                            "overloadedDeclarations": [],
                            "referencedDeclaration": 51269,
                            "src": "1246:1:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_uint256",
                              "typeString": "uint256"
                            }
                          },
                          "src": "1239:8:52",
                          "typeDescriptions": {
                            "typeIdentifier": "t_bool",
                            "typeString": "bool"
                          }
                        },
                        "nodeType": "BinaryOperation",
                        "operator": "&&",
                        "rightExpression": {
                          "commonType": {
                            "typeIdentifier": "t_uint256",
                            "typeString": "uint256"
                          },
                          "id": 51282,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": false,
                          "lValueRequested": false,
                          "leftExpression": {
                            "id": 51280,
                            "name": "n",
                            "nodeType": "Identifier",
                            "overloadedDeclarations": [],
                            "referencedDeclaration": 51269,
                            "src": "1251:1:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_uint256",
                              "typeString": "uint256"
                            }
                          },
                          "nodeType": "BinaryOperation",
                          "operator": "<",
                          "rightExpression": {
                            "hexValue": "333430323832333636393230393338343633343633333734363037343331373638323131343536",
                            "id": 51281,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": true,
                            "kind": "number",
                            "lValueRequested": false,
                            "nodeType": "Literal",
                            "src": "1255:39:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_rational_340282366920938463463374607431768211456_by_1",
                              "typeString": "int_const 3402...(31 digits omitted)...1456"
                            },
                            "value": "340282366920938463463374607431768211456"
                          },
                          "src": "1251:43:52",
                          "typeDescriptions": {
                            "typeIdentifier": "t_bool",
                            "typeString": "bool"
                          }
                        },
                        "src": "1239:55:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_bool",
                          "typeString": "bool"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_bool",
                          "typeString": "bool"
                        }
                      ],
                      "expression": {
                        "id": 51274,
                        "name": "vm",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 5028,
                        "src": "1229:2:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_contract$_Vm_$16595",
                          "typeString": "contract Vm"
                        }
                      },
                      "id": 51276,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberLocation": "1232:6:52",
                      "memberName": "assume",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 16060,
                      "src": "1229:9:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_external_pure$_t_bool_$returns$__$",
                        "typeString": "function (bool) pure external"
                      }
                    },
                    "id": 51284,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "nameLocations": [],
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "1229:66:52",
                    "tryCall": false,
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$__$",
                      "typeString": "tuple()"
                    }
                  },
                  "id": 51285,
                  "nodeType": "ExpressionStatement",
                  "src": "1229:66:52"
                },
                {
                  "assignments": [
                    51287
                  ],
                  "declarations": [
                    {
                      "constant": false,
                      "id": 51287,
                      "mutability": "mutable",
                      "name": "k",
                      "nameLocation": "1312:1:52",
                      "nodeType": "VariableDeclaration",
                      "scope": 51304,
                      "src": "1305:8:52",
                      "stateVariable": false,
                      "storageLocation": "default",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint16",
                        "typeString": "uint16"
                      },
                      "typeName": {
                        "id": 51286,
                        "name": "uint16",
                        "nodeType": "ElementaryTypeName",
                        "src": "1305:6:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint16",
                          "typeString": "uint16"
                        }
                      },
                      "visibility": "internal"
                    }
                  ],
                  "id": 51292,
                  "initialValue": {
                    "arguments": [
                      {
                        "id": 51290,
                        "name": "n",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51269,
                        "src": "1343:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      ],
                      "expression": {
                        "id": 51288,
                        "name": "LibPowMath",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 2098,
                        "src": "1316:10:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_type$_t_contract$_LibPowMath_$2098_$",
                          "typeString": "type(library LibPowMath)"
                        }
                      },
                      "id": 51289,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberLocation": "1327:15:52",
                      "memberName": "findMaxExponent",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 2097,
                      "src": "1316:26:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_pure$_t_uint256_$returns$_t_uint16_$",
                        "typeString": "function (uint256) pure returns (uint16)"
                      }
                    },
                    "id": 51291,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "nameLocations": [],
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "1316:29:52",
                    "tryCall": false,
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint16",
                      "typeString": "uint16"
                    }
                  },
                  "nodeType": "VariableDeclarationStatement",
                  "src": "1305:40:52"
                },
                {
                  "expression": {
                    "id": 51302,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftHandSide": {
                      "id": 51293,
                      "name": "res",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51272,
                      "src": "1355:3:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "nodeType": "Assignment",
                    "operator": "=",
                    "rightHandSide": {
                      "commonType": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      },
                      "id": 51301,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "leftExpression": {
                        "id": 51294,
                        "name": "n",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51269,
                        "src": "1361:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      "nodeType": "BinaryOperation",
                      "operator": "**",
                      "rightExpression": {
                        "arguments": [
                          {
                            "commonType": {
                              "typeIdentifier": "t_uint16",
                              "typeString": "uint16"
                            },
                            "id": 51299,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": false,
                            "lValueRequested": false,
                            "leftExpression": {
                              "id": 51297,
                              "name": "k",
                              "nodeType": "Identifier",
                              "overloadedDeclarations": [],
                              "referencedDeclaration": 51287,
                              "src": "1374:1:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_uint16",
                                "typeString": "uint16"
                              }
                            },
                            "nodeType": "BinaryOperation",
                            "operator": "+",
                            "rightExpression": {
                              "hexValue": "31",
                              "id": 51298,
                              "isConstant": false,
                              "isLValue": false,
                              "isPure": true,
                              "kind": "number",
                              "lValueRequested": false,
                              "nodeType": "Literal",
                              "src": "1378:1:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_rational_1_by_1",
                                "typeString": "int_const 1"
                              },
                              "value": "1"
                            },
                            "src": "1374:5:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_uint16",
                              "typeString": "uint16"
                            }
                          }
                        ],
                        "expression": {
                          "argumentTypes": [
                            {
                              "typeIdentifier": "t_uint16",
                              "typeString": "uint16"
                            }
                          ],
                          "id": 51296,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": true,
                          "lValueRequested": false,
                          "nodeType": "ElementaryTypeNameExpression",
                          "src": "1366:7:52",
                          "typeDescriptions": {
                            "typeIdentifier": "t_type$_t_uint256_$",
                            "typeString": "type(uint256)"
                          },
                          "typeName": {
                            "id": 51295,
                            "name": "uint256",
                            "nodeType": "ElementaryTypeName",
                            "src": "1366:7:52",
                            "typeDescriptions": {}
                          }
                        },
                        "id": 51300,
                        "isConstant": false,
                        "isLValue": false,
                        "isPure": false,
                        "kind": "typeConversion",
                        "lValueRequested": false,
                        "nameLocations": [],
                        "names": [],
                        "nodeType": "FunctionCall",
                        "src": "1366:14:52",
                        "tryCall": false,
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      "src": "1361:19:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "src": "1355:25:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 51303,
                  "nodeType": "ExpressionStatement",
                  "src": "1355:25:52"
                }
              ]
            },
            "documentation": {
              "id": 51267,
              "nodeType": "StructuredDocumentation",
              "src": "1042:61:52",
              "text": " @notice Should fail when the exponent k+1."
            },
            "functionSelector": "5a15e501",
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "testFail_findMaxExponent_ExponentWhenPlus1",
            "nameLocation": "1117:42:52",
            "parameters": {
              "id": 51270,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 51269,
                  "mutability": "mutable",
                  "name": "n",
                  "nameLocation": "1177:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51305,
                  "src": "1169:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51268,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "1169:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "1159:25:52"
            },
            "returnParameters": {
              "id": 51273,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 51272,
                  "mutability": "mutable",
                  "name": "res",
                  "nameLocation": "1214:3:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51305,
                  "src": "1206:11:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51271,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "1206:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "1205:13:52"
            },
            "scope": 51625,
            "stateMutability": "pure",
            "virtual": false,
            "visibility": "public"
          },
          {
            "id": 51331,
            "nodeType": "FunctionDefinition",
            "src": "1460:198:52",
            "nodes": [],
            "body": {
              "id": 51330,
              "nodeType": "Block",
              "src": "1612:46:52",
              "nodes": [],
              "statements": [
                {
                  "expression": {
                    "arguments": [
                      {
                        "id": 51324,
                        "name": "x",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51308,
                        "src": "1640:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51325,
                        "name": "y",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51310,
                        "src": "1643:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51326,
                        "name": "d",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51312,
                        "src": "1646:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51327,
                        "name": "n",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51314,
                        "src": "1649:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint8",
                          "typeString": "uint8"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint8",
                          "typeString": "uint8"
                        }
                      ],
                      "id": 51323,
                      "name": "safeUnutilizedPow",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51624,
                      "src": "1622:17:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$_t_uint8_$returns$_t_uint256_$",
                        "typeString": "function (uint256,uint256,uint256,uint8) pure returns (uint256)"
                      }
                    },
                    "id": 51328,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "nameLocations": [],
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "1622:29:52",
                    "tryCall": false,
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 51329,
                  "nodeType": "ExpressionStatement",
                  "src": "1622:29:52"
                }
              ]
            },
            "documentation": {
              "id": 51306,
              "nodeType": "StructuredDocumentation",
              "src": "1393:62:52",
              "text": " @notice Gas report for {safeUnutilizedPow}."
            },
            "functionSelector": "2c8bbef9",
            "implemented": true,
            "kind": "function",
            "modifiers": [
              {
                "arguments": [
                  {
                    "id": 51317,
                    "name": "x",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51308,
                    "src": "1600:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  {
                    "id": 51318,
                    "name": "y",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51310,
                    "src": "1603:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  {
                    "id": 51319,
                    "name": "d",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51312,
                    "src": "1606:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  {
                    "id": 51320,
                    "name": "n",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51314,
                    "src": "1609:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    }
                  }
                ],
                "id": 51321,
                "kind": "modifierInvocation",
                "modifierName": {
                  "id": 51316,
                  "name": "skipOverflow",
                  "nameLocations": [
                    "1587:12:52"
                  ],
                  "nodeType": "IdentifierPath",
                  "referencedDeclaration": 51241,
                  "src": "1587:12:52"
                },
                "nodeType": "ModifierInvocation",
                "src": "1587:24:52"
              }
            ],
            "name": "testGas_safeUnutilizedPow",
            "nameLocation": "1469:25:52",
            "parameters": {
              "id": 51315,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 51308,
                  "mutability": "mutable",
                  "name": "x",
                  "nameLocation": "1512:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51331,
                  "src": "1504:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51307,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "1504:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51310,
                  "mutability": "mutable",
                  "name": "y",
                  "nameLocation": "1531:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51331,
                  "src": "1523:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51309,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "1523:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51312,
                  "mutability": "mutable",
                  "name": "d",
                  "nameLocation": "1550:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51331,
                  "src": "1542:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51311,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "1542:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51314,
                  "mutability": "mutable",
                  "name": "n",
                  "nameLocation": "1567:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51331,
                  "src": "1561:7:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint8",
                    "typeString": "uint8"
                  },
                  "typeName": {
                    "id": 51313,
                    "name": "uint8",
                    "nodeType": "ElementaryTypeName",
                    "src": "1561:5:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "1494:80:52"
            },
            "returnParameters": {
              "id": 51322,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1612:0:52"
            },
            "scope": 51625,
            "stateMutability": "view",
            "virtual": false,
            "visibility": "public"
          },
          {
            "id": 51375,
            "nodeType": "FunctionDefinition",
            "src": "1731:256:52",
            "nodes": [],
            "body": {
              "id": 51374,
              "nodeType": "Block",
              "src": "1872:115:52",
              "nodes": [],
              "statements": [
                {
                  "expression": {
                    "id": 51351,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftHandSide": {
                      "id": 51349,
                      "name": "x",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51334,
                      "src": "1882:1:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "nodeType": "Assignment",
                    "operator": "=",
                    "rightHandSide": {
                      "hexValue": "35373339",
                      "id": 51350,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": true,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "1886:4:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_rational_5739_by_1",
                        "typeString": "int_const 5739"
                      },
                      "value": "5739"
                    },
                    "src": "1882:8:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 51352,
                  "nodeType": "ExpressionStatement",
                  "src": "1882:8:52"
                },
                {
                  "expression": {
                    "id": 51355,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftHandSide": {
                      "id": 51353,
                      "name": "y",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51336,
                      "src": "1900:1:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "nodeType": "Assignment",
                    "operator": "=",
                    "rightHandSide": {
                      "hexValue": "31323933",
                      "id": 51354,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": true,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "1904:4:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_rational_1293_by_1",
                        "typeString": "int_const 1293"
                      },
                      "value": "1293"
                    },
                    "src": "1900:8:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 51356,
                  "nodeType": "ExpressionStatement",
                  "src": "1900:8:52"
                },
                {
                  "expression": {
                    "id": 51359,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftHandSide": {
                      "id": 51357,
                      "name": "d",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51338,
                      "src": "1918:1:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "nodeType": "Assignment",
                    "operator": "=",
                    "rightHandSide": {
                      "hexValue": "323432",
                      "id": 51358,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": true,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "1922:3:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_rational_242_by_1",
                        "typeString": "int_const 242"
                      },
                      "value": "242"
                    },
                    "src": "1918:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 51360,
                  "nodeType": "ExpressionStatement",
                  "src": "1918:7:52"
                },
                {
                  "expression": {
                    "id": 51363,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftHandSide": {
                      "id": 51361,
                      "name": "n",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51340,
                      "src": "1935:1:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint8",
                        "typeString": "uint8"
                      }
                    },
                    "nodeType": "Assignment",
                    "operator": "=",
                    "rightHandSide": {
                      "hexValue": "3231",
                      "id": 51362,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": true,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "1939:2:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_rational_21_by_1",
                        "typeString": "int_const 21"
                      },
                      "value": "21"
                    },
                    "src": "1935:6:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    }
                  },
                  "id": 51364,
                  "nodeType": "ExpressionStatement",
                  "src": "1935:6:52"
                },
                {
                  "expression": {
                    "arguments": [
                      {
                        "id": 51368,
                        "name": "x",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51334,
                        "src": "1969:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51369,
                        "name": "y",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51336,
                        "src": "1972:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51370,
                        "name": "d",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51338,
                        "src": "1975:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51371,
                        "name": "n",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51340,
                        "src": "1978:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint8",
                          "typeString": "uint8"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint8",
                          "typeString": "uint8"
                        }
                      ],
                      "expression": {
                        "id": 51365,
                        "name": "LibPowMath",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 2098,
                        "src": "1951:10:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_type$_t_contract$_LibPowMath_$2098_$",
                          "typeString": "type(library LibPowMath)"
                        }
                      },
                      "id": 51367,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberLocation": "1962:6:52",
                      "memberName": "mulDiv",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 1814,
                      "src": "1951:17:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$_t_uint16_$returns$_t_uint256_$",
                        "typeString": "function (uint256,uint256,uint256,uint16) pure returns (uint256)"
                      }
                    },
                    "id": 51372,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "nameLocations": [],
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "1951:29:52",
                    "tryCall": false,
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 51373,
                  "nodeType": "ExpressionStatement",
                  "src": "1951:29:52"
                }
              ]
            },
            "documentation": {
              "id": 51332,
              "nodeType": "StructuredDocumentation",
              "src": "1664:62:52",
              "text": " @notice Gas report for {LibPowMath.mulDiv}."
            },
            "functionSelector": "93ea09fb",
            "implemented": true,
            "kind": "function",
            "modifiers": [
              {
                "arguments": [
                  {
                    "id": 51343,
                    "name": "x",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51334,
                    "src": "1860:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  {
                    "id": 51344,
                    "name": "y",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51336,
                    "src": "1863:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  {
                    "id": 51345,
                    "name": "d",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51338,
                    "src": "1866:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  {
                    "id": 51346,
                    "name": "n",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51340,
                    "src": "1869:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    }
                  }
                ],
                "id": 51347,
                "kind": "modifierInvocation",
                "modifierName": {
                  "id": 51342,
                  "name": "skipOverflow",
                  "nameLocations": [
                    "1847:12:52"
                  ],
                  "nodeType": "IdentifierPath",
                  "referencedDeclaration": 51241,
                  "src": "1847:12:52"
                },
                "nodeType": "ModifierInvocation",
                "src": "1847:24:52"
              }
            ],
            "name": "testGas_mulDiv",
            "nameLocation": "1740:14:52",
            "parameters": {
              "id": 51341,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 51334,
                  "mutability": "mutable",
                  "name": "x",
                  "nameLocation": "1772:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51375,
                  "src": "1764:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51333,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "1764:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51336,
                  "mutability": "mutable",
                  "name": "y",
                  "nameLocation": "1791:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51375,
                  "src": "1783:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51335,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "1783:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51338,
                  "mutability": "mutable",
                  "name": "d",
                  "nameLocation": "1810:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51375,
                  "src": "1802:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51337,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "1802:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51340,
                  "mutability": "mutable",
                  "name": "n",
                  "nameLocation": "1827:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51375,
                  "src": "1821:7:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint8",
                    "typeString": "uint8"
                  },
                  "typeName": {
                    "id": 51339,
                    "name": "uint8",
                    "nodeType": "ElementaryTypeName",
                    "src": "1821:5:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "1754:80:52"
            },
            "returnParameters": {
              "id": 51348,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1872:0:52"
            },
            "scope": 51625,
            "stateMutability": "view",
            "virtual": false,
            "visibility": "public"
          },
          {
            "id": 51403,
            "nodeType": "FunctionDefinition",
            "src": "2072:211:52",
            "nodes": [],
            "body": {
              "id": 51402,
              "nodeType": "Block",
              "src": "2225:58:52",
              "nodes": [],
              "statements": [
                {
                  "expression": {
                    "arguments": [
                      {
                        "id": 51396,
                        "name": "x",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51378,
                        "src": "2265:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51397,
                        "name": "y",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51380,
                        "src": "2268:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51398,
                        "name": "d",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51382,
                        "src": "2271:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51399,
                        "name": "n",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51384,
                        "src": "2274:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint8",
                          "typeString": "uint8"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint8",
                          "typeString": "uint8"
                        }
                      ],
                      "expression": {
                        "id": 51393,
                        "name": "LibPowMath",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 2098,
                        "src": "2235:10:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_type$_t_contract$_LibPowMath_$2098_$",
                          "typeString": "type(library LibPowMath)"
                        }
                      },
                      "id": 51395,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberLocation": "2246:18:52",
                      "memberName": "mulDivLowPrecision",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 1843,
                      "src": "2235:29:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$_t_uint16_$returns$_t_uint256_$",
                        "typeString": "function (uint256,uint256,uint256,uint16) pure returns (uint256)"
                      }
                    },
                    "id": 51400,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "nameLocations": [],
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "2235:41:52",
                    "tryCall": false,
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 51401,
                  "nodeType": "ExpressionStatement",
                  "src": "2235:41:52"
                }
              ]
            },
            "documentation": {
              "id": 51376,
              "nodeType": "StructuredDocumentation",
              "src": "1993:74:52",
              "text": " @notice Gas report for {LibPowMath.mulDivLowPrecision}."
            },
            "functionSelector": "eaf3dc1e",
            "implemented": true,
            "kind": "function",
            "modifiers": [
              {
                "arguments": [
                  {
                    "id": 51387,
                    "name": "x",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51378,
                    "src": "2213:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  {
                    "id": 51388,
                    "name": "y",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51380,
                    "src": "2216:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  {
                    "id": 51389,
                    "name": "d",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51382,
                    "src": "2219:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  {
                    "id": 51390,
                    "name": "n",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51384,
                    "src": "2222:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    }
                  }
                ],
                "id": 51391,
                "kind": "modifierInvocation",
                "modifierName": {
                  "id": 51386,
                  "name": "skipOverflow",
                  "nameLocations": [
                    "2200:12:52"
                  ],
                  "nodeType": "IdentifierPath",
                  "referencedDeclaration": 51241,
                  "src": "2200:12:52"
                },
                "nodeType": "ModifierInvocation",
                "src": "2200:24:52"
              }
            ],
            "name": "testGas_mulDivLowPrecision",
            "nameLocation": "2081:26:52",
            "parameters": {
              "id": 51385,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 51378,
                  "mutability": "mutable",
                  "name": "x",
                  "nameLocation": "2125:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51403,
                  "src": "2117:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51377,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "2117:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51380,
                  "mutability": "mutable",
                  "name": "y",
                  "nameLocation": "2144:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51403,
                  "src": "2136:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51379,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "2136:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51382,
                  "mutability": "mutable",
                  "name": "d",
                  "nameLocation": "2163:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51403,
                  "src": "2155:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51381,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "2155:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51384,
                  "mutability": "mutable",
                  "name": "n",
                  "nameLocation": "2180:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51403,
                  "src": "2174:7:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint8",
                    "typeString": "uint8"
                  },
                  "typeName": {
                    "id": 51383,
                    "name": "uint8",
                    "nodeType": "ElementaryTypeName",
                    "src": "2174:5:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "2107:80:52"
            },
            "returnParameters": {
              "id": 51392,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "2225:0:52"
            },
            "scope": 51625,
            "stateMutability": "view",
            "virtual": false,
            "visibility": "public"
          },
          {
            "id": 51429,
            "nodeType": "FunctionDefinition",
            "src": "2359:182:52",
            "nodes": [],
            "body": {
              "id": 51428,
              "nodeType": "Block",
              "src": "2503:38:52",
              "nodes": [],
              "statements": [
                {
                  "expression": {
                    "arguments": [
                      {
                        "id": 51422,
                        "name": "x",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51406,
                        "src": "2523:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51423,
                        "name": "y",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51408,
                        "src": "2526:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51424,
                        "name": "d",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51410,
                        "src": "2529:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51425,
                        "name": "n",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51412,
                        "src": "2532:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint8",
                          "typeString": "uint8"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint8",
                          "typeString": "uint8"
                        }
                      ],
                      "id": 51421,
                      "name": "unsafePow",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51536,
                      "src": "2513:9:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$_t_uint8_$returns$_t_uint256_$",
                        "typeString": "function (uint256,uint256,uint256,uint8) pure returns (uint256)"
                      }
                    },
                    "id": 51426,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "nameLocations": [],
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "2513:21:52",
                    "tryCall": false,
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 51427,
                  "nodeType": "ExpressionStatement",
                  "src": "2513:21:52"
                }
              ]
            },
            "documentation": {
              "id": 51404,
              "nodeType": "StructuredDocumentation",
              "src": "2289:65:52",
              "text": " @notice Gas report for {LibPowMath.unsafePow}."
            },
            "functionSelector": "cc1ebd75",
            "implemented": true,
            "kind": "function",
            "modifiers": [
              {
                "arguments": [
                  {
                    "id": 51415,
                    "name": "x",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51406,
                    "src": "2491:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  {
                    "id": 51416,
                    "name": "y",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51408,
                    "src": "2494:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  {
                    "id": 51417,
                    "name": "d",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51410,
                    "src": "2497:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  {
                    "id": 51418,
                    "name": "n",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51412,
                    "src": "2500:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    }
                  }
                ],
                "id": 51419,
                "kind": "modifierInvocation",
                "modifierName": {
                  "id": 51414,
                  "name": "skipOverflow",
                  "nameLocations": [
                    "2478:12:52"
                  ],
                  "nodeType": "IdentifierPath",
                  "referencedDeclaration": 51241,
                  "src": "2478:12:52"
                },
                "nodeType": "ModifierInvocation",
                "src": "2478:24:52"
              }
            ],
            "name": "testGas_unsafePow",
            "nameLocation": "2368:17:52",
            "parameters": {
              "id": 51413,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 51406,
                  "mutability": "mutable",
                  "name": "x",
                  "nameLocation": "2403:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51429,
                  "src": "2395:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51405,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "2395:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51408,
                  "mutability": "mutable",
                  "name": "y",
                  "nameLocation": "2422:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51429,
                  "src": "2414:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51407,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "2414:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51410,
                  "mutability": "mutable",
                  "name": "d",
                  "nameLocation": "2441:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51429,
                  "src": "2433:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51409,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "2433:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51412,
                  "mutability": "mutable",
                  "name": "n",
                  "nameLocation": "2458:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51429,
                  "src": "2452:7:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint8",
                    "typeString": "uint8"
                  },
                  "typeName": {
                    "id": 51411,
                    "name": "uint8",
                    "nodeType": "ElementaryTypeName",
                    "src": "2452:5:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "2385:80:52"
            },
            "returnParameters": {
              "id": 51420,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "2503:0:52"
            },
            "scope": 51625,
            "stateMutability": "view",
            "virtual": false,
            "visibility": "public"
          },
          {
            "id": 51496,
            "nodeType": "FunctionDefinition",
            "src": "2642:579:52",
            "nodes": [],
            "body": {
              "id": 51495,
              "nodeType": "Block",
              "src": "2775:446:52",
              "nodes": [],
              "statements": [
                {
                  "assignments": [
                    51448
                  ],
                  "declarations": [
                    {
                      "constant": false,
                      "id": 51448,
                      "mutability": "mutable",
                      "name": "calc",
                      "nameLocation": "2793:4:52",
                      "nodeType": "VariableDeclaration",
                      "scope": 51495,
                      "src": "2785:12:52",
                      "stateVariable": false,
                      "storageLocation": "default",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      },
                      "typeName": {
                        "id": 51447,
                        "name": "uint256",
                        "nodeType": "ElementaryTypeName",
                        "src": "2785:7:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      "visibility": "internal"
                    }
                  ],
                  "id": 51456,
                  "initialValue": {
                    "arguments": [
                      {
                        "id": 51451,
                        "name": "x",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51432,
                        "src": "2818:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51452,
                        "name": "y",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51434,
                        "src": "2821:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51453,
                        "name": "d",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51436,
                        "src": "2824:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51454,
                        "name": "n",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51438,
                        "src": "2827:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint8",
                          "typeString": "uint8"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint8",
                          "typeString": "uint8"
                        }
                      ],
                      "expression": {
                        "id": 51449,
                        "name": "LibPowMath",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 2098,
                        "src": "2800:10:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_type$_t_contract$_LibPowMath_$2098_$",
                          "typeString": "type(library LibPowMath)"
                        }
                      },
                      "id": 51450,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberLocation": "2811:6:52",
                      "memberName": "mulDiv",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 1814,
                      "src": "2800:17:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$_t_uint16_$returns$_t_uint256_$",
                        "typeString": "function (uint256,uint256,uint256,uint16) pure returns (uint256)"
                      }
                    },
                    "id": 51455,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "nameLocations": [],
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "2800:29:52",
                    "tryCall": false,
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "nodeType": "VariableDeclarationStatement",
                  "src": "2785:44:52"
                },
                {
                  "assignments": [
                    51458
                  ],
                  "declarations": [
                    {
                      "constant": false,
                      "id": 51458,
                      "mutability": "mutable",
                      "name": "expt",
                      "nameLocation": "2847:4:52",
                      "nodeType": "VariableDeclaration",
                      "scope": 51495,
                      "src": "2839:12:52",
                      "stateVariable": false,
                      "storageLocation": "default",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      },
                      "typeName": {
                        "id": 51457,
                        "name": "uint256",
                        "nodeType": "ElementaryTypeName",
                        "src": "2839:7:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      "visibility": "internal"
                    }
                  ],
                  "id": 51465,
                  "initialValue": {
                    "arguments": [
                      {
                        "id": 51460,
                        "name": "x",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51432,
                        "src": "2872:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51461,
                        "name": "y",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51434,
                        "src": "2875:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51462,
                        "name": "d",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51436,
                        "src": "2878:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51463,
                        "name": "n",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51438,
                        "src": "2881:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint8",
                          "typeString": "uint8"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint8",
                          "typeString": "uint8"
                        }
                      ],
                      "id": 51459,
                      "name": "safeUnutilizedPow",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51624,
                      "src": "2854:17:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$_t_uint8_$returns$_t_uint256_$",
                        "typeString": "function (uint256,uint256,uint256,uint8) pure returns (uint256)"
                      }
                    },
                    "id": 51464,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "nameLocations": [],
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "2854:29:52",
                    "tryCall": false,
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "nodeType": "VariableDeclarationStatement",
                  "src": "2839:44:52"
                },
                {
                  "expression": {
                    "arguments": [
                      {
                        "id": 51467,
                        "name": "calc",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51448,
                        "src": "2915:4:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "id": 51468,
                        "name": "expt",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51458,
                        "src": "2933:4:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      {
                        "arguments": [
                          {
                            "hexValue": "45787072657373696f6e3a20",
                            "id": 51472,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": true,
                            "kind": "string",
                            "lValueRequested": false,
                            "nodeType": "Literal",
                            "src": "2982:14:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_stringliteral_ae79fedba1d0cb541bb75cb337b18bcf993ccd4bb1484256d41dac3441628721",
                              "typeString": "literal_string \"Expression: \""
                            },
                            "value": "Expression: "
                          },
                          {
                            "arguments": [
                              {
                                "id": 51475,
                                "name": "x",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 51432,
                                "src": "3026:1:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                }
                              }
                            ],
                            "expression": {
                              "argumentTypes": [
                                {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                }
                              ],
                              "expression": {
                                "id": 51473,
                                "name": "vm",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 5028,
                                "src": "3014:2:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_contract$_Vm_$16595",
                                  "typeString": "contract Vm"
                                }
                              },
                              "id": 51474,
                              "isConstant": false,
                              "isLValue": false,
                              "isPure": false,
                              "lValueRequested": false,
                              "memberLocation": "3017:8:52",
                              "memberName": "toString",
                              "nodeType": "MemberAccess",
                              "referencedDeclaration": 15593,
                              "src": "3014:11:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_function_external_pure$_t_uint256_$returns$_t_string_memory_ptr_$",
                                "typeString": "function (uint256) pure external returns (string memory)"
                              }
                            },
                            "id": 51476,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": false,
                            "kind": "functionCall",
                            "lValueRequested": false,
                            "nameLocations": [],
                            "names": [],
                            "nodeType": "FunctionCall",
                            "src": "3014:14:52",
                            "tryCall": false,
                            "typeDescriptions": {
                              "typeIdentifier": "t_string_memory_ptr",
                              "typeString": "string memory"
                            }
                          },
                          {
                            "hexValue": "2a28",
                            "id": 51477,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": true,
                            "kind": "string",
                            "lValueRequested": false,
                            "nodeType": "Literal",
                            "src": "3046:4:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_stringliteral_cf24049ed45733246cef0f1b082cb531f83d541297f1f0cc085e7ba7aae3d6c4",
                              "typeString": "literal_string \"*(\""
                            },
                            "value": "*("
                          },
                          {
                            "arguments": [
                              {
                                "id": 51480,
                                "name": "y",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 51434,
                                "src": "3080:1:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                }
                              }
                            ],
                            "expression": {
                              "argumentTypes": [
                                {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                }
                              ],
                              "expression": {
                                "id": 51478,
                                "name": "vm",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 5028,
                                "src": "3068:2:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_contract$_Vm_$16595",
                                  "typeString": "contract Vm"
                                }
                              },
                              "id": 51479,
                              "isConstant": false,
                              "isLValue": false,
                              "isPure": false,
                              "lValueRequested": false,
                              "memberLocation": "3071:8:52",
                              "memberName": "toString",
                              "nodeType": "MemberAccess",
                              "referencedDeclaration": 15593,
                              "src": "3068:11:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_function_external_pure$_t_uint256_$returns$_t_string_memory_ptr_$",
                                "typeString": "function (uint256) pure external returns (string memory)"
                              }
                            },
                            "id": 51481,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": false,
                            "kind": "functionCall",
                            "lValueRequested": false,
                            "nameLocations": [],
                            "names": [],
                            "nodeType": "FunctionCall",
                            "src": "3068:14:52",
                            "tryCall": false,
                            "typeDescriptions": {
                              "typeIdentifier": "t_string_memory_ptr",
                              "typeString": "string memory"
                            }
                          },
                          {
                            "hexValue": "2f",
                            "id": 51482,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": true,
                            "kind": "string",
                            "lValueRequested": false,
                            "nodeType": "Literal",
                            "src": "3100:3:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_stringliteral_fba9715e477e68952d3f1df7a185b3708aadad50ec10cc793973864023868527",
                              "typeString": "literal_string \"/\""
                            },
                            "value": "/"
                          },
                          {
                            "arguments": [
                              {
                                "id": 51485,
                                "name": "d",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 51436,
                                "src": "3133:1:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                }
                              }
                            ],
                            "expression": {
                              "argumentTypes": [
                                {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                }
                              ],
                              "expression": {
                                "id": 51483,
                                "name": "vm",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 5028,
                                "src": "3121:2:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_contract$_Vm_$16595",
                                  "typeString": "contract Vm"
                                }
                              },
                              "id": 51484,
                              "isConstant": false,
                              "isLValue": false,
                              "isPure": false,
                              "lValueRequested": false,
                              "memberLocation": "3124:8:52",
                              "memberName": "toString",
                              "nodeType": "MemberAccess",
                              "referencedDeclaration": 15593,
                              "src": "3121:11:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_function_external_pure$_t_uint256_$returns$_t_string_memory_ptr_$",
                                "typeString": "function (uint256) pure external returns (string memory)"
                              }
                            },
                            "id": 51486,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": false,
                            "kind": "functionCall",
                            "lValueRequested": false,
                            "nameLocations": [],
                            "names": [],
                            "nodeType": "FunctionCall",
                            "src": "3121:14:52",
                            "tryCall": false,
                            "typeDescriptions": {
                              "typeIdentifier": "t_string_memory_ptr",
                              "typeString": "string memory"
                            }
                          },
                          {
                            "hexValue": "292a2a",
                            "id": 51487,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": true,
                            "kind": "string",
                            "lValueRequested": false,
                            "nodeType": "Literal",
                            "src": "3153:5:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_stringliteral_092eff04b7125b3516298b769505d9f7f0c20586eb1aea6cae910e66e610dd2f",
                              "typeString": "literal_string \")**\""
                            },
                            "value": ")**"
                          },
                          {
                            "arguments": [
                              {
                                "id": 51490,
                                "name": "n",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 51438,
                                "src": "3188:1:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_uint8",
                                  "typeString": "uint8"
                                }
                              }
                            ],
                            "expression": {
                              "argumentTypes": [
                                {
                                  "typeIdentifier": "t_uint8",
                                  "typeString": "uint8"
                                }
                              ],
                              "expression": {
                                "id": 51488,
                                "name": "vm",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 5028,
                                "src": "3176:2:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_contract$_Vm_$16595",
                                  "typeString": "contract Vm"
                                }
                              },
                              "id": 51489,
                              "isConstant": false,
                              "isLValue": false,
                              "isPure": false,
                              "lValueRequested": false,
                              "memberLocation": "3179:8:52",
                              "memberName": "toString",
                              "nodeType": "MemberAccess",
                              "referencedDeclaration": 15593,
                              "src": "3176:11:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_function_external_pure$_t_uint256_$returns$_t_string_memory_ptr_$",
                                "typeString": "function (uint256) pure external returns (string memory)"
                              }
                            },
                            "id": 51491,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": false,
                            "kind": "functionCall",
                            "lValueRequested": false,
                            "nameLocations": [],
                            "names": [],
                            "nodeType": "FunctionCall",
                            "src": "3176:14:52",
                            "tryCall": false,
                            "typeDescriptions": {
                              "typeIdentifier": "t_string_memory_ptr",
                              "typeString": "string memory"
                            }
                          }
                        ],
                        "expression": {
                          "argumentTypes": [
                            {
                              "typeIdentifier": "t_stringliteral_ae79fedba1d0cb541bb75cb337b18bcf993ccd4bb1484256d41dac3441628721",
                              "typeString": "literal_string \"Expression: \""
                            },
                            {
                              "typeIdentifier": "t_string_memory_ptr",
                              "typeString": "string memory"
                            },
                            {
                              "typeIdentifier": "t_stringliteral_cf24049ed45733246cef0f1b082cb531f83d541297f1f0cc085e7ba7aae3d6c4",
                              "typeString": "literal_string \"*(\""
                            },
                            {
                              "typeIdentifier": "t_string_memory_ptr",
                              "typeString": "string memory"
                            },
                            {
                              "typeIdentifier": "t_stringliteral_fba9715e477e68952d3f1df7a185b3708aadad50ec10cc793973864023868527",
                              "typeString": "literal_string \"/\""
                            },
                            {
                              "typeIdentifier": "t_string_memory_ptr",
                              "typeString": "string memory"
                            },
                            {
                              "typeIdentifier": "t_stringliteral_092eff04b7125b3516298b769505d9f7f0c20586eb1aea6cae910e66e610dd2f",
                              "typeString": "literal_string \")**\""
                            },
                            {
                              "typeIdentifier": "t_string_memory_ptr",
                              "typeString": "string memory"
                            }
                          ],
                          "expression": {
                            "id": 51470,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": true,
                            "lValueRequested": false,
                            "nodeType": "ElementaryTypeNameExpression",
                            "src": "2951:6:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_type$_t_string_storage_ptr_$",
                              "typeString": "type(string storage pointer)"
                            },
                            "typeName": {
                              "id": 51469,
                              "name": "string",
                              "nodeType": "ElementaryTypeName",
                              "src": "2951:6:52",
                              "typeDescriptions": {}
                            }
                          },
                          "id": 51471,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": false,
                          "lValueRequested": false,
                          "memberLocation": "2958:6:52",
                          "memberName": "concat",
                          "nodeType": "MemberAccess",
                          "src": "2951:13:52",
                          "typeDescriptions": {
                            "typeIdentifier": "t_function_stringconcat_pure$__$returns$_t_string_memory_ptr_$",
                            "typeString": "function () pure returns (string memory)"
                          }
                        },
                        "id": 51492,
                        "isConstant": false,
                        "isLValue": false,
                        "isPure": false,
                        "kind": "functionCall",
                        "lValueRequested": false,
                        "nameLocations": [],
                        "names": [],
                        "nodeType": "FunctionCall",
                        "src": "2951:253:52",
                        "tryCall": false,
                        "typeDescriptions": {
                          "typeIdentifier": "t_string_memory_ptr",
                          "typeString": "string memory"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        {
                          "typeIdentifier": "t_string_memory_ptr",
                          "typeString": "string memory"
                        }
                      ],
                      "id": 51466,
                      "name": "assertEq",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [
                        5163,
                        5188,
                        5201,
                        5217,
                        5259,
                        5301,
                        5343,
                        5380,
                        5417,
                        5454,
                        2998,
                        3023,
                        3053,
                        3078,
                        3137,
                        3162,
                        3192,
                        3217,
                        4690,
                        4725
                      ],
                      "referencedDeclaration": 3217,
                      "src": "2893:8:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_nonpayable$_t_uint256_$_t_uint256_$_t_string_memory_ptr_$returns$__$",
                        "typeString": "function (uint256,uint256,string memory)"
                      }
                    },
                    "id": 51493,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "nameLocations": [],
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "2893:321:52",
                    "tryCall": false,
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$__$",
                      "typeString": "tuple()"
                    }
                  },
                  "id": 51494,
                  "nodeType": "ExpressionStatement",
                  "src": "2893:321:52"
                }
              ]
            },
            "documentation": {
              "id": 51430,
              "nodeType": "StructuredDocumentation",
              "src": "2547:90:52",
              "text": " @notice Test the correctness of the mul div method {LibPowMath.mulDiv}."
            },
            "functionSelector": "f76ee3ee",
            "implemented": true,
            "kind": "function",
            "modifiers": [
              {
                "arguments": [
                  {
                    "id": 51441,
                    "name": "x",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51432,
                    "src": "2763:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  {
                    "id": 51442,
                    "name": "y",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51434,
                    "src": "2766:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  {
                    "id": 51443,
                    "name": "d",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51436,
                    "src": "2769:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  {
                    "id": 51444,
                    "name": "n",
                    "nodeType": "Identifier",
                    "overloadedDeclarations": [],
                    "referencedDeclaration": 51438,
                    "src": "2772:1:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    }
                  }
                ],
                "id": 51445,
                "kind": "modifierInvocation",
                "modifierName": {
                  "id": 51440,
                  "name": "skipOverflow",
                  "nameLocations": [
                    "2750:12:52"
                  ],
                  "nodeType": "IdentifierPath",
                  "referencedDeclaration": 51241,
                  "src": "2750:12:52"
                },
                "nodeType": "ModifierInvocation",
                "src": "2750:24:52"
              }
            ],
            "name": "test_mulDiv",
            "nameLocation": "2651:11:52",
            "parameters": {
              "id": 51439,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 51432,
                  "mutability": "mutable",
                  "name": "x",
                  "nameLocation": "2680:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51496,
                  "src": "2672:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51431,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "2672:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51434,
                  "mutability": "mutable",
                  "name": "y",
                  "nameLocation": "2699:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51496,
                  "src": "2691:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51433,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "2691:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51436,
                  "mutability": "mutable",
                  "name": "d",
                  "nameLocation": "2718:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51496,
                  "src": "2710:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51435,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "2710:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51438,
                  "mutability": "mutable",
                  "name": "n",
                  "nameLocation": "2735:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51496,
                  "src": "2729:7:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint8",
                    "typeString": "uint8"
                  },
                  "typeName": {
                    "id": 51437,
                    "name": "uint8",
                    "nodeType": "ElementaryTypeName",
                    "src": "2729:5:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "2662:80:52"
            },
            "returnParameters": {
              "id": 51446,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "2775:0:52"
            },
            "scope": 51625,
            "stateMutability": "nonpayable",
            "virtual": false,
            "visibility": "public"
          },
          {
            "id": 51536,
            "nodeType": "FunctionDefinition",
            "src": "3307:243:52",
            "nodes": [],
            "body": {
              "id": 51535,
              "nodeType": "Block",
              "src": "3438:112:52",
              "nodes": [],
              "statements": [
                {
                  "expression": {
                    "id": 51512,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftHandSide": {
                      "id": 51510,
                      "name": "r",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51508,
                      "src": "3448:1:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "nodeType": "Assignment",
                    "operator": "=",
                    "rightHandSide": {
                      "id": 51511,
                      "name": "x",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51499,
                      "src": "3452:1:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "src": "3448:5:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 51513,
                  "nodeType": "ExpressionStatement",
                  "src": "3448:5:52"
                },
                {
                  "body": {
                    "id": 51533,
                    "nodeType": "Block",
                    "src": "3495:49:52",
                    "statements": [
                      {
                        "expression": {
                          "id": 51531,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": false,
                          "lValueRequested": false,
                          "leftHandSide": {
                            "id": 51524,
                            "name": "r",
                            "nodeType": "Identifier",
                            "overloadedDeclarations": [],
                            "referencedDeclaration": 51508,
                            "src": "3509:1:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_uint256",
                              "typeString": "uint256"
                            }
                          },
                          "nodeType": "Assignment",
                          "operator": "=",
                          "rightHandSide": {
                            "arguments": [
                              {
                                "id": 51527,
                                "name": "r",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 51508,
                                "src": "3525:1:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                }
                              },
                              {
                                "id": 51528,
                                "name": "y",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 51501,
                                "src": "3528:1:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                }
                              },
                              {
                                "id": 51529,
                                "name": "d",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 51503,
                                "src": "3531:1:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                }
                              }
                            ],
                            "expression": {
                              "argumentTypes": [
                                {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                },
                                {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                },
                                {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                }
                              ],
                              "expression": {
                                "id": 51525,
                                "name": "Math",
                                "nodeType": "Identifier",
                                "overloadedDeclarations": [],
                                "referencedDeclaration": 50849,
                                "src": "3513:4:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_type$_t_contract$_Math_$50849_$",
                                  "typeString": "type(library Math)"
                                }
                              },
                              "id": 51526,
                              "isConstant": false,
                              "isLValue": false,
                              "isPure": false,
                              "lValueRequested": false,
                              "memberLocation": "3518:6:52",
                              "memberName": "mulDiv",
                              "nodeType": "MemberAccess",
                              "referencedDeclaration": 50197,
                              "src": "3513:11:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$returns$_t_uint256_$",
                                "typeString": "function (uint256,uint256,uint256) pure returns (uint256)"
                              }
                            },
                            "id": 51530,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": false,
                            "kind": "functionCall",
                            "lValueRequested": false,
                            "nameLocations": [],
                            "names": [],
                            "nodeType": "FunctionCall",
                            "src": "3513:20:52",
                            "tryCall": false,
                            "typeDescriptions": {
                              "typeIdentifier": "t_uint256",
                              "typeString": "uint256"
                            }
                          },
                          "src": "3509:24:52",
                          "typeDescriptions": {
                            "typeIdentifier": "t_uint256",
                            "typeString": "uint256"
                          }
                        },
                        "id": 51532,
                        "nodeType": "ExpressionStatement",
                        "src": "3509:24:52"
                      }
                    ]
                  },
                  "condition": {
                    "commonType": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    },
                    "id": 51520,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftExpression": {
                      "id": 51518,
                      "name": "i",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51515,
                      "src": "3483:1:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "nodeType": "BinaryOperation",
                    "operator": "<",
                    "rightExpression": {
                      "id": 51519,
                      "name": "n",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51505,
                      "src": "3487:1:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint8",
                        "typeString": "uint8"
                      }
                    },
                    "src": "3483:5:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bool",
                      "typeString": "bool"
                    }
                  },
                  "id": 51534,
                  "initializationExpression": {
                    "assignments": [
                      51515
                    ],
                    "declarations": [
                      {
                        "constant": false,
                        "id": 51515,
                        "mutability": "mutable",
                        "name": "i",
                        "nameLocation": "3476:1:52",
                        "nodeType": "VariableDeclaration",
                        "scope": 51534,
                        "src": "3468:9:52",
                        "stateVariable": false,
                        "storageLocation": "default",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        },
                        "typeName": {
                          "id": 51514,
                          "name": "uint256",
                          "nodeType": "ElementaryTypeName",
                          "src": "3468:7:52",
                          "typeDescriptions": {
                            "typeIdentifier": "t_uint256",
                            "typeString": "uint256"
                          }
                        },
                        "visibility": "internal"
                      }
                    ],
                    "id": 51517,
                    "initialValue": {
                      "hexValue": "30",
                      "id": 51516,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": true,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "3480:1:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_rational_0_by_1",
                        "typeString": "int_const 0"
                      },
                      "value": "0"
                    },
                    "nodeType": "VariableDeclarationStatement",
                    "src": "3468:13:52"
                  },
                  "loopExpression": {
                    "expression": {
                      "id": 51522,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "nodeType": "UnaryOperation",
                      "operator": "++",
                      "prefix": false,
                      "src": "3490:3:52",
                      "subExpression": {
                        "id": 51521,
                        "name": "i",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 51515,
                        "src": "3490:1:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint256",
                          "typeString": "uint256"
                        }
                      },
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "id": 51523,
                    "nodeType": "ExpressionStatement",
                    "src": "3490:3:52"
                  },
                  "nodeType": "ForStatement",
                  "src": "3463:81:52"
                }
              ]
            },
            "documentation": {
              "id": 51497,
              "nodeType": "StructuredDocumentation",
              "src": "3227:75:52",
              "text": " @notice Helper method to compute scale: x * (y / d) ^ n."
            },
            "functionSelector": "2f410386",
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "unsafePow",
            "nameLocation": "3316:9:52",
            "parameters": {
              "id": 51506,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 51499,
                  "mutability": "mutable",
                  "name": "x",
                  "nameLocation": "3343:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51536,
                  "src": "3335:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51498,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "3335:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51501,
                  "mutability": "mutable",
                  "name": "y",
                  "nameLocation": "3362:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51536,
                  "src": "3354:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51500,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "3354:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51503,
                  "mutability": "mutable",
                  "name": "d",
                  "nameLocation": "3381:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51536,
                  "src": "3373:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51502,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "3373:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51505,
                  "mutability": "mutable",
                  "name": "n",
                  "nameLocation": "3398:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51536,
                  "src": "3392:7:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint8",
                    "typeString": "uint8"
                  },
                  "typeName": {
                    "id": 51504,
                    "name": "uint8",
                    "nodeType": "ElementaryTypeName",
                    "src": "3392:5:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "3325:80:52"
            },
            "returnParameters": {
              "id": 51509,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 51508,
                  "mutability": "mutable",
                  "name": "r",
                  "nameLocation": "3435:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51536,
                  "src": "3427:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51507,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "3427:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "3426:11:52"
            },
            "scope": 51625,
            "stateMutability": "pure",
            "virtual": false,
            "visibility": "public"
          },
          {
            "id": 51624,
            "nodeType": "FunctionDefinition",
            "src": "3636:707:52",
            "nodes": [],
            "body": {
              "id": 51623,
              "nodeType": "Block",
              "src": "3777:566:52",
              "nodes": [],
              "statements": [
                {
                  "expression": {
                    "id": 51552,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftHandSide": {
                      "id": 51550,
                      "name": "res",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51548,
                      "src": "3787:3:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "nodeType": "Assignment",
                    "operator": "=",
                    "rightHandSide": {
                      "id": 51551,
                      "name": "x",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51539,
                      "src": "3793:1:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "src": "3787:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 51553,
                  "nodeType": "ExpressionStatement",
                  "src": "3787:7:52"
                },
                {
                  "assignments": [
                    51555
                  ],
                  "declarations": [
                    {
                      "constant": false,
                      "id": 51555,
                      "mutability": "mutable",
                      "name": "ndReverse",
                      "nameLocation": "3810:9:52",
                      "nodeType": "VariableDeclaration",
                      "scope": 51623,
                      "src": "3804:15:52",
                      "stateVariable": false,
                      "storageLocation": "default",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint8",
                        "typeString": "uint8"
                      },
                      "typeName": {
                        "id": 51554,
                        "name": "uint8",
                        "nodeType": "ElementaryTypeName",
                        "src": "3804:5:52",
                        "typeDescriptions": {
                          "typeIdentifier": "t_uint8",
                          "typeString": "uint8"
                        }
                      },
                      "visibility": "internal"
                    }
                  ],
                  "id": 51556,
                  "nodeType": "VariableDeclarationStatement",
                  "src": "3804:15:52"
                },
                {
                  "body": {
                    "id": 51607,
                    "nodeType": "Block",
                    "src": "3843:399:52",
                    "statements": [
                      {
                        "assignments": [
                          51561,
                          51563
                        ],
                        "declarations": [
                          {
                            "constant": false,
                            "id": 51561,
                            "mutability": "mutable",
                            "name": "ok",
                            "nameLocation": "3863:2:52",
                            "nodeType": "VariableDeclaration",
                            "scope": 51607,
                            "src": "3858:7:52",
                            "stateVariable": false,
                            "storageLocation": "default",
                            "typeDescriptions": {
                              "typeIdentifier": "t_bool",
                              "typeString": "bool"
                            },
                            "typeName": {
                              "id": 51560,
                              "name": "bool",
                              "nodeType": "ElementaryTypeName",
                              "src": "3858:4:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_bool",
                                "typeString": "bool"
                              }
                            },
                            "visibility": "internal"
                          },
                          {
                            "constant": false,
                            "id": 51563,
                            "mutability": "mutable",
                            "name": "res_",
                            "nameLocation": "3875:4:52",
                            "nodeType": "VariableDeclaration",
                            "scope": 51607,
                            "src": "3867:12:52",
                            "stateVariable": false,
                            "storageLocation": "default",
                            "typeDescriptions": {
                              "typeIdentifier": "t_uint256",
                              "typeString": "uint256"
                            },
                            "typeName": {
                              "id": 51562,
                              "name": "uint256",
                              "nodeType": "ElementaryTypeName",
                              "src": "3867:7:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_uint256",
                                "typeString": "uint256"
                              }
                            },
                            "visibility": "internal"
                          }
                        ],
                        "id": 51569,
                        "initialValue": {
                          "arguments": [
                            {
                              "id": 51566,
                              "name": "res",
                              "nodeType": "Identifier",
                              "overloadedDeclarations": [],
                              "referencedDeclaration": 51548,
                              "src": "3899:3:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_uint256",
                                "typeString": "uint256"
                              }
                            },
                            {
                              "id": 51567,
                              "name": "y",
                              "nodeType": "Identifier",
                              "overloadedDeclarations": [],
                              "referencedDeclaration": 51541,
                              "src": "3904:1:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_uint256",
                                "typeString": "uint256"
                              }
                            }
                          ],
                          "expression": {
                            "argumentTypes": [
                              {
                                "typeIdentifier": "t_uint256",
                                "typeString": "uint256"
                              },
                              {
                                "typeIdentifier": "t_uint256",
                                "typeString": "uint256"
                              }
                            ],
                            "expression": {
                              "id": 51564,
                              "name": "SafeMath",
                              "nodeType": "Identifier",
                              "overloadedDeclarations": [],
                              "referencedDeclaration": 51161,
                              "src": "3883:8:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_type$_t_contract$_SafeMath_$51161_$",
                                "typeString": "type(library SafeMath)"
                              }
                            },
                            "id": 51565,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": false,
                            "lValueRequested": false,
                            "memberLocation": "3892:6:52",
                            "memberName": "tryMul",
                            "nodeType": "MemberAccess",
                            "referencedDeclaration": 50954,
                            "src": "3883:15:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_function_internal_pure$_t_uint256_$_t_uint256_$returns$_t_bool_$_t_uint256_$",
                              "typeString": "function (uint256,uint256) pure returns (bool,uint256)"
                            }
                          },
                          "id": 51568,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": false,
                          "kind": "functionCall",
                          "lValueRequested": false,
                          "nameLocations": [],
                          "names": [],
                          "nodeType": "FunctionCall",
                          "src": "3883:23:52",
                          "tryCall": false,
                          "typeDescriptions": {
                            "typeIdentifier": "t_tuple$_t_bool_$_t_uint256_$",
                            "typeString": "tuple(bool,uint256)"
                          }
                        },
                        "nodeType": "VariableDeclarationStatement",
                        "src": "3857:49:52"
                      },
                      {
                        "condition": {
                          "id": 51571,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": false,
                          "lValueRequested": false,
                          "nodeType": "UnaryOperation",
                          "operator": "!",
                          "prefix": true,
                          "src": "3924:3:52",
                          "subExpression": {
                            "id": 51570,
                            "name": "ok",
                            "nodeType": "Identifier",
                            "overloadedDeclarations": [],
                            "referencedDeclaration": 51561,
                            "src": "3925:2:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_bool",
                              "typeString": "bool"
                            }
                          },
                          "typeDescriptions": {
                            "typeIdentifier": "t_bool",
                            "typeString": "bool"
                          }
                        },
                        "falseBody": {
                          "id": 51598,
                          "nodeType": "Block",
                          "src": "4146:44:52",
                          "statements": [
                            {
                              "expression": {
                                "id": 51596,
                                "isConstant": false,
                                "isLValue": false,
                                "isPure": false,
                                "lValueRequested": false,
                                "nodeType": "UnaryOperation",
                                "operator": "++",
                                "prefix": false,
                                "src": "4164:11:52",
                                "subExpression": {
                                  "id": 51595,
                                  "name": "ndReverse",
                                  "nodeType": "Identifier",
                                  "overloadedDeclarations": [],
                                  "referencedDeclaration": 51555,
                                  "src": "4164:9:52",
                                  "typeDescriptions": {
                                    "typeIdentifier": "t_uint8",
                                    "typeString": "uint8"
                                  }
                                },
                                "typeDescriptions": {
                                  "typeIdentifier": "t_uint8",
                                  "typeString": "uint8"
                                }
                              },
                              "id": 51597,
                              "nodeType": "ExpressionStatement",
                              "src": "4164:11:52"
                            }
                          ]
                        },
                        "id": 51599,
                        "nodeType": "IfStatement",
                        "src": "3920:270:52",
                        "trueBody": {
                          "id": 51594,
                          "nodeType": "Block",
                          "src": "3929:211:52",
                          "statements": [
                            {
                              "condition": {
                                "commonType": {
                                  "typeIdentifier": "t_uint8",
                                  "typeString": "uint8"
                                },
                                "id": 51574,
                                "isConstant": false,
                                "isLValue": false,
                                "isPure": false,
                                "lValueRequested": false,
                                "leftExpression": {
                                  "id": 51572,
                                  "name": "ndReverse",
                                  "nodeType": "Identifier",
                                  "overloadedDeclarations": [],
                                  "referencedDeclaration": 51555,
                                  "src": "3951:9:52",
                                  "typeDescriptions": {
                                    "typeIdentifier": "t_uint8",
                                    "typeString": "uint8"
                                  }
                                },
                                "nodeType": "BinaryOperation",
                                "operator": ">",
                                "rightExpression": {
                                  "hexValue": "30",
                                  "id": 51573,
                                  "isConstant": false,
                                  "isLValue": false,
                                  "isPure": true,
                                  "kind": "number",
                                  "lValueRequested": false,
                                  "nodeType": "Literal",
                                  "src": "3963:1:52",
                                  "typeDescriptions": {
                                    "typeIdentifier": "t_rational_0_by_1",
                                    "typeString": "int_const 0"
                                  },
                                  "value": "0"
                                },
                                "src": "3951:13:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_bool",
                                  "typeString": "bool"
                                }
                              },
                              "id": 51584,
                              "nodeType": "IfStatement",
                              "src": "3947:131:52",
                              "trueBody": {
                                "id": 51583,
                                "nodeType": "Block",
                                "src": "3966:112:52",
                                "statements": [
                                  {
                                    "expression": {
                                      "id": 51577,
                                      "isConstant": false,
                                      "isLValue": false,
                                      "isPure": false,
                                      "lValueRequested": false,
                                      "leftHandSide": {
                                        "id": 51575,
                                        "name": "res",
                                        "nodeType": "Identifier",
                                        "overloadedDeclarations": [],
                                        "referencedDeclaration": 51548,
                                        "src": "3988:3:52",
                                        "typeDescriptions": {
                                          "typeIdentifier": "t_uint256",
                                          "typeString": "uint256"
                                        }
                                      },
                                      "nodeType": "Assignment",
                                      "operator": "/=",
                                      "rightHandSide": {
                                        "id": 51576,
                                        "name": "d",
                                        "nodeType": "Identifier",
                                        "overloadedDeclarations": [],
                                        "referencedDeclaration": 51543,
                                        "src": "3995:1:52",
                                        "typeDescriptions": {
                                          "typeIdentifier": "t_uint256",
                                          "typeString": "uint256"
                                        }
                                      },
                                      "src": "3988:8:52",
                                      "typeDescriptions": {
                                        "typeIdentifier": "t_uint256",
                                        "typeString": "uint256"
                                      }
                                    },
                                    "id": 51578,
                                    "nodeType": "ExpressionStatement",
                                    "src": "3988:8:52"
                                  },
                                  {
                                    "expression": {
                                      "id": 51580,
                                      "isConstant": false,
                                      "isLValue": false,
                                      "isPure": false,
                                      "lValueRequested": false,
                                      "nodeType": "UnaryOperation",
                                      "operator": "--",
                                      "prefix": false,
                                      "src": "4018:11:52",
                                      "subExpression": {
                                        "id": 51579,
                                        "name": "ndReverse",
                                        "nodeType": "Identifier",
                                        "overloadedDeclarations": [],
                                        "referencedDeclaration": 51555,
                                        "src": "4018:9:52",
                                        "typeDescriptions": {
                                          "typeIdentifier": "t_uint8",
                                          "typeString": "uint8"
                                        }
                                      },
                                      "typeDescriptions": {
                                        "typeIdentifier": "t_uint8",
                                        "typeString": "uint8"
                                      }
                                    },
                                    "id": 51581,
                                    "nodeType": "ExpressionStatement",
                                    "src": "4018:11:52"
                                  },
                                  {
                                    "id": 51582,
                                    "nodeType": "Continue",
                                    "src": "4051:8:52"
                                  }
                                ]
                              }
                            },
                            {
                              "expression": {
                                "id": 51592,
                                "isConstant": false,
                                "isLValue": false,
                                "isPure": false,
                                "lValueRequested": false,
                                "leftHandSide": {
                                  "id": 51585,
                                  "name": "res_",
                                  "nodeType": "Identifier",
                                  "overloadedDeclarations": [],
                                  "referencedDeclaration": 51563,
                                  "src": "4096:4:52",
                                  "typeDescriptions": {
                                    "typeIdentifier": "t_uint256",
                                    "typeString": "uint256"
                                  }
                                },
                                "nodeType": "Assignment",
                                "operator": "=",
                                "rightHandSide": {
                                  "arguments": [
                                    {
                                      "id": 51588,
                                      "name": "res",
                                      "nodeType": "Identifier",
                                      "overloadedDeclarations": [],
                                      "referencedDeclaration": 51548,
                                      "src": "4115:3:52",
                                      "typeDescriptions": {
                                        "typeIdentifier": "t_uint256",
                                        "typeString": "uint256"
                                      }
                                    },
                                    {
                                      "id": 51589,
                                      "name": "y",
                                      "nodeType": "Identifier",
                                      "overloadedDeclarations": [],
                                      "referencedDeclaration": 51541,
                                      "src": "4120:1:52",
                                      "typeDescriptions": {
                                        "typeIdentifier": "t_uint256",
                                        "typeString": "uint256"
                                      }
                                    },
                                    {
                                      "id": 51590,
                                      "name": "d",
                                      "nodeType": "Identifier",
                                      "overloadedDeclarations": [],
                                      "referencedDeclaration": 51543,
                                      "src": "4123:1:52",
                                      "typeDescriptions": {
                                        "typeIdentifier": "t_uint256",
                                        "typeString": "uint256"
                                      }
                                    }
                                  ],
                                  "expression": {
                                    "argumentTypes": [
                                      {
                                        "typeIdentifier": "t_uint256",
                                        "typeString": "uint256"
                                      },
                                      {
                                        "typeIdentifier": "t_uint256",
                                        "typeString": "uint256"
                                      },
                                      {
                                        "typeIdentifier": "t_uint256",
                                        "typeString": "uint256"
                                      }
                                    ],
                                    "expression": {
                                      "id": 51586,
                                      "name": "Math",
                                      "nodeType": "Identifier",
                                      "overloadedDeclarations": [],
                                      "referencedDeclaration": 50849,
                                      "src": "4103:4:52",
                                      "typeDescriptions": {
                                        "typeIdentifier": "t_type$_t_contract$_Math_$50849_$",
                                        "typeString": "type(library Math)"
                                      }
                                    },
                                    "id": 51587,
                                    "isConstant": false,
                                    "isLValue": false,
                                    "isPure": false,
                                    "lValueRequested": false,
                                    "memberLocation": "4108:6:52",
                                    "memberName": "mulDiv",
                                    "nodeType": "MemberAccess",
                                    "referencedDeclaration": 50197,
                                    "src": "4103:11:52",
                                    "typeDescriptions": {
                                      "typeIdentifier": "t_function_internal_pure$_t_uint256_$_t_uint256_$_t_uint256_$returns$_t_uint256_$",
                                      "typeString": "function (uint256,uint256,uint256) pure returns (uint256)"
                                    }
                                  },
                                  "id": 51591,
                                  "isConstant": false,
                                  "isLValue": false,
                                  "isPure": false,
                                  "kind": "functionCall",
                                  "lValueRequested": false,
                                  "nameLocations": [],
                                  "names": [],
                                  "nodeType": "FunctionCall",
                                  "src": "4103:22:52",
                                  "tryCall": false,
                                  "typeDescriptions": {
                                    "typeIdentifier": "t_uint256",
                                    "typeString": "uint256"
                                  }
                                },
                                "src": "4096:29:52",
                                "typeDescriptions": {
                                  "typeIdentifier": "t_uint256",
                                  "typeString": "uint256"
                                }
                              },
                              "id": 51593,
                              "nodeType": "ExpressionStatement",
                              "src": "4096:29:52"
                            }
                          ]
                        }
                      },
                      {
                        "expression": {
                          "id": 51602,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": false,
                          "lValueRequested": false,
                          "leftHandSide": {
                            "id": 51600,
                            "name": "res",
                            "nodeType": "Identifier",
                            "overloadedDeclarations": [],
                            "referencedDeclaration": 51548,
                            "src": "4204:3:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_uint256",
                              "typeString": "uint256"
                            }
                          },
                          "nodeType": "Assignment",
                          "operator": "=",
                          "rightHandSide": {
                            "id": 51601,
                            "name": "res_",
                            "nodeType": "Identifier",
                            "overloadedDeclarations": [],
                            "referencedDeclaration": 51563,
                            "src": "4210:4:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_uint256",
                              "typeString": "uint256"
                            }
                          },
                          "src": "4204:10:52",
                          "typeDescriptions": {
                            "typeIdentifier": "t_uint256",
                            "typeString": "uint256"
                          }
                        },
                        "id": 51603,
                        "nodeType": "ExpressionStatement",
                        "src": "4204:10:52"
                      },
                      {
                        "expression": {
                          "id": 51605,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": false,
                          "lValueRequested": false,
                          "nodeType": "UnaryOperation",
                          "operator": "--",
                          "prefix": false,
                          "src": "4228:3:52",
                          "subExpression": {
                            "id": 51604,
                            "name": "n",
                            "nodeType": "Identifier",
                            "overloadedDeclarations": [],
                            "referencedDeclaration": 51545,
                            "src": "4228:1:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_uint8",
                              "typeString": "uint8"
                            }
                          },
                          "typeDescriptions": {
                            "typeIdentifier": "t_uint8",
                            "typeString": "uint8"
                          }
                        },
                        "id": 51606,
                        "nodeType": "ExpressionStatement",
                        "src": "4228:3:52"
                      }
                    ]
                  },
                  "condition": {
                    "commonType": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    },
                    "id": 51559,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftExpression": {
                      "id": 51557,
                      "name": "n",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51545,
                      "src": "3836:1:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint8",
                        "typeString": "uint8"
                      }
                    },
                    "nodeType": "BinaryOperation",
                    "operator": ">",
                    "rightExpression": {
                      "hexValue": "30",
                      "id": 51558,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": true,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "3840:1:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_rational_0_by_1",
                        "typeString": "int_const 0"
                      },
                      "value": "0"
                    },
                    "src": "3836:5:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bool",
                      "typeString": "bool"
                    }
                  },
                  "id": 51608,
                  "nodeType": "WhileStatement",
                  "src": "3829:413:52"
                },
                {
                  "body": {
                    "id": 51621,
                    "nodeType": "Block",
                    "src": "4274:63:52",
                    "statements": [
                      {
                        "expression": {
                          "id": 51616,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": false,
                          "lValueRequested": false,
                          "leftHandSide": {
                            "id": 51612,
                            "name": "res",
                            "nodeType": "Identifier",
                            "overloadedDeclarations": [],
                            "referencedDeclaration": 51548,
                            "src": "4288:3:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_uint256",
                              "typeString": "uint256"
                            }
                          },
                          "nodeType": "Assignment",
                          "operator": "=",
                          "rightHandSide": {
                            "commonType": {
                              "typeIdentifier": "t_uint256",
                              "typeString": "uint256"
                            },
                            "id": 51615,
                            "isConstant": false,
                            "isLValue": false,
                            "isPure": false,
                            "lValueRequested": false,
                            "leftExpression": {
                              "id": 51613,
                              "name": "res",
                              "nodeType": "Identifier",
                              "overloadedDeclarations": [],
                              "referencedDeclaration": 51548,
                              "src": "4294:3:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_uint256",
                                "typeString": "uint256"
                              }
                            },
                            "nodeType": "BinaryOperation",
                            "operator": "/",
                            "rightExpression": {
                              "id": 51614,
                              "name": "d",
                              "nodeType": "Identifier",
                              "overloadedDeclarations": [],
                              "referencedDeclaration": 51543,
                              "src": "4300:1:52",
                              "typeDescriptions": {
                                "typeIdentifier": "t_uint256",
                                "typeString": "uint256"
                              }
                            },
                            "src": "4294:7:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_uint256",
                              "typeString": "uint256"
                            }
                          },
                          "src": "4288:13:52",
                          "typeDescriptions": {
                            "typeIdentifier": "t_uint256",
                            "typeString": "uint256"
                          }
                        },
                        "id": 51617,
                        "nodeType": "ExpressionStatement",
                        "src": "4288:13:52"
                      },
                      {
                        "expression": {
                          "id": 51619,
                          "isConstant": false,
                          "isLValue": false,
                          "isPure": false,
                          "lValueRequested": false,
                          "nodeType": "UnaryOperation",
                          "operator": "--",
                          "prefix": false,
                          "src": "4315:11:52",
                          "subExpression": {
                            "id": 51618,
                            "name": "ndReverse",
                            "nodeType": "Identifier",
                            "overloadedDeclarations": [],
                            "referencedDeclaration": 51555,
                            "src": "4315:9:52",
                            "typeDescriptions": {
                              "typeIdentifier": "t_uint8",
                              "typeString": "uint8"
                            }
                          },
                          "typeDescriptions": {
                            "typeIdentifier": "t_uint8",
                            "typeString": "uint8"
                          }
                        },
                        "id": 51620,
                        "nodeType": "ExpressionStatement",
                        "src": "4315:11:52"
                      }
                    ]
                  },
                  "condition": {
                    "commonType": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    },
                    "id": 51611,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "leftExpression": {
                      "id": 51609,
                      "name": "ndReverse",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 51555,
                      "src": "4259:9:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint8",
                        "typeString": "uint8"
                      }
                    },
                    "nodeType": "BinaryOperation",
                    "operator": ">",
                    "rightExpression": {
                      "hexValue": "30",
                      "id": 51610,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": true,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "4271:1:52",
                      "typeDescriptions": {
                        "typeIdentifier": "t_rational_0_by_1",
                        "typeString": "int_const 0"
                      },
                      "value": "0"
                    },
                    "src": "4259:13:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bool",
                      "typeString": "bool"
                    }
                  },
                  "id": 51622,
                  "nodeType": "WhileStatement",
                  "src": "4252:85:52"
                }
              ]
            },
            "documentation": {
              "id": 51537,
              "nodeType": "StructuredDocumentation",
              "src": "3556:75:52",
              "text": " @notice Helper method to compute scale: x * (y / d) ^ n."
            },
            "functionSelector": "e47126d0",
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "safeUnutilizedPow",
            "nameLocation": "3645:17:52",
            "parameters": {
              "id": 51546,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 51539,
                  "mutability": "mutable",
                  "name": "x",
                  "nameLocation": "3680:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51624,
                  "src": "3672:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51538,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "3672:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51541,
                  "mutability": "mutable",
                  "name": "y",
                  "nameLocation": "3699:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51624,
                  "src": "3691:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51540,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "3691:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51543,
                  "mutability": "mutable",
                  "name": "d",
                  "nameLocation": "3718:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51624,
                  "src": "3710:9:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51542,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "3710:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 51545,
                  "mutability": "mutable",
                  "name": "n",
                  "nameLocation": "3735:1:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51624,
                  "src": "3729:7:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint8",
                    "typeString": "uint8"
                  },
                  "typeName": {
                    "id": 51544,
                    "name": "uint8",
                    "nodeType": "ElementaryTypeName",
                    "src": "3729:5:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint8",
                      "typeString": "uint8"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "3662:80:52"
            },
            "returnParameters": {
              "id": 51549,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 51548,
                  "mutability": "mutable",
                  "name": "res",
                  "nameLocation": "3772:3:52",
                  "nodeType": "VariableDeclaration",
                  "scope": 51624,
                  "src": "3764:11:52",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 51547,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "3764:7:52",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "3763:13:52"
            },
            "scope": 51625,
            "stateMutability": "pure",
            "virtual": false,
            "visibility": "public"
          }
        ],
        "abstract": false,
        "baseContracts": [
          {
            "baseName": {
              "id": 51170,
              "name": "Test",
              "nameLocations": [
                "312:4:52"
              ],
              "nodeType": "IdentifierPath",
              "referencedDeclaration": 14893,
              "src": "312:4:52"
            },
            "id": 51171,
            "nodeType": "InheritanceSpecifier",
            "src": "312:4:52"
          }
        ],
        "canonicalName": "LibPowMathTest",
        "contractDependencies": [],
        "contractKind": "contract",
        "fullyImplemented": true,
        "linearizedBaseContracts": [
          51625,
          14893,
          14842,
          10378,
          10053,
          9260,
          7200,
          6462,
          4969,
          5035,
          5032
        ],
        "name": "LibPowMathTest",
        "nameLocation": "294:14:52",
        "scope": 51626,
        "usedErrors": [],
        "usedEvents": [
          2683,
          2687,
          2691,
          2695,
          2699,
          2703,
          2707,
          2711,
          2717,
          2723,
          2731,
          2739,
          2745,
          2751,
          2757,
          2763,
          5057,
          5062,
          5067,
          5074,
          5081,
          5088
        ]
      }
    ],
    "license": "UNLICENSED"
  },
  "id": 52
}